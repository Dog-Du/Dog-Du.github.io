<!DOCTYPE html><html lang="cn-ZH" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Go学习 | DogDu's blog</title><meta name="author" content="DogDu"><meta name="copyright" content="DogDu"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="学习Go基本语法">
<meta property="og:type" content="article">
<meta property="og:title" content="Go学习">
<meta property="og:url" content="https://dog-du.github.io/posts/27248.html">
<meta property="og:site_name" content="DogDu&#39;s blog">
<meta property="og:description" content="学习Go基本语法">
<meta property="og:locale" content="cn_ZH">
<meta property="og:image" content="https://dog-du.github.io/img/top_img.jpg">
<meta property="article:published_time" content="2025-05-11T03:36:44.000Z">
<meta property="article:modified_time" content="2025-05-22T01:54:11.961Z">
<meta property="article:author" content="DogDu">
<meta property="article:tag" content="学习">
<meta property="article:tag" content="未完成">
<meta property="article:tag" content="Go">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://dog-du.github.io/img/top_img.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Go学习",
  "url": "https://dog-du.github.io/posts/27248.html",
  "image": "https://dog-du.github.io/img/top_img.jpg",
  "datePublished": "2025-05-11T03:36:44.000Z",
  "dateModified": "2025-05-22T01:54:11.961Z",
  "author": [
    {
      "@type": "Person",
      "name": "DogDu",
      "url": "https://dog-du.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/head.jpg"><link rel="canonical" href="https://dog-du.github.io/posts/27248.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":300,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Go学习',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="alternate" href="/atom.xml" title="DogDu's blog" type="application/atom+xml">
</head><body><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/top_img.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="/img/head.jpg" alt="Logo"><span class="site-name">DogDu's blog</span></a><a class="nav-page-title" href="/"><span class="site-name">Go学习</span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">Go学习</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2025-05-11T03:36:44.000Z" title="Created 2025-05-11 11:36:44">2025-05-11</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2025-05-22T01:54:11.961Z" title="Updated 2025-05-22 09:54:11">2025-05-22</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%AD%A6%E4%B9%A0%E7%B1%BB/">学习类</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p>
    <b>
        </b></p><center><b>学习Go，我也要成为Go学长。</b></center><b>
    </b>
<p></p>
<h1 id="环境配置"><a class="markdownIt-Anchor" href="#环境配置"></a> 环境配置</h1>
<p>环境变量：</p>
<p><img src="/img/go%E5%AD%A6%E4%B9%A0/image-20250511113903776.png" alt="image-20250511113903776"></p>
<p>备注：GOPROXY由于国内的网络环境，可以通过配置GOPROXY避免DNS污染导致的模块拉取缓慢或失败的问题，加速你的构建。<br>
<code>go env -w GOPROXY=https://goproxy.cn,direct</code></p>
<p>或者</p>
<p><code>export GOPROXY="https://goproxy.cn,direct"</code></p>
<h1 id="简单包管理"><a class="markdownIt-Anchor" href="#简单包管理"></a> 简单包管理</h1>
<p>在代码中引入模块，如：</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"github.com/valyala/fasthttp"</span></span><br><span class="line">  <span class="string">"go.uber.org/zap"</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">var</span> logger *zap.Logger</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> {</span><br><span class="line">  logger, _ = zap.NewProduction()</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fastHTTPHandler</span><span class="params">(ctx *fasthttp.RequestCtx)</span></span> {</span><br><span class="line">  logger.Info(<span class="string">"hello, go module"</span>, zap.ByteString(<span class="string">"uri"</span>, ctx.RequestURI()))</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">  fasthttp.ListenAndServe(<span class="string">":8081"</span>, fastHTTPHandler)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>然后在目录下: <code>go mod init &lt;package_name&gt;</code> 即可自动下载依赖，之后 <code>go build</code>即可</p>
<h3 id="init-函数go-包的初始化函数"><a class="markdownIt-Anchor" href="#init-函数go-包的初始化函数"></a> init 函数：Go 包的初始化函数</h3>
<p>除了前面讲过的 main.main 函数之外，Go 语言还有一个特殊函数，它就是用于<strong>进行包初始化的 init 函数</strong>了。</p>
<p>和 main.main 函数一样，init 函数也是一个无参数无返回值的函数。</p>
<p>init不能显示调用，</p>
<h1 id="简单语法"><a class="markdownIt-Anchor" href="#简单语法"></a> 简单语法</h1>
<h2 id="变量声明"><a class="markdownIt-Anchor" href="#变量声明"></a> 变量声明：</h2>
<p><img src="/img/go%E5%AD%A6%E4%B9%A0/image-20250511210455481.png" alt="image-20250511210455481"></p>
<p>类型的默认值</p>
<p><img src="/img/go%E5%AD%A6%E4%B9%A0/image-20250511210508114.png" alt="image-20250511210508114"></p>
<p><img src="/img/go%E5%AD%A6%E4%B9%A0/image-20250511213342719.png" alt="image-20250511213342719"></p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 变量声明块：</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    a <span class="type">int</span> = <span class="number">128</span></span><br><span class="line">    b <span class="type">int8</span> = <span class="number">6</span></span><br><span class="line">    s <span class="type">string</span> = <span class="string">"hello"</span></span><br><span class="line">    c <span class="type">rune</span> = <span class="string">'A'</span></span><br><span class="line">    t <span class="type">bool</span> = <span class="literal">true</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多个变量一起声明：</span></span><br><span class="line"><span class="keyword">var</span> a, b, c <span class="type">int</span> = <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    a, b, c <span class="type">int</span> = <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span></span><br><span class="line">    c, d, e <span class="type">rune</span> = <span class="string">'C'</span>, <span class="string">'D'</span>, <span class="string">'E'</span> <span class="comment">// rune为处理utf-8字符集的数据类型</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 省略类型的变量声明：</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">13</span> <span class="comment">// 类似C++: auto b = 13</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="type">int32</span>(<span class="number">13</span>) <span class="comment">// 指定类型。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b <span class="comment">// error，显然是错误的。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个语句中声明多个不同类型的变量：</span></span><br><span class="line"><span class="keyword">var</span> a, b, c = <span class="number">12</span>, <span class="string">'A'</span>, <span class="string">"hello"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 短变量声明：</span></span><br><span class="line">a := <span class="number">12</span></span><br><span class="line">b := <span class="string">'A'</span></span><br><span class="line">c := <span class="string">"hello"</span></span><br><span class="line"></span><br><span class="line">a, b, c := <span class="number">12</span>, <span class="string">'A'</span>, <span class="string">"hello"</span></span><br></pre></td></tr></tbody></table></figure>
<p>变量类型：</p>
<ul>
<li>包级变量：首大写导出，否则包内</li>
<li>局部变量：函数或者方法中的变量，仅内部可见。</li>
</ul>
<p>小结论：<strong>包级变量只能使用带有 var 关键字的变量声明形式，不能使用短变量声明形式，但在形式细节上可以有一定灵活度。</strong></p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// $GOROOT/src/io/io.go</span></span><br><span class="line"><span class="comment">// 包级变量：多使用语法糖，省略类型信息</span></span><br><span class="line"><span class="keyword">var</span> ErrShortWrite = errors.New(<span class="string">"short write"</span>)</span><br><span class="line"><span class="keyword">var</span> ErrShortBuffer = errors.New(<span class="string">"short buffer"</span>)</span><br><span class="line"><span class="keyword">var</span> EOF = errors.New(<span class="string">"EOF"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要具体写出类型时：</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第一种：</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">13</span> <span class="comment">// 使用默认类型</span></span><br><span class="line"><span class="keyword">var</span> b <span class="type">int32</span> = <span class="number">17</span>  <span class="comment">// 显式指定类型</span></span><br><span class="line"><span class="keyword">var</span> f <span class="type">float32</span> = <span class="number">3.14</span> <span class="comment">// 显式指定类型</span></span><br><span class="line"><span class="comment">//第二种（更推荐，符合格式）：</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">13</span> <span class="comment">// 使用默认类型</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="type">int32</span>(<span class="number">17</span>) <span class="comment">// 显式指定类型</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="type">float32</span>(<span class="number">3.14</span>) <span class="comment">// 显式指定类型</span></span><br><span class="line"><span class="comment">//第三种（最推荐）：</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">  a = <span class="number">13</span></span><br><span class="line">  b = <span class="type">int32</span>(<span class="number">17</span>)</span><br><span class="line">  f = <span class="type">float32</span>(<span class="number">3.14</span>)</span><br><span class="line">)</span><br><span class="line"><span class="comment">//第四种（不太推荐）：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">  a = <span class="number">13</span></span><br><span class="line">  b <span class="type">int32</span> = <span class="number">17</span></span><br><span class="line">  f <span class="type">float32</span> = <span class="number">3.14</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//声明，但是延迟初始化。</span></span><br><span class="line"><span class="keyword">var</span> a <span class="type">int32</span></span><br><span class="line"><span class="keyword">var</span> f <span class="type">float64</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//把延迟初始化放在一起，其他的放在一起。</span></span><br><span class="line"><span class="comment">// $GOROOT/src/net/net.go</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    netGo  <span class="type">bool</span> </span><br><span class="line">    netCgo <span class="type">bool</span> </span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    aLongTimeAgo = time.Unix(<span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">    noDeadline = time.Time{}</span><br><span class="line">    noCancel   = (<span class="keyword">chan</span> <span class="keyword">struct</span>{})(<span class="literal">nil</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//就近原则：声明的包级变量尽可能靠近用到的地方</span></span><br><span class="line"><span class="comment">// $GOROOT/src/net/http/request.go</span></span><br><span class="line"><span class="keyword">var</span> ErrNoCookie = errors.New(<span class="string">"http: named cookie not present"</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Request)</span></span> Cookie(name <span class="type">string</span>) (*Cookie, <span class="type">error</span>) {</span><br><span class="line">    <span class="keyword">for</span> _, c := <span class="keyword">range</span> readCookies(r.Header, name) {</span><br><span class="line">        <span class="keyword">return</span> c, <span class="literal">nil</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, ErrNoCookie</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>局部变量声明：</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一类：对于延迟初始化的局部变量声明，我们采用通用的变量声明形式</span></span><br><span class="line"><span class="keyword">var</span> err <span class="type">error</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第二类：对于声明且显式初始化的局部变量，建议使用短变量声明形式</span></span><br><span class="line">a := <span class="number">17</span></span><br><span class="line">f := <span class="number">3.14</span></span><br><span class="line">s := <span class="string">"hello, gopher!"</span></span><br><span class="line"><span class="comment">//不接受默认类型的变量，我们依然可以使用短变量声明形式</span></span><br><span class="line">a := <span class="type">int32</span>(<span class="number">17</span>)</span><br><span class="line">f := <span class="type">float32</span>(<span class="number">3.14</span>)</span><br><span class="line">s := []<span class="type">byte</span>(<span class="string">"hello, gopher!"</span>)</span><br><span class="line"><span class="comment">//这里我们还要注意：尽量在分支控制时使用短变量声明形式。</span></span><br><span class="line"><span class="comment">//如：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="built_in">len</span>(s); i &gt; <span class="number">0</span>; { </span><br><span class="line">        r, size := utf8.DecodeLastRuneInString(s[:i])</span><br><span class="line">        i -= size</span><br><span class="line">        <span class="keyword">for</span> _, c := <span class="keyword">range</span> chars {</span><br><span class="line">            <span class="keyword">if</span> r == c {</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p><img src="/img/go%E5%AD%A6%E4%B9%A0/image-20250511212427442.png" alt="image-20250511212427442"></p>
<h2 id="代码块与作用域"><a class="markdownIt-Anchor" href="#代码块与作用域"></a> 代码块与作用域</h2>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">11</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">(n <span class="type">int</span>)</span></span> {</span><br><span class="line">  a := <span class="number">1</span></span><br><span class="line">  a += n</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">  fmt.Println(<span class="string">"a ="</span>, a) <span class="comment">// 11</span></span><br><span class="line">  foo(<span class="number">5</span>)</span><br><span class="line">  fmt.Println(<span class="string">"after calling foo, a ="</span>, a) <span class="comment">// 11</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面代码中，foo 并没有修改包级变量 a</span></span><br></pre></td></tr></tbody></table></figure>
<p><img src="/img/go%E5%AD%A6%E4%B9%A0/image-20250511212946671.png" alt="image-20250511212946671"></p>
<p><strong>宇宙代码块（Universe Block）</strong>，它囊括的范围最大，所有 Go 源码都在这个隐式代码块中。</p>
<p><strong>包代码块（Package Block）</strong>，每个 Go 包都对应一个隐式包代码块，每个包代码块包含了该包中的所有 Go 源码，不管这些代码分布在这个包里的多少个的源文件中。</p>
<p><strong>文件代码块（File Block）</strong>，每个 Go 源文件都对应着一个文件代码块，也就是说一个 Go 包如果有多个源文件，那么就会有多个对应的文件代码块。</p>
<p><strong>隐式代码块</strong>就在控制语句层面了，包括 if、for 与 switch。我们可以把每个控制语句都视为在它自己的隐式代码块里。</p>
<p><strong>一个标识符的作用域就是指这个标识符在被声明后可以被有效使用的源码区域</strong>。</p>
<p><strong>声明于外层代码块中的标识符，其作用域包括所有内层代码块</strong>。</p>
<h2 id="类型"><a class="markdownIt-Anchor" href="#类型"></a> 类型</h2>
<p><img src="/img/go%E5%AD%A6%E4%B9%A0/image-20250512205021589.png" alt="image-20250512205021589"></p>
<p>平台相关：</p>
<p><img src="/img/go%E5%AD%A6%E4%B9%A0/image-20250512205045466.png" alt="image-20250512205045466"></p>
<p>Go的整数也是补码实现。</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字面量。</span></span><br><span class="line">a := <span class="number">53</span>        <span class="comment">// 十进制</span></span><br><span class="line">b := <span class="number">0700</span>      <span class="comment">// 八进制，以"0"为前缀</span></span><br><span class="line">c1 := <span class="number">0xaabbcc</span> <span class="comment">// 十六进制，以"0x"为前缀</span></span><br><span class="line">c2 := <span class="number">0Xddeeff</span> <span class="comment">// 十六进制，以"0X"为前缀</span></span><br><span class="line">d1 := <span class="number">0</span>b10000001 <span class="comment">// 二进制，以"0b"为前缀</span></span><br><span class="line">d2 := <span class="number">0</span>B10000001 <span class="comment">// 二进制，以"0B"为前缀</span></span><br><span class="line">e1 := <span class="number">0o700</span>      <span class="comment">// 八进制，以"0o"为前缀</span></span><br><span class="line">e2 := <span class="number">0O700</span>      <span class="comment">// 八进制，以"0O"为前缀</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用下划线_ 分割增加可读性 (Go 1.13之后)</span></span><br><span class="line">a := <span class="number">5_3_7</span>   <span class="comment">// 十进制: 537</span></span><br><span class="line">b := <span class="number">0</span>b_1000_0111  <span class="comment">// 二进制位表示为10000111 </span></span><br><span class="line">c1 := <span class="number">0_700</span>  <span class="comment">// 八进制: 0700</span></span><br><span class="line">c2 := <span class="number">0o_700</span> <span class="comment">// 八进制: 0700</span></span><br><span class="line">d1 := <span class="number">0x_5c_6d</span> <span class="comment">// 十六进制：0x5c6d</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="keyword">var</span> a <span class="type">int8</span> = <span class="number">59</span></span><br><span class="line">fmt.Printf(<span class="string">"%b\n"</span>, a) <span class="comment">//输出二进制：111011</span></span><br><span class="line">fmt.Printf(<span class="string">"%d\n"</span>, a) <span class="comment">//输出十进制：59</span></span><br><span class="line">fmt.Printf(<span class="string">"%o\n"</span>, a) <span class="comment">//输出八进制：73</span></span><br><span class="line">fmt.Printf(<span class="string">"%O\n"</span>, a) <span class="comment">//输出八进制(带0o前缀)：0o73</span></span><br><span class="line">fmt.Printf(<span class="string">"%x\n"</span>, a) <span class="comment">//输出十六进制(小写)：3b</span></span><br><span class="line">fmt.Printf(<span class="string">"%X\n"</span>, a) <span class="comment">//输出十六进制(大写)：3B</span></span><br></pre></td></tr></tbody></table></figure>
<p>浮点数（均为平台无关）：</p>
<p><img src="/img/go%E5%AD%A6%E4%B9%A0/image-20250512205634216.png" alt="image-20250512205634216"></p>
<p>Go中浮点数默认为<code>float64</code></p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 浮点数字面量</span></span><br><span class="line"><span class="number">3.1415</span></span><br><span class="line"><span class="number">.15</span>  <span class="comment">// 整数部分如果为0，整数部分可以省略不写</span></span><br><span class="line"><span class="number">81.80</span></span><br><span class="line"><span class="number">82.</span> <span class="comment">// 小数部分如果为0，小数点后的0可以省略不写</span></span><br><span class="line"><span class="number">6674.28e-2</span> <span class="comment">// 6674.28 * 10^(-2) = 66.742800</span></span><br><span class="line"><span class="number">.12345E+5</span>  <span class="comment">// 0.12345 * 10^5 = 12345.000000</span></span><br><span class="line"></span><br><span class="line"><span class="number">0x2.p10</span>  <span class="comment">// 2.0 * 2^10 = 2048.000000</span></span><br><span class="line"><span class="number">0x1.Fp+0</span> <span class="comment">// 1.9375 * 2^0 = 1.937500</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f <span class="type">float64</span> = <span class="number">123.45678</span></span><br><span class="line">fmt.Printf(<span class="string">"%f\n"</span>, f) <span class="comment">// 123.456780</span></span><br><span class="line">fmt.Printf(<span class="string">"%e\n"</span>, f) <span class="comment">// 1.234568e+02</span></span><br><span class="line">fmt.Printf(<span class="string">"%x\n"</span>, f) <span class="comment">// 0x1.edd3be22e5de1p+06</span></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 复数初始化。</span></span><br><span class="line"><span class="keyword">var</span> c = <span class="number">5</span> + <span class="number">6i</span></span><br><span class="line"><span class="keyword">var</span> d = <span class="number">0o123</span> + <span class="number">.12345E+5i</span> <span class="comment">// 83+12345i</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第二种，Go 还提供了 complex 函数，方便我们创建一个 complex128 类型值：</span></span><br><span class="line"><span class="keyword">var</span> c = <span class="built_in">complex</span>(<span class="number">5</span>, <span class="number">6</span>) <span class="comment">// 5 + 6i</span></span><br><span class="line"><span class="keyword">var</span> d = <span class="built_in">complex</span>(<span class="number">0o123</span>, <span class="number">.12345E+5</span>) <span class="comment">// 83+12345i</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三种，你还可以通过 Go 提供的预定义的函数 real 和 imag，</span></span><br><span class="line"><span class="comment">// 来获取一个复数的实部与虚部，返回值为一个浮点类型：</span></span><br><span class="line"><span class="keyword">var</span> c = <span class="built_in">complex</span>(<span class="number">5</span>, <span class="number">6</span>) <span class="comment">// 5 + 6i</span></span><br><span class="line">r := <span class="built_in">real</span>(c) <span class="comment">// 5.000000</span></span><br><span class="line">i := <span class="built_in">imag</span>(c) <span class="comment">// 6.000000</span></span><br></pre></td></tr></tbody></table></figure>
<p>自定义类型：</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyInt <span class="type">int32</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> m <span class="type">int</span> = <span class="number">5</span></span><br><span class="line"><span class="keyword">var</span> n <span class="type">int32</span> = <span class="number">6</span></span><br><span class="line"><span class="keyword">var</span> a MyInt = m <span class="comment">// 错误：在赋值中不能将m（int类型）作为MyInt类型使用</span></span><br><span class="line"><span class="keyword">var</span> a MyInt = n <span class="comment">// 错误：在赋值中不能将n（int32类型）作为MyInt类型使用</span></span><br><span class="line"><span class="keyword">var</span> a MyInt = MyInt(m) <span class="comment">// ok</span></span><br><span class="line"><span class="keyword">var</span> a MyInt = MyInt(n) <span class="comment">// ok</span></span><br></pre></td></tr></tbody></table></figure>
<p>类型别名：</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyInt = <span class="type">int32</span></span><br><span class="line"><span class="keyword">var</span> n <span class="type">int32</span> = <span class="number">6</span></span><br><span class="line"><span class="keyword">var</span> a MyInt = n <span class="comment">// ok</span></span><br></pre></td></tr></tbody></table></figure>
<p>字符串：</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">  GO_SLOGAN = <span class="string">"less is more"</span> <span class="comment">// GO_SLOGAN是string类型常量</span></span><br><span class="line">  s1 = <span class="string">"hello, gopher"</span>       <span class="comment">// s1是string类型常量</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">var</span> s2 = <span class="string">"I love go"</span> <span class="comment">// s2是string类型变量</span></span><br></pre></td></tr></tbody></table></figure>
<p><strong>string 类型的数据是不可变的，提高了字符串的并发安全性和存储利用率。</strong></p>
<p>Go 字符串可以被多个 Goroutine 共享，开发者不用因为担心并发安全问题，使用会带来一定开销的同步机制。</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s <span class="type">string</span> = <span class="string">"hello"</span></span><br><span class="line">s[<span class="number">0</span>] = <span class="string">'k'</span>   <span class="comment">// 错误：字符串的内容是不可改变的</span></span><br><span class="line">s = <span class="string">"gopher"</span> <span class="comment">// ok</span></span><br></pre></td></tr></tbody></table></figure>
<p><strong>没有结尾’\0’，而且获取长度的时间复杂度是常数时间，消除了获取字符串长度的开销。</strong></p>
<p><strong>原生支持“所见即所得”的原始字符串，大大降低构造多行字符串时的心智负担。</strong></p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s <span class="type">string</span> = <span class="string">`         ,_---~~~~~----._</span></span><br><span class="line"><span class="string">    _,,_,*^____      _____*g*\"*,--,</span></span><br><span class="line"><span class="string">   / __/ /'     ^.  /      \ ^@q   f</span></span><br><span class="line"><span class="string">  [  @f | @))    |  | @))   l  0 _/</span></span><br><span class="line"><span class="string">   \/   \~____ / __ \_____/     \</span></span><br><span class="line"><span class="string">    |           _l__l_           I</span></span><br><span class="line"><span class="string">    }          [______]           I</span></span><br><span class="line"><span class="string">    ]            | | |            |</span></span><br><span class="line"><span class="string">    ]             ~ ~             |</span></span><br><span class="line"><span class="string">    |                            |</span></span><br><span class="line"><span class="string">     |                           |`</span></span><br><span class="line">fmt.Println(s)</span><br></pre></td></tr></tbody></table></figure>
<p><strong>对非 ASCII 字符提供原生支持，消除了源码在不同环境下显示乱码的可能。</strong></p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> s = <span class="string">"中国人"</span></span><br><span class="line">fmt.Printf(<span class="string">"the length of s = %d\n"</span>, <span class="built_in">len</span>(s)) <span class="comment">// 9-&gt;非ASCII字符占多个字节</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s); i++ {</span><br><span class="line">  fmt.Printf(<span class="string">"0x%x "</span>, s[i]) <span class="comment">// 0xe4 0xb8 0xad 0xe5 0x9b 0xbd 0xe4 0xba 0xba</span></span><br><span class="line">}</span><br><span class="line">fmt.Printf(<span class="string">"\n"</span>)</span><br></pre></td></tr></tbody></table></figure>
<h3 id="rune-类型与字符字面值"><a class="markdownIt-Anchor" href="#rune-类型与字符字面值"></a> rune 类型与字符字面值</h3>
<p>Go 使用 rune 这个类型来表示一个 Unicode 码点。rune 本质上是 int32 类型的别名类型，它与 int32 类型是完全等价的，定义：</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// $GOROOT/src/builtin.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="type">rune</span> = <span class="type">int32</span></span><br></pre></td></tr></tbody></table></figure>
<p><img src="/img/go%E5%AD%A6%E4%B9%A0/image-20250512212043390.png" alt="image-20250512212043390"></p>
<p>Go字符串的内部表示：</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// $GOROOT/src/reflect/value.go</span></span><br><span class="line"><span class="comment">// StringHeader是一个string的运行时表示</span></span><br><span class="line"><span class="keyword">type</span> StringHeader <span class="keyword">struct</span> {</span><br><span class="line">    Data <span class="type">uintptr</span></span><br><span class="line">    Len  <span class="type">int</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong>string 类型其实是一个“描述符”，它本身并不真正存储字符串数据，而仅是由一个指向底层存储的指针和字符串的长度字段组成的。</strong></p>
<p>了解了 string 类型的实现原理后，我们还可以得到这样一个结论，那就是**我们直接将 string 类型通过函数 / 方法参数传入也不会带来太多的开销。**因为传入的仅仅是一个“描述符”，而不是真正的字符串数据。</p>
<p>下标索引：</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">"中国人"</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s); i++ {</span><br><span class="line">  fmt.Printf(<span class="string">"index: %d, value: 0x%x\n"</span>, i, s[i])</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>输出：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">index: 0, value: 0xe4</span><br><span class="line">index: 1, value: 0xb8</span><br><span class="line">index: 2, value: 0xad</span><br><span class="line">index: 3, value: 0xe5</span><br><span class="line">index: 4, value: 0x9b</span><br><span class="line">index: 5, value: 0xbd</span><br><span class="line">index: 6, value: 0xe4</span><br><span class="line">index: 7, value: 0xba</span><br><span class="line">index: 8, value: 0xba</span><br></pre></td></tr></tbody></table></figure>
<p>字符迭代：</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">"中国人"</span></span><br><span class="line"><span class="keyword">for</span> i, v := <span class="keyword">range</span> s {</span><br><span class="line">    fmt.Printf(<span class="string">"index: %d, value: 0x%x\n"</span>, i, v)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>输出（与下标检索不一样）：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">index: 0, value: 0x4e2d</span><br><span class="line">index: 3, value: 0x56fd</span><br><span class="line">index: 6, value: 0x4eba</span><br></pre></td></tr></tbody></table></figure>
<p>按照unicode字符的码点输出。</p>
<p>通过 Go 提供的内置函数 len，我们只能获取字符串内容的长度（字节个数）。当然了，获取字符串中字符个数更专业的方法，是调用标准库 UTF-8 包中的 RuneCountInString 函数。</p>
<p>字符串连接：</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="string">"Rob Pike, "</span></span><br><span class="line">s = s + <span class="string">"Robert Griesemer, "</span></span><br><span class="line">s += <span class="string">" Ken Thompson"</span></span><br><span class="line">fmt.Println(s) <span class="comment">// Rob Pike, Robert Griesemer, Ken Thompson</span></span><br></pre></td></tr></tbody></table></figure>
<p>除了这个方法外，Go 还提供了 strings.Builder、strings.Join、fmt.Sprintf 等函数来进行字符串连接操作。</p>
<p>如果能知道拼接字符串的个数，那么使用<code>bytes.Buffer</code>和<code>strings.Builder</code>的<code>Grows</code>申请空间后，性能是最好的；如果不能确定长度，那么<code>bytes.Buffer</code>和<code>strings.Builder</code>也比“+”和<code>fmt.Sprintf</code>性能好很多。</p>
<p><code>bytes.Buffer</code>与<code>strings.Builder</code>，<code>strings.Builder</code>更合适，因为<code>bytes.Buffer</code>转化为字符串时重新申请了一块空间，存放生成的字符串变量，而 <code>strings.Builder </code>直接将底层的 []byte 转换成了字符串类型返回了回来。</p>
<p>bytes.Buffer 的注释中还特意提到了：</p>
<p><code>To build strings more efficiently, see the strings.Builder type.</code></p>
<p>字符串比较：</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">        <span class="comment">// ==</span></span><br><span class="line">        s1 := <span class="string">"世界和平"</span></span><br><span class="line">        s2 := <span class="string">"世界"</span> + <span class="string">"和平"</span></span><br><span class="line">        fmt.Println(s1 == s2) <span class="comment">// true</span></span><br><span class="line">        <span class="comment">// !=</span></span><br><span class="line">        s1 = <span class="string">"Go"</span></span><br><span class="line">        s2 = <span class="string">"C"</span></span><br><span class="line">        fmt.Println(s1 != s2) <span class="comment">// true</span></span><br><span class="line">        <span class="comment">// &lt; and &lt;=</span></span><br><span class="line">        s1 = <span class="string">"12345"</span></span><br><span class="line">        s2 = <span class="string">"23456"</span></span><br><span class="line">        fmt.Println(s1 &lt; s2)  <span class="comment">// true</span></span><br><span class="line">        fmt.Println(s1 &lt;= s2) <span class="comment">// true</span></span><br><span class="line">        <span class="comment">// &gt; and &gt;=</span></span><br><span class="line">        s1 = <span class="string">"12345"</span></span><br><span class="line">        s2 = <span class="string">"123"</span></span><br><span class="line">        fmt.Println(s1 &gt; s2)  <span class="comment">// true</span></span><br><span class="line">        fmt.Println(s1 &gt;= s2) <span class="comment">// true</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>字符串转换：</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s <span class="type">string</span> = <span class="string">"中国人"</span></span><br><span class="line">                      </span><br><span class="line"><span class="comment">// string -&gt; []rune</span></span><br><span class="line">rs := []<span class="type">rune</span>(s) </span><br><span class="line">fmt.Printf(<span class="string">"%x\n"</span>, rs) <span class="comment">// [4e2d 56fd 4eba]</span></span><br><span class="line">                </span><br><span class="line"><span class="comment">// string -&gt; []byte</span></span><br><span class="line">bs := []<span class="type">byte</span>(s) </span><br><span class="line">fmt.Printf(<span class="string">"%x\n"</span>, bs) <span class="comment">// e4b8ade59bbde4baba</span></span><br><span class="line">                </span><br><span class="line"><span class="comment">// []rune -&gt; string</span></span><br><span class="line">s1 := <span class="type">string</span>(rs)</span><br><span class="line">fmt.Println(s1) <span class="comment">// 中国人</span></span><br><span class="line">                </span><br><span class="line"><span class="comment">// []byte -&gt; string</span></span><br><span class="line">s2 := <span class="type">string</span>(bs)</span><br><span class="line">fmt.Println(s2) <span class="comment">// 中国人</span></span><br></pre></td></tr></tbody></table></figure>
<p>这样的转型看似简单，但无论是 string 转切片，还是切片转 string，这类转型背后也是有着一定开销的。这些开销的根源就在于 string 是不可变的，运行时要为转换后的类型分配新内存。</p>
<h2 id="常量"><a class="markdownIt-Anchor" href="#常量"></a> 常量</h2>
<ul>
<li>支持无类型常量；</li>
<li>支持隐式自动转型；</li>
<li>可用于实现枚举。</li>
</ul>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Pi <span class="type">float64</span> = <span class="number">3.14159265358979323846</span> <span class="comment">// 单行常量声明</span></span><br><span class="line"><span class="comment">// 以const代码块形式声明常量</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    size <span class="type">int64</span> = <span class="number">4096</span></span><br><span class="line">    i, j, s = <span class="number">13</span>, <span class="number">14</span>, <span class="string">"bar"</span> <span class="comment">// 单行声明多个常量</span></span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure>
<p><strong>Go 常量的类型只局限于前面我们学过的 Go 基本数据类型，包括数值类型、字符串类型，以及只有两个取值（true 和 false）的布尔类型。</strong></p>
<p>无类型常量：</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//错误：</span></span><br><span class="line"><span class="keyword">type</span> myInt <span class="type">int</span></span><br><span class="line"><span class="keyword">const</span> n myInt = <span class="number">13</span></span><br><span class="line"><span class="keyword">const</span> m <span class="type">int</span> = n + <span class="number">5</span> <span class="comment">// 编译器报错：cannot use n + 5 (type myInt) as type int in const initializer</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">var</span> a <span class="type">int</span> = <span class="number">5</span></span><br><span class="line">    fmt.Println(a + n) <span class="comment">// 编译器报错：invalid operation: a + n (mismatched types int and myInt)</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//正确：</span></span><br><span class="line"><span class="keyword">type</span> myInt <span class="type">int</span></span><br><span class="line"><span class="keyword">const</span> n myInt = <span class="number">13</span></span><br><span class="line"><span class="keyword">const</span> m <span class="type">int</span> = <span class="type">int</span>(n) + <span class="number">5</span>  <span class="comment">// OK</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">var</span> a <span class="type">int</span> = <span class="number">5</span></span><br><span class="line">    fmt.Println(a + <span class="type">int</span>(n))  <span class="comment">// 输出：18</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong>即便两个类型拥有着相同的底层类型，但它们仍然是不同的数据类型，不可以被相互比较或混在一个表达式中进行运算。</strong></p>
<p>无类型：</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> myInt <span class="type">int</span></span><br><span class="line"><span class="keyword">const</span> n = <span class="number">13</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">var</span> a myInt = <span class="number">5</span></span><br><span class="line">    fmt.Println(a + n)  <span class="comment">// 输出：18</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>隐式转换：</p>
<p>隐式转型说的就是，对于无类型常量参与的表达式求值，Go 编译器会根据上下文中的类型信息，把无类型常量自动转换为相应的类型后，再参与求值计算，这一转型动作是隐式进行的。</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="number">1333333333</span></span><br><span class="line"><span class="keyword">var</span> k <span class="type">int8</span> = <span class="number">1</span></span><br><span class="line">j := k + m <span class="comment">// 编译器报错：constant 1333333333 overflows int8</span></span><br></pre></td></tr></tbody></table></figure>
<p>这个代码中常量 m 的值 1333333333 已经超出了 int8 类型可以表示的范围，所以我们将它转换为 int8 类型时，就会导致编译器报溢出错误。</p>
<p>枚举实现：</p>
<p><strong>Go 的 const 语法提供了“隐式重复前一个非空表达式”的机制</strong></p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    Apple, Banana = <span class="number">11</span>, <span class="number">22</span></span><br><span class="line">    Strawberry, Grape </span><br><span class="line">    Pear, Watermelon </span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价于：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    Apple, Banana = <span class="number">11</span>, <span class="number">22</span></span><br><span class="line">    Strawberry, Grape  = <span class="number">11</span>, <span class="number">22</span> <span class="comment">// 使用上一行的初始化表达式</span></span><br><span class="line">    Pear, Watermelon  = <span class="number">11</span>, <span class="number">22</span> <span class="comment">// 使用上一行的初始化表达式</span></span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure>
<p>itoa：</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// $GOROOT/src/sync/mutex.go </span></span><br><span class="line"><span class="keyword">const</span> ( </span><br><span class="line">    mutexLocked = <span class="number">1</span> &lt;&lt; <span class="literal">iota</span> <span class="comment">// 1</span></span><br><span class="line">    mutexWoken              <span class="comment">// 2</span></span><br><span class="line">    mutexStarving           <span class="comment">// 4</span></span><br><span class="line">    mutexWaiterShift = <span class="literal">iota</span> <span class="comment">// 3</span></span><br><span class="line">    starvationThresholdNs = <span class="number">1e6</span> <span class="comment">// 1e6</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    Apple, Banana = <span class="literal">iota</span>, <span class="literal">iota</span> + <span class="number">10</span> <span class="comment">// 0, 10 (iota = 0)</span></span><br><span class="line">    Strawberry, Grape <span class="comment">// 1, 11 (iota = 1)</span></span><br><span class="line">    Pear, Watermelon  <span class="comment">// 2, 12 (iota = 2)</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    _ = <span class="literal">iota</span> <span class="comment">// 0 ，空白占位符</span></span><br><span class="line">    Pin1</span><br><span class="line">    Pin2</span><br><span class="line">    Pin3</span><br><span class="line">    _</span><br><span class="line">    Pin5    <span class="comment">// 5   </span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    _ = <span class="literal">iota</span>     </span><br><span class="line">    Blue</span><br><span class="line">    Red </span><br><span class="line">    Yellow     </span><br><span class="line">) </span><br></pre></td></tr></tbody></table></figure>
<h2 id="复合数据类型"><a class="markdownIt-Anchor" href="#复合数据类型"></a> 复合数据类型</h2>
<p>Go 语言原生内置了多种复合数据类型，包括数组、切片（slice）、map、结构体，以及像 channel 这类用于并发程序设计的高级复合数据类型。</p>
<h3 id="数组"><a class="markdownIt-Anchor" href="#数组"></a> 数组</h3>
<p>Go 的数组类型包含两个重要属性：<strong>元素的类型</strong>和<strong>数组长度</strong>（元素的个数）。</p>
<p><code>var arr [N]T</code></p>
<p><strong>如果两个数组类型的元素类型 T 与数组长度 N 都是一样的，那么这两个数组类型是等价的，如果有一个属性不同，它们就是两个不同的数组类型。</strong></p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">(arr [5]<span class="type">int</span>)</span></span> {}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">var</span> arr1 [<span class="number">5</span>]<span class="type">int</span></span><br><span class="line">    <span class="keyword">var</span> arr2 [<span class="number">6</span>]<span class="type">int</span></span><br><span class="line">    <span class="keyword">var</span> arr3 [<span class="number">5</span>]<span class="type">string</span></span><br><span class="line">    foo(arr1) <span class="comment">// ok</span></span><br><span class="line">    foo(arr2) <span class="comment">// 错误：[6]int与函数foo参数的类型[5]int不是同一数组类型</span></span><br><span class="line">    foo(arr3) <span class="comment">// 错误：[5]string与函数foo参数的类型[5]int不是同一数组类型</span></span><br><span class="line">}  </span><br></pre></td></tr></tbody></table></figure>
<p><img src="/img/go%E5%AD%A6%E4%B9%A0/image-20250513104610566.png" alt="image-20250513104610566"></p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">6</span>]<span class="type">int</span>{<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>}</span><br><span class="line">fmt.Println(<span class="string">"数组长度："</span>, <span class="built_in">len</span>(arr))           <span class="comment">// 6</span></span><br><span class="line">fmt.Println(<span class="string">"数组大小："</span>, unsafe.Sizeof(arr)) <span class="comment">// 48</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果没有进行初始化，默认为零值。</span></span><br><span class="line"><span class="keyword">var</span> arr1 [<span class="number">6</span>]<span class="type">int</span> <span class="comment">// [0 0 0 0 0 0]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr2 = [<span class="number">6</span>]<span class="type">int</span> {</span><br><span class="line">    <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span>,</span><br><span class="line">} <span class="comment">// [11 12 13 14 15 16]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr3 = [...]<span class="type">int</span> { <span class="comment">// 通过[...]自动计算出长度</span></span><br><span class="line">    <span class="number">21</span>, <span class="number">22</span>, <span class="number">23</span>,</span><br><span class="line">} <span class="comment">// [21 22 23]</span></span><br><span class="line">fmt.Printf(<span class="string">"%T\n"</span>, arr3) <span class="comment">// [3]int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 稀疏数组的初始化。</span></span><br><span class="line"><span class="keyword">var</span> arr4 = [...]<span class="type">int</span>{</span><br><span class="line">    <span class="number">99</span>: <span class="number">39</span>, <span class="comment">// 将第100个元素(下标值为99)的值赋值为39，其余元素值均为0</span></span><br><span class="line">}</span><br><span class="line">fmt.Printf(<span class="string">"%T\n"</span>, arr4) <span class="comment">// [100]int</span></span><br></pre></td></tr></tbody></table></figure>
<p>数组的<strong>下标值是从 0 开始的</strong>。如果下标值超出数组长度范畴，或者是负数，那么 Go 编译器会给出错误提示，防止访问溢出：</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">6</span>]<span class="type">int</span>{<span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span>}</span><br><span class="line">fmt.Println(arr[<span class="number">0</span>], arr[<span class="number">5</span>]) <span class="comment">// 11 16</span></span><br><span class="line">fmt.Println(arr[<span class="number">-1</span>])        <span class="comment">// 错误：下标值不能为负数</span></span><br><span class="line">fmt.Println(arr[<span class="number">8</span>])         <span class="comment">// 错误：小标值超出了arr的长度范围</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="多维数组"><a class="markdownIt-Anchor" href="#多维数组"></a> 多维数组</h3>
<p><code>var mArr [2][3][4]int</code></p>
<p>在Go中，数组类型变量是一个整体，这就意味着一个数组变量表示的是整个数组。这点与 C 语言完全不同，在 C 语言中，数组变量可视为指向数组第一个元素的指针。这样一来，无论是参与迭代，还是作为实际参数传给一个函数 / 方法，Go 传递数组的方式都是纯粹的值拷贝，这会带来较大的内存拷贝开销。</p>
<p>这时，你可能会想到我们可以使用指针的方式，来向函数传递数组。没错，这样做的确可以避免性能损耗，但这更像是 C 语言的惯用法。**其实，Go 语言为我们提供了一种更为灵活、更为地道的方式 ，切片，来解决这个问题。**它的优秀特性让它成为了 Go 语言中最常用的同构复合类型。</p>
<h3 id="切片"><a class="markdownIt-Anchor" href="#切片"></a> 切片</h3>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> nums = []<span class="type">int</span>{<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>}</span><br><span class="line">fmt.Println(<span class="built_in">len</span>(nums)) <span class="comment">// 6</span></span><br><span class="line">nums = <span class="built_in">append</span>(nums, <span class="number">7</span>) <span class="comment">// 切片变为[1 2 3 4 5 6 7], append内置函数</span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(nums)) <span class="comment">// 7</span></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> slice <span class="keyword">struct</span> {</span><br><span class="line">    array unsafe.Pointer</span><br><span class="line">    <span class="built_in">len</span>   <span class="type">int</span></span><br><span class="line">    <span class="built_in">cap</span>   <span class="type">int</span> <span class="comment">// cap-&gt;capacity, cap &gt;= len.</span></span><br><span class="line">} <span class="comment">// 类似于vector。</span></span><br></pre></td></tr></tbody></table></figure>
<p><img src="/img/go%E5%AD%A6%E4%B9%A0/image-20250513105805333.png" alt="image-20250513105805333"></p>
<p>创建切片。</p>
<p><strong>方法一：通过 make 函数来创建切片，并指定底层数组的长度。</strong></p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sl := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">6</span>, <span class="number">10</span>) <span class="comment">// 其中10为cap值，即底层数组长度，6为切片的初始长度</span></span><br><span class="line"><span class="comment">// 如果没有在 make 中指定 cap 参数，那么底层数组长度 cap 就等于 len</span></span><br><span class="line">sl := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">6</span>) <span class="comment">// cap = len = 6</span></span><br></pre></td></tr></tbody></table></figure>
<p><strong>方法二：采用 array[low : high : max] （max可省）语法基于一个已存在的数组创建切片。这种方式被称为数组的切片化</strong></p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr := [<span class="number">10</span>]<span class="type">int</span>{<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>}</span><br><span class="line">sl := arr[<span class="number">3</span>:<span class="number">7</span>:<span class="number">9</span>]</span><br></pre></td></tr></tbody></table></figure>
<p><img src="/img/go%E5%AD%A6%E4%B9%A0/image-20250513105744384.png" alt="image-20250513105744384"></p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sl[<span class="number">0</span>] += <span class="number">10</span></span><br><span class="line">fmt.Println(<span class="string">"arr[3] ="</span>, arr[<span class="number">3</span>]) <span class="comment">// 14</span></span><br></pre></td></tr></tbody></table></figure>
<p><strong>切片好比打开了一个访问与修改数组的“窗口”</strong>，通过这个窗口，我们可以直接操作底层数组中的部分元素。这有些类似于我们操作文件之前打开的“文件描述符”（Windows 上称为句柄），通过文件描述符我们可以对底层的真实文件进行相关操作。<strong>可以说，切片之于数组就像是文件描述符之于文件。</strong></p>
<p>切片与数组最大的不同，就在于其长度的不定长，这种不定长需要 Go 运行时提供支持，这种支持就是切片的“动态扩容”。</p>
<h4 id="切片的动态扩容"><a class="markdownIt-Anchor" href="#切片的动态扩容"></a> 切片的动态扩容</h4>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s []<span class="type">int</span></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">11</span>) </span><br><span class="line">fmt.Println(<span class="built_in">len</span>(s), <span class="built_in">cap</span>(s)) <span class="comment">//1 1</span></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">12</span>) </span><br><span class="line">fmt.Println(<span class="built_in">len</span>(s), <span class="built_in">cap</span>(s)) <span class="comment">//2 2</span></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">13</span>) </span><br><span class="line">fmt.Println(<span class="built_in">len</span>(s), <span class="built_in">cap</span>(s)) <span class="comment">//3 4</span></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">14</span>) </span><br><span class="line">fmt.Println(<span class="built_in">len</span>(s), <span class="built_in">cap</span>(s)) <span class="comment">//4 4</span></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">15</span>) </span><br><span class="line">fmt.Println(<span class="built_in">len</span>(s), <span class="built_in">cap</span>(s)) <span class="comment">//5 8</span></span><br></pre></td></tr></tbody></table></figure>
<p>不过 append 操作的这种自动扩容行为，有些时候会给我们开发者带来一些困惑，比如基于<strong>一个已有数组建立的切片，一旦追加的数据操作触碰到切片的容量上限（实质上也是数组容量的上界)，切片就会和原数组解除“绑定”，后续对切片的任何修改都不会反映到原数组中了。</strong></p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">u := [...]<span class="type">int</span>{<span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>}</span><br><span class="line">fmt.Println(<span class="string">"array:"</span>, u) <span class="comment">// [11, 12, 13, 14, 15]</span></span><br><span class="line">s := u[<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line">fmt.Printf(<span class="string">"slice(len=%d, cap=%d): %v\n"</span>, <span class="built_in">len</span>(s), <span class="built_in">cap</span>(s), s) <span class="comment">// [12, 13]</span></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">24</span>)</span><br><span class="line">fmt.Println(<span class="string">"after append 24, array:"</span>, u)</span><br><span class="line">fmt.Printf(<span class="string">"after append 24, slice(len=%d, cap=%d): %v\n"</span>, <span class="built_in">len</span>(s), <span class="built_in">cap</span>(s), s)</span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">25</span>)</span><br><span class="line">fmt.Println(<span class="string">"after append 25, array:"</span>, u)</span><br><span class="line">fmt.Printf(<span class="string">"after append 25, slice(len=%d, cap=%d): %v\n"</span>, <span class="built_in">len</span>(s), <span class="built_in">cap</span>(s), s)</span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">26</span>)</span><br><span class="line">fmt.Println(<span class="string">"after append 26, array:"</span>, u)</span><br><span class="line">fmt.Printf(<span class="string">"after append 26, slice(len=%d, cap=%d): %v\n"</span>, <span class="built_in">len</span>(s), <span class="built_in">cap</span>(s), s)</span><br><span class="line">s[<span class="number">0</span>] = <span class="number">22</span></span><br><span class="line">fmt.Println(<span class="string">"after reassign 1st elem of slice, array:"</span>, u)</span><br><span class="line">fmt.Printf(<span class="string">"after reassign 1st elem of slice, slice(len=%d, cap=%d): %v\n"</span>, <span class="built_in">len</span>(s), <span class="built_in">cap</span>(s), s)</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">结果</span></span><br><span class="line">array: [11 12 13 14 15]</span><br><span class="line">slice(len=2, cap=4): [12 13]</span><br><span class="line">after append 24, array: [11 12 13 24 15]</span><br><span class="line">after append 24, slice(len=3, cap=4): [12 13 24]</span><br><span class="line">after append 25, array: [11 12 13 24 25]</span><br><span class="line">after append 25, slice(len=4, cap=4): [12 13 24 25]</span><br><span class="line">after append 26, array: [11 12 13 24 25]</span><br><span class="line">after append 26, slice(len=5, cap=8): [12 13 24 25 26]</span><br><span class="line">after reassign 1st elem of slice, array: [11 12 13 24 25]</span><br><span class="line">after reassign 1st elem of slice, slice(len=5, cap=8): [22 13 24 25 26]</span><br></pre></td></tr></tbody></table></figure>
<p>显然，对于cap &gt; len的切片，如果append，那么不会对原数组拷贝扩容，只会对数组的下一位进行修改而已。</p>
<p>原数组 u 的元素也不会发生改变了，因为这个时候切片 s 与数组 u 已经解除了“绑定关系”，s 已经不再是数组 u 的“描述符”了。这种因切片的自动扩容而导致的“绑定关系”解除，有时候会成为你实践道路上的一个小陷阱，你一定要注意这一点。</p>
<p>思考题：<code>var sl1 []int</code> 和 <code>var sl2 []int{}</code>区别。</p>
<p>相当于 <code>var sl2 []int{}</code>是已经初始化的，是空，但是非nil，但是前者是nil。</p>
<h3 id="map类型"><a class="markdownIt-Anchor" href="#map类型"></a> map类型</h3>
<p>map 是 Go 语言提供的一种抽象数据类型，它表示一组无序的键值对。在后面的讲解中，我们会直接使用 key 和 value 分别代表 map 的键和值。而且，map 集合中每个 key 都是唯一的：</p>
<p><img src="/img/go%E5%AD%A6%E4%B9%A0/image-20250513113332824.png" alt="image-20250513113332824"></p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">map</span>[key_type]value_type</span><br><span class="line"></span><br><span class="line"><span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span> <span class="comment">// key与value元素的类型相同</span></span><br><span class="line"><span class="keyword">map</span>[<span class="type">int</span>]<span class="type">string</span>    <span class="comment">// key与value元素的类型不同</span></span><br></pre></td></tr></tbody></table></figure>
<p>Go 语言中要求，<strong>key 的类型必须支持“==”和“!=”两种比较操作符</strong>。对value没有限制</p>
<p>在 Go 语言中，函数类型、map 类型自身，以及切片只支持与 nil 的比较，而不支持同类型两个变量的比较。如果像下面代码这样，进行这些类型的比较，Go 编译器将会报错：</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">s1 := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">1</span>)</span><br><span class="line">s2 := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">2</span>)</span><br><span class="line">f1 := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {}</span><br><span class="line">f2 := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {}</span><br><span class="line">m1 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">string</span>)</span><br><span class="line">m2 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">string</span>)</span><br><span class="line"><span class="built_in">println</span>(s1 == s2) <span class="comment">// 错误：invalid operation: s1 == s2 (slice can only be compared to nil)</span></span><br><span class="line"><span class="built_in">println</span>(f1 == f2) <span class="comment">// 错误：invalid operation: f1 == f2 (func can only be compared to nil)</span></span><br><span class="line"><span class="built_in">println</span>(m1 == m2) <span class="comment">// 错误：invalid operation: m1 == m2 (map can only be compared to nil)</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p><strong>函数类型、map 类型自身，以及切片类型是不能作为 map 的 key 类型的</strong>。</p>
<h4 id="声明与初始化"><a class="markdownIt-Anchor" href="#声明与初始化"></a> 声明与初始化。</h4>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var m map[string]int // 一个map[string]int类型的变量</span><br></pre></td></tr></tbody></table></figure>
<p>和切片类型变量一样，如果我们没有显式地赋予 map 变量初值，map 类型变量的默认值为 nil。</p>
<p>不过切片变量和 map 变量在这里也有些不同。初值为零值 nil 的切片类型变量，可以借助内置的 append 的函数进行操作，这种在 Go 语言中被称为“<strong>零值可用</strong>”。定义“零值可用”的类型，可以提升我们开发者的使用体验，我们不用再担心变量的初始状态是否有效。</p>
<p><strong>但 map 类型，因为它内部实现的复杂性，无法“零值可用”</strong>。所以，如果我们对处于零值状态的 map 变量直接进行操作，就会导致运行时异常（panic），从而导致程序进程异常退出：</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span> <span class="comment">// m = nil</span></span><br><span class="line">m[<span class="string">"key"</span>] = <span class="number">1</span>         <span class="comment">// 发生运行时异常：panic: assignment to entry in nil map</span></span><br></pre></td></tr></tbody></table></figure>
<p>初始化方法：</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法一：使用复合字面值初始化 map 类型变量。</span></span><br><span class="line">m := <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">string</span>{}</span><br><span class="line"></span><br><span class="line">m1 := <span class="keyword">map</span>[<span class="type">int</span>][]<span class="type">string</span>{</span><br><span class="line">    <span class="number">1</span>: []<span class="type">string</span>{<span class="string">"val1_1"</span>, <span class="string">"val1_2"</span>},</span><br><span class="line">    <span class="number">3</span>: []<span class="type">string</span>{<span class="string">"val3_1"</span>, <span class="string">"val3_2"</span>, <span class="string">"val3_3"</span>},</span><br><span class="line">    <span class="number">7</span>: []<span class="type">string</span>{<span class="string">"val7_1"</span>},</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Position <span class="keyword">struct</span> { </span><br><span class="line">    x <span class="type">float64</span> </span><br><span class="line">    y <span class="type">float64</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">m2 := <span class="keyword">map</span>[Position]<span class="type">string</span>{</span><br><span class="line">    Position{<span class="number">29.935523</span>, <span class="number">52.568915</span>}: <span class="string">"school"</span>,</span><br><span class="line">    Position{<span class="number">25.352594</span>, <span class="number">113.304361</span>}: <span class="string">"shopping-mall"</span>,</span><br><span class="line">    Position{<span class="number">73.224455</span>, <span class="number">111.804306</span>}: <span class="string">"hospital"</span>,</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//这种情况下，Go 允许省略字面值中的元素类型。</span></span><br><span class="line">m2 := <span class="keyword">map</span>[Position]<span class="type">string</span>{</span><br><span class="line">    {<span class="number">29.935523</span>, <span class="number">52.568915</span>}: <span class="string">"school"</span>,</span><br><span class="line">    {<span class="number">25.352594</span>, <span class="number">113.304361</span>}: <span class="string">"shopping-mall"</span>,</span><br><span class="line">    {<span class="number">73.224455</span>, <span class="number">111.804306</span>}: <span class="string">"hospital"</span>,</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法二：使用 make 为 map 类型变量进行显式初始化。</span></span><br><span class="line">m1 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">string</span>) <span class="comment">// 未指定初始容量</span></span><br><span class="line">m2 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">string</span>, <span class="number">8</span>) <span class="comment">// 指定初始容量为8</span></span><br><span class="line"><span class="comment">//map 类型会自动扩容。</span></span><br></pre></td></tr></tbody></table></figure>
<p><strong>插入键值对：</strong></p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">string</span>)</span><br><span class="line">m[<span class="number">1</span>] = <span class="string">"value1"</span></span><br><span class="line">m[<span class="number">2</span>] = <span class="string">"value2"</span></span><br><span class="line">m[<span class="number">3</span>] = <span class="string">"value3"</span></span><br></pre></td></tr></tbody></table></figure>
<p>除非内存耗尽，不然不用担心插值结果。</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">m := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span> {</span><br><span class="line">  <span class="string">"key1"</span> : <span class="number">1</span>,</span><br><span class="line">  <span class="string">"key2"</span> : <span class="number">2</span>,</span><br><span class="line">}</span><br><span class="line">m[<span class="string">"key1"</span>] = <span class="number">11</span> <span class="comment">// 11会覆盖掉"key1"对应的旧值1</span></span><br><span class="line">m[<span class="string">"key3"</span>] = <span class="number">3</span>  <span class="comment">// 此时m为map[key1:11 key2:2 key3:3]</span></span><br></pre></td></tr></tbody></table></figure>
<p>会覆盖原值，与C++行为一致。</p>
<p><strong>获取键值对数量</strong> 使用内置函数len，不能使用cap函数，这与数组和切片不同。</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">m := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span> {</span><br><span class="line">  <span class="string">"key1"</span> : <span class="number">1</span>,</span><br><span class="line">  <span class="string">"key2"</span> : <span class="number">2</span>,</span><br><span class="line">}</span><br><span class="line">fmt.Println(<span class="built_in">len</span>(m)) <span class="comment">// 2</span></span><br><span class="line">m[<span class="string">"key3"</span>] = <span class="number">3</span>  </span><br><span class="line">fmt.Println(<span class="built_in">len</span>(m)) <span class="comment">// 3</span></span><br></pre></td></tr></tbody></table></figure>
<p><strong>查找和数据读取</strong>：判断key是否存在map中。</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line">v := m[<span class="string">"key1"</span>] <span class="comment">// 错误，这样无法判断。但是会返回一个value类型的零值，如果不存在的话。</span></span><br><span class="line"></span><br><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line">v, ok := m[<span class="string">"key1"</span>] <span class="comment">// 对的对的。</span></span><br><span class="line"><span class="keyword">if</span> !ok {</span><br><span class="line">    <span class="comment">// "key1"不在map中</span></span><br><span class="line">}</span><br><span class="line"><span class="comment">// "key1"在map中，v将被赋予"key1"键对应的value</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果不关心value，只关心是否存在：</span></span><br><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line">_, ok := m[<span class="string">"key1"</span>]</span><br><span class="line">... ...</span><br></pre></td></tr></tbody></table></figure>
<p><strong>在 Go 语言中，请使用“comma ok”惯用法对 map 进行键查找和键值读取操作。</strong></p>
<p><strong>删除</strong></p>
<p>使用内置函数delete。</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">m := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span> {</span><br><span class="line">  <span class="string">"key1"</span> : <span class="number">1</span>,</span><br><span class="line">  <span class="string">"key2"</span> : <span class="number">2</span>,</span><br><span class="line">}</span><br><span class="line">fmt.Println(m) <span class="comment">// map[key1:1 key2:2]</span></span><br><span class="line"><span class="built_in">delete</span>(m, <span class="string">"key2"</span>) <span class="comment">// 删除"key2"</span></span><br><span class="line">fmt.Println(m) <span class="comment">// map[key1:1]</span></span><br></pre></td></tr></tbody></table></figure>
<p><strong>delete 函数是从 map 中删除键的唯一方法</strong>。即便传给 delete 的键在 map 中并不存在，delete 函数的执行也不会失败，更不会抛出运行时的异常。</p>
<p><strong>遍历map</strong></p>
<p>在 Go 中，遍历 map 的键值对只有一种方法，那就是<strong>像对待切片那样通过 for range 语句对 map 数据进行遍历</strong>。</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">m := <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>{</span><br><span class="line">       <span class="number">1</span>: <span class="number">11</span>,</span><br><span class="line">       <span class="number">2</span>: <span class="number">12</span>,</span><br><span class="line">       <span class="number">3</span>: <span class="number">13</span>,</span><br><span class="line">   }</span><br><span class="line">   fmt.Printf(<span class="string">"{ "</span>)</span><br><span class="line">   <span class="keyword">for</span> k, v := <span class="keyword">range</span> m {</span><br><span class="line">       fmt.Printf(<span class="string">"[%d, %d] "</span>, k, v)</span><br><span class="line">   }</span><br><span class="line">   fmt.Printf(<span class="string">"}\n"</span>)</span><br></pre></td></tr></tbody></table></figure>
<p><strong>对同一 map 做多次遍历的时候，每次遍历元素的次序都不相同</strong>。这是 Go 语言 map 类型的一个重要特点，也是很容易让 Go 初学者掉入坑中的一个地方。所以这里你一定要记住：<strong>程序逻辑千万不要依赖遍历 map 所得到的的元素次序</strong>。</p>
<p><strong>map 传递开销</strong></p>
<p>map 只是传递<strong>描述符</strong>，是引用。</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">(m <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span></span> {</span><br><span class="line">    m[<span class="string">"key1"</span>] = <span class="number">11</span></span><br><span class="line">    m[<span class="string">"key2"</span>] = <span class="number">12</span></span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    m := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>{</span><br><span class="line">        <span class="string">"key1"</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="string">"key2"</span>: <span class="number">2</span>,</span><br><span class="line">    }</span><br><span class="line">    fmt.Println(m) <span class="comment">// map[key1:1 key2:2]  </span></span><br><span class="line">    foo(m)</span><br><span class="line">    fmt.Println(m) <span class="comment">// map[key1:11 key2:12] </span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong>map 内部实现</strong></p>
<p>map 内部使用哈希表。</p>
<p>Go 编译器会将 Go 语法层面的 map 操作，重写成运行时对应的函数调用。大致的对应关系是这样的：</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建map类型变量实例</span></span><br><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[keyType]valType, capacityhint) → m := runtime.makemap(maptype, capacityhint, m)</span><br><span class="line"><span class="comment">// 插入新键值对或给键重新赋值</span></span><br><span class="line">m[<span class="string">"key"</span>] = <span class="string">"value"</span> → v := runtime.mapassign(maptype, m, <span class="string">"key"</span>) v是用于后续存储value的空间的地址</span><br><span class="line"><span class="comment">// 获取某键的值 </span></span><br><span class="line">v := m[<span class="string">"key"</span>]      → v := runtime.mapaccess1(maptype, m, <span class="string">"key"</span>)</span><br><span class="line">v, ok := m[<span class="string">"key"</span>]  → v, ok := runtime.mapaccess2(maptype, m, <span class="string">"key"</span>)</span><br><span class="line"><span class="comment">// 删除某键</span></span><br><span class="line"><span class="built_in">delete</span>(m, <span class="string">"key"</span>)   → runtime.mapdelete(maptype, m, “key”)</span><br></pre></td></tr></tbody></table></figure>
<p><img src="/img/go%E5%AD%A6%E4%B9%A0/image-20250514204343647.png" alt="image-20250514204343647"></p>
<p><strong>初始状态</strong></p>
<p>hmap 类型是 map 类型的头部结构（header），也就是我们前面在讲解 map 类型变量传递开销时提到的 <strong>map 类型的描述符</strong>，它存储了后续 map 类型操作所需的所有信息，包括：</p>
<p><img src="/img/go%E5%AD%A6%E4%B9%A0/image-20250514204443028.png" alt="image-20250514204443028"></p>
<p>真正用来存储键值对数据的是桶，也就是 bucket，每个 bucket 中存储的是 Hash 值低 bit 位数值相同的元素，默认的元素个数为 BUCKETSIZE。</p>
<p>可见是可拓展哈希。</p>
<p><strong>tophash 区域</strong></p>
<p><img src="/img/go%E5%AD%A6%E4%B9%A0/image-20250514204729499.png" alt="image-20250514204729499"></p>
<p>当我们向 map 插入一条数据，或者是从 map 按 key 查询数据的时候，运行时都会使用哈希函数对 key 做哈希运算，并获得一个哈希值（hashcode）。这个 hashcode 非常关键，运行时会把 hashcode“一分为二”来看待，其中低位区的值用于选定 bucket，高位区的值用于在某个 bucket 中确定 key 的位置。</p>
<p><strong>key 存储区域</strong></p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> maptype <span class="keyword">struct</span> {</span><br><span class="line">    typ        _type</span><br><span class="line">    key        *_type</span><br><span class="line">    elem       *_type</span><br><span class="line">    bucket     *_type <span class="comment">// internal type representing a hash bucket</span></span><br><span class="line">    keysize    <span class="type">uint8</span>  <span class="comment">// size of key slot</span></span><br><span class="line">    elemsize   <span class="type">uint8</span>  <span class="comment">// size of elem slot</span></span><br><span class="line">    bucketsize <span class="type">uint16</span> <span class="comment">// size of bucket</span></span><br><span class="line">    flags      <span class="type">uint32</span></span><br><span class="line">} </span><br></pre></td></tr></tbody></table></figure>
<p>编译器会把语法层面的 map 操作重写成运行时对应的函数调用，这些运行时函数都有一个共同的特点，那就是第一个参数都是 maptype 指针类型的参数。</p>
<p><strong>Go 运行时就是利用 maptype 参数中的信息确定 key 的类型和大小的。</strong>（像是C语言的 void* 来实现类似于泛型的东西）</p>
<p><strong>value 存储区域</strong></p>
<p>Go 运行时采用了把 key 和 value 分开存储的方式，而不是采用一个 kv 接着一个 kv 的 kv 紧邻方式存储，这带来的其实是算法上的复杂性，但却减少了因内存对齐带来的内存浪费。（kv分离，唔）</p>
<p><img src="/img/go%E5%AD%A6%E4%B9%A0/image-20250514205418005.png" alt="image-20250514205418005"></p>
<p>如果 key 或 value 的数据长度大于一定数值，那么运行时不会在 bucket 中直接存储数据，而是会存储 key 或 value 数据的指针。目前 Go 运行时定义的最大 key 和 value 的长度是这样的：</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// $GOROOT/src/runtime/map.go</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    maxKeySize  = <span class="number">128</span></span><br><span class="line">    maxElemSize = <span class="number">128</span></span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure>
<p><strong>map 扩容</strong></p>
<p>那么 map 在什么情况下会进行扩容呢？Go 运行时的 map 实现中引入了一个 LoadFactor（负载因子），当 <strong>count &gt; LoadFactor * 2^B</strong> 或 overflow bucket 过多时，运行时会自动对 map 进行扩容。目前 Go 1.17 版本 LoadFactor 设置为 6.5</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// $GOROOT/src/runtime/map.go</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">  ... ...</span><br><span class="line">  loadFactorNum = <span class="number">13</span></span><br><span class="line">  loadFactorDen = <span class="number">2</span></span><br><span class="line">  ... ...</span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapassign</span><span class="params">(t *maptype, h *hmap, key unsafe.Pointer)</span></span> unsafe.Pointer {</span><br><span class="line">  ... ...</span><br><span class="line">  <span class="keyword">if</span> !h.growing() &amp;&amp; (overLoadFactor(h.count+<span class="number">1</span>, h.B) || tooManyOverflowBuckets(h.noverflow, h.B)) {</span><br><span class="line">    hashGrow(t, h)</span><br><span class="line">    <span class="keyword">goto</span> again <span class="comment">// Growing the table invalidates everything, so try again</span></span><br><span class="line">  }</span><br><span class="line">  ... ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>如果是因为当前数据数量超出 LoadFactor 指定水位而进行的扩容，那么运行时会建立一个<strong>两倍于现有规模的 bucket 数组</strong>，但真正的排空和迁移工作也是在 assign 和 delete 时逐步进行的。原 bucket 数组会挂在 hmap 的 oldbuckets 指针下面，直到原 buckets 数组中所有数据都迁移到新数组后，原 buckets 数组才会被释放。</p>
<p><img src="/img/go%E5%AD%A6%E4%B9%A0/image-20250514210046014-1747227647497-1.png" alt="image-20250514210046014"></p>
<p>逐步迁移，减少性能波动。让oldbuckets，逐渐不存储数据，而是存储指针，直到最后释放。</p>
<p><strong>map 与并发</strong></p>
<p>从上面的实现原理来看，充当 map 描述符角色的 hmap 实例自身是有状态的（hmap.flags），而且对状态的读写是没有并发保护的。所以说 map 实例不是并发写安全的，也不支持并发读写。如果我们对 map 实例进行并发读写，程序运行时就会抛出异常。</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doIteration</span><span class="params">(m <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>)</span></span> {</span><br><span class="line">    <span class="keyword">for</span> k, v := <span class="keyword">range</span> m {</span><br><span class="line">        _ = fmt.Sprintf(<span class="string">"[%d, %d] "</span>, k, v)</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doWrite</span><span class="params">(m <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>)</span></span> {</span><br><span class="line">    <span class="keyword">for</span> k, v := <span class="keyword">range</span> m {</span><br><span class="line">        m[k] = v + <span class="number">1</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    m := <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>{</span><br><span class="line">        <span class="number">1</span>: <span class="number">11</span>,</span><br><span class="line">        <span class="number">2</span>: <span class="number">12</span>,</span><br><span class="line">        <span class="number">3</span>: <span class="number">13</span>,</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ {</span><br><span class="line">            doIteration(m)</span><br><span class="line">        }</span><br><span class="line">    }()</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ {</span><br><span class="line">            doWrite(m)</span><br><span class="line">        }</span><br><span class="line">    }()</span><br><span class="line">    time.Sleep(<span class="number">5</span> * time.Second)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行：</span></span><br><span class="line">fatal <span class="type">error</span>: concurrent <span class="keyword">map</span> iteration and <span class="keyword">map</span> write</span><br></pre></td></tr></tbody></table></figure>
<p>不过，如果我们仅仅是进行并发读，map 是没有问题的。而且，Go 1.9 版本中引入了支持并发写安全的 sync.Map 类型，可以用来在并发读写的场景下替换掉 map。</p>
<p>考虑到 map 可以自动扩容，map 中数据元素的 value 位置可能在这一过程中发生变化，所以 <strong>Go 不允许获取 map 中 value 的地址，这个约束是在编译期间就生效的</strong>。</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p := &amp;m[key]  <span class="comment">// cannot take the address of m[key]</span></span><br><span class="line">fmt.Println(p)</span><br></pre></td></tr></tbody></table></figure>
<h2 id="复合数据类型结构体"><a class="markdownIt-Anchor" href="#复合数据类型结构体"></a> 复合数据类型：结构体</h2>
<p>在 Go 中，我们自定义一个新类型一般有两种方法。<strong>第一种是类型定义（Type Definition），这也是我们最常用的类型定义方法。在这种方法中，我们会使用关键字</strong>type 来定义一个新类型 T</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> T S <span class="comment">// 定义一个新类型T</span></span><br><span class="line"><span class="keyword">type</span> T1 <span class="type">int</span> </span><br><span class="line"><span class="keyword">type</span> T2 T1  </span><br></pre></td></tr></tbody></table></figure>
<p><strong>底层类型</strong>。如果一个新类型是基于某个 Go 原生类型定义的，那么我们就叫 Go 原生类型为新类型的<strong>底层类型（Underlying Type)</strong>。</p>
<p>如果不是基于 Go 原生类型定义的新类型，比如 T2，它的底层类型是什么呢？这时我们就要看它定义时是基于什么类型了。这里，T2 是基于 T1 类型创建的，那么 T2 类型的底层类型就是 T1 的底层类型，而 T1 的底层类型我们已经知道了，是类型 int，那么 T2 的底层类型也是类型 int。</p>
<p>底层类型在 Go 语言中有重要作用，<strong>它被用来判断两个类型本质上是否相同（Identical）。</strong></p>
<p>在上面例子中，虽然 T1 和 T2 是不同类型，但因为它们的底层类型都是类型 int，所以它们在本质上是相同的。<strong>而本质上相同的两个类型，它们的变量可以通过显式转型进行相互赋值，相反，如果本质上是不同的两个类型，它们的变量间连显式转型都不可能，更不要说相互赋值了。</strong></p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> T1 <span class="type">int</span></span><br><span class="line"><span class="keyword">type</span> T2 T1</span><br><span class="line"><span class="keyword">type</span> T3 <span class="type">string</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">var</span> n1 T1</span><br><span class="line">    <span class="keyword">var</span> n2 T2 = <span class="number">5</span></span><br><span class="line">    n1 = T1(n2)  <span class="comment">// ok</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> s T3 = <span class="string">"hello"</span></span><br><span class="line">    n1 = T1(s) <span class="comment">// 错误：cannot convert s (type T3) to type T1</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>我们还可以基于<strong>类型字面值</strong>来定义新类型，这种方式多用于自定义一个新的复合类型，比如：</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> M <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">string</span></span><br><span class="line"><span class="keyword">type</span> S []<span class="type">string</span></span><br></pre></td></tr></tbody></table></figure>
<p>类型定义也支持通过 type 块的方式进行，比如我们可以把上面代码中的 T1、T2 和 T3 的定义放在同一个 type 块中：</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> (</span><br><span class="line">   T1 <span class="type">int</span></span><br><span class="line">   T2 T1</span><br><span class="line">   T3 <span class="type">string</span></span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure>
<p><strong>第二种自定义新类型的方式是使用类型别名（Type Alias）</strong>，本质两种类型是一摸一样的，这种类型定义方式通常用在项目的渐进式重构，还有对已有包的二次封装方面，它的形式是这样的：</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> T = S <span class="comment">// type alias</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> T = <span class="type">string</span> </span><br><span class="line">  </span><br><span class="line"><span class="keyword">var</span> s <span class="type">string</span> = <span class="string">"hello"</span> </span><br><span class="line"><span class="keyword">var</span> t T = s <span class="comment">// ok</span></span><br><span class="line">fmt.Printf(<span class="string">"%T\n"</span>, t) <span class="comment">// string</span></span><br></pre></td></tr></tbody></table></figure>
<p>结构体：</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> {</span><br><span class="line">    Field1 T1</span><br><span class="line">    Field2 T2</span><br><span class="line">    ... ...</span><br><span class="line">    FieldN Tn</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>定义中 struct 关键字后面的大括号包裹的内容就是一个<strong>类型字面值</strong>。</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> book</span><br><span class="line"><span class="keyword">type</span> Book <span class="keyword">struct</span> {</span><br><span class="line">     Title <span class="type">string</span>              <span class="comment">// 书名</span></span><br><span class="line">     Pages <span class="type">int</span>                 <span class="comment">// 书的页数</span></span><br><span class="line">     Indexes <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>    <span class="comment">// 书的索引</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>Go 用标识符名称的首字母大小写来判定这个标识符是否为导出标识符。所以，这里的类型 Book 以及它的各个字段都是导出标识符。这样，只要其他包导入了包 book，我们就可以在这些包中直接引用类型名 Book，也可以通过 Book 类型变量引用 Name、Pages 等字段。</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">".../book"</span></span><br><span class="line"><span class="keyword">var</span> b book.Book</span><br><span class="line">b.Title = <span class="string">"The Go Programming Language"</span></span><br><span class="line">b.Pages = <span class="number">800</span></span><br></pre></td></tr></tbody></table></figure>
<p><strong>定义一个空结构体。</strong></p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Empty <span class="keyword">struct</span>{} <span class="comment">// Empty是一个不包含任何字段的空结构体类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s Empty</span><br><span class="line"><span class="built_in">println</span>(unsafe.Sizeof(s)) <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c = <span class="built_in">make</span>(<span class="keyword">chan</span> Empty) <span class="comment">// 声明一个元素类型为Empty的channel</span></span><br><span class="line">c&lt;-Empty{}               <span class="comment">// 向channel写入一个“事件”</span></span><br></pre></td></tr></tbody></table></figure>
<p>可以在管道中，当作一种hint，表示发生与否。</p>
<p>空结构体为元素类建立的 channel，是目前能实现的、内存占用最小的 Goroutine 间通信方式。</p>
<p><strong>使用其他结构体作为自定义结构体中字段的类型。</strong></p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> {</span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">    Phone <span class="type">string</span></span><br><span class="line">    Addr <span class="type">string</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">type</span> Book <span class="keyword">struct</span> {</span><br><span class="line">    Title <span class="type">string</span></span><br><span class="line">    Author Person</span><br><span class="line">    ... ...</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> book Book </span><br><span class="line"><span class="built_in">println</span>(book.Author.Phone)</span><br></pre></td></tr></tbody></table></figure>
<p>对于包含结构体类型字段的结构体类型来说，Go 还提供了一种更为简便的定义方法，<strong>那就是我们可以无需提供字段的名字，只需要使用其类型就可以了</strong>，以上面的 Book 结构体定义为例，我们可以用下面的方式提供一个等价的定义：</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Book <span class="keyword">struct</span> {</span><br><span class="line">    Title <span class="type">string</span></span><br><span class="line">    Person</span><br><span class="line">    ... ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>以这种方式定义的结构体字段，我们叫做<strong>嵌入字段（Embedded Field）</strong>。我们也可以将这种字段称为匿名字段，或者把类型名看作是这个字段的名字。</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> book Book </span><br><span class="line"><span class="built_in">println</span>(book.Person.Phone) <span class="comment">// 将类型名当作嵌入字段的名字</span></span><br><span class="line"><span class="built_in">println</span>(book.Phone)        <span class="comment">// 支持直接访问嵌入字段所属类型中字段</span></span><br></pre></td></tr></tbody></table></figure>
<p>第一种方式显然是通过把类型名当作嵌入字段的名字来进行操作的，而第二种方式更像是一种“语法糖”，我们可以“绕过”Person 类型这一层，直接访问 Person 中的字段。</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> {</span><br><span class="line">    t T  </span><br><span class="line">    ... ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>Go 语言不支持这种在结构体类型定义中，递归地放入其自身类型字段的定义方式。</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> T1 <span class="keyword">struct</span> {</span><br><span class="line">  t2 T2</span><br><span class="line">}</span><br><span class="line"><span class="keyword">type</span> T2 <span class="keyword">struct</span> {</span><br><span class="line">  t1 T1</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> {</span><br><span class="line">    t  *T           <span class="comment">// ok</span></span><br><span class="line">    st []T          <span class="comment">// ok</span></span><br><span class="line">    m  <span class="keyword">map</span>[<span class="type">string</span>]T <span class="comment">// ok</span></span><br><span class="line">}    </span><br></pre></td></tr></tbody></table></figure>
<p>结构体变量的声明与初始化：</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Book <span class="keyword">struct</span> {</span><br><span class="line">    ...</span><br><span class="line">}</span><br><span class="line"><span class="keyword">var</span> book Book</span><br><span class="line"><span class="keyword">var</span> book = Book{}</span><br><span class="line">book := Book{}</span><br></pre></td></tr></tbody></table></figure>
<p><strong>结构体类型的变量通常都要被赋予适当的初始值后，才会有合理的意义。</strong></p>
<p><strong>零值初始化</strong></p>
<p><code>var book Book // book为零值结构体变量</code></p>
<p>那么采用零值初始化的零值结构体变量就真的没有任何价值了吗？恰恰相反。如果一种类型采用零值初始化得到的零值变量，是有意义的，而且是直接可用的，我称这种类型为**“零值可用”类型**。可以说，定义零值可用类型是简化代码、改善开发者使用体验的一种重要的手段。</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mu sync.Mutex</span><br><span class="line">mu.Lock()</span><br><span class="line">mu.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b bytes.Buffer</span><br><span class="line">b.Write([]<span class="type">byte</span>(<span class="string">"Hello, Go"</span>))</span><br><span class="line">fmt.Println(b.String()) <span class="comment">// 输出：Hello, Go</span></span><br></pre></td></tr></tbody></table></figure>
<p>不过有些类型确实不能设计为零值可用类型，就比如我们前面的 Book 类型，它们的零值并非有效值。对于这类类型，我们需要对它的变量进行显式的初始化后，才能正确使用。</p>
<p><strong>使用复合字面量初始化结构体</strong></p>
<p>最简单的对结构体变量进行显式初始化的方式，就是<strong>按顺序依次给每个结构体字段进行赋值</strong>，</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Book <span class="keyword">struct</span> {</span><br><span class="line">    Title <span class="type">string</span>              <span class="comment">// 书名</span></span><br><span class="line">    Pages <span class="type">int</span>                 <span class="comment">// 书的页数</span></span><br><span class="line">    Indexes <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>    <span class="comment">// 书的索引</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">var</span> book = Book{<span class="string">"The Go Programming Language"</span>, <span class="number">700</span>, <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)}</span><br></pre></td></tr></tbody></table></figure>
<p>但是，如果结构体定义变化，字段多，或者存在不可导出字段，这就很不方便了。</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> {</span><br><span class="line">    F1 <span class="type">int</span></span><br><span class="line">    F2 <span class="type">string</span></span><br><span class="line">    f3 <span class="type">int</span></span><br><span class="line">    F4 <span class="type">int</span></span><br><span class="line">    F5 <span class="type">int</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">var</span> t = T{<span class="number">11</span>, <span class="string">"hello"</span>, <span class="number">13</span>} <span class="comment">// 错误：implicit assignment of unexported field 'f3' in T literal</span></span><br><span class="line">或</span><br><span class="line"><span class="keyword">var</span> t = T{<span class="number">11</span>, <span class="string">"hello"</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>} <span class="comment">// 错误：implicit assignment of unexported field 'f3' in T literal</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>Go 推荐我们用**“field:value”形式的复合字面值**，对结构体类型变量进行显式初始化，这种方式可以降低结构体类型使用者和结构体类型设计者之间的耦合，这也是 Go 语言的惯用法。</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> t = T{</span><br><span class="line">    F2: <span class="string">"hello"</span>,</span><br><span class="line">    F1: <span class="number">11</span>,</span><br><span class="line">    F4: <span class="number">14</span>,</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>未显式出现在字面值中的结构体字段（比如上面例子中的 F5）将采用它对应类型的零值。</p>
<p>记：nil</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="literal">nil</span> Type	<span class="comment">// Type must be a pointer, channel, func, interface, map, or slice type</span></span><br></pre></td></tr></tbody></table></figure>
<p>复合字面值作为结构体类型变量初值被广泛使用，即便结构体采用类型零值时，我们也会使用复合字面值的形式：<code>t := T{}</code></p>
<p>而比较少使用 new 这一个 Go 预定义的函数来创建结构体变量实例：<code>tp := new(T)</code></p>
<p>我们不能用从其他包导入的结构体中的未导出字段，来作为复合字面值中的 field。这会导致编译错误，因为未导出字段是不可见的。</p>
<p>那么，如果一个结构体类型中包含未导出字段，并且这个字段的零值还不可用时，我们要如何初始化这个结构体类型的变量呢？又或是一个结构体类型中的某些字段，需要一个复杂的初始化逻辑，我们又该怎么做呢？这时我们就需要使用一个特定的构造函数，来创建并初始化结构体变量了。</p>
<p><strong>使用特定的构造函数</strong></p>
<p>使用特定的构造函数创建并初始化结构体变量的例子，并不罕见。</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// $GOROOT/src/time/sleep.go</span></span><br><span class="line"><span class="keyword">type</span> runtimeTimer <span class="keyword">struct</span> {</span><br><span class="line">    pp       <span class="type">uintptr</span></span><br><span class="line">    when     <span class="type">int64</span></span><br><span class="line">    period   <span class="type">int64</span></span><br><span class="line">    f        <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">interface</span>{}, <span class="type">uintptr</span>)</span></span> </span><br><span class="line">    arg      <span class="keyword">interface</span>{}</span><br><span class="line">    seq      <span class="type">uintptr</span></span><br><span class="line">    nextwhen <span class="type">int64</span></span><br><span class="line">    status   <span class="type">uint32</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">type</span> Timer <span class="keyword">struct</span> {</span><br><span class="line">    C &lt;-<span class="keyword">chan</span> Time</span><br><span class="line">    r runtimeTimer</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// $GOROOT/src/time/sleep.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewTimer</span><span class="params">(d Duration)</span></span> *Timer {</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> Time, <span class="number">1</span>)</span><br><span class="line">    t := &amp;Timer{</span><br><span class="line">        C: c,</span><br><span class="line">        r: runtimeTimer{</span><br><span class="line">            when: when(d),</span><br><span class="line">            f:    sendTime,</span><br><span class="line">            arg:  c,</span><br><span class="line">        },</span><br><span class="line">    }</span><br><span class="line">    startTimer(&amp;t.r)</span><br><span class="line">    <span class="keyword">return</span> t</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>这类通过专用构造函数进行结构体类型变量创建、初始化的例子还有很多，我们可以总结一下，它们的专用构造函数大多都符合这种模式：</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewT</span><span class="params">(field1, field2, ...)</span></span> *T {</span><br><span class="line">    ... ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>这里，NewT 是结构体类型 T 的专用构造函数，它的参数列表中的参数通常与 T 定义中的导出字段相对应，返回值则是一个 T 指针类型的变量。T 的非导出字段在 NewT 内部进行初始化，一些需要复杂初始化逻辑的字段也会在 NewT 内部完成初始化。这样，我们只要调用 NewT 函数就可以得到一个可用的 T 指针类型变量了.</p>
<p><strong>结构体类型的内存布局</strong></p>
<p><img src="/img/go%E5%AD%A6%E4%B9%A0/image-20250514221254656.png" alt="image-20250514221254656"></p>
<p>我们可以借助标准库 unsafe 包提供的函数，获得结构体类型变量占用的内存大小，以及它每个字段在内存中相对于结构体变量起始地址的偏移量：</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> t T</span><br><span class="line">unsafe.Sizeof(t)      <span class="comment">// 结构体类型变量占用的内存大小</span></span><br><span class="line">unsafe.Offsetof(t.Fn) <span class="comment">// 字段Fn在内存中相对于变量t起始地址的偏移量</span></span><br></pre></td></tr></tbody></table></figure>
<p><img src="/img/go%E5%AD%A6%E4%B9%A0/image-20250514221339662.png" alt="image-20250514221339662"></p>
<p>为什么会出现内存对齐的要求呢？这是出于对处理器存取数据效率的考虑。在早期的一些处理器中，比如 Sun 公司的 Sparc 处理器仅支持内存对齐的地址，如果它遇到没有对齐的内存地址，会引发段错误，导致程序崩溃。我们常见的 x86-64 架构处理器虽然处理未对齐的内存地址不会出现段错误，但数据的存取性能也会受到影响。</p>
<p>比如下面两个结构体类型表示的抽象是相同的，但正是因为字段排列顺序不同，导致它们的大小也不同：</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> {</span><br><span class="line">    b <span class="type">byte</span></span><br><span class="line">    i <span class="type">int64</span></span><br><span class="line">    u <span class="type">uint16</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">type</span> S <span class="keyword">struct</span> {</span><br><span class="line">    b <span class="type">byte</span></span><br><span class="line">    u <span class="type">uint16</span></span><br><span class="line">    i <span class="type">int64</span></span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">var</span> t T</span><br><span class="line">    <span class="built_in">println</span>(unsafe.Sizeof(t)) <span class="comment">// 24</span></span><br><span class="line">    <span class="keyword">var</span> s S</span><br><span class="line">    <span class="built_in">println</span>(unsafe.Sizeof(s)) <span class="comment">// 16</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>有些时候，为了保证某个字段的内存地址有更为严格的约束，我们也会做主动填充。比如 runtime 包中的 mstats 结构体定义就采用了主动填充：</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// $GOROOT/src/runtime/mstats.go</span></span><br><span class="line"><span class="keyword">type</span> mstats <span class="keyword">struct</span> {</span><br><span class="line">    ... ...</span><br><span class="line">    <span class="comment">// Add an uint32 for even number of size classes to align below fields</span></span><br><span class="line">    <span class="comment">// to 64 bits for atomic operations on 32 bit platforms.</span></span><br><span class="line">    _ [<span class="number">1</span> - _NumSizeClasses%<span class="number">2</span>]<span class="type">uint32</span> <span class="comment">// 这里做了主动填充</span></span><br><span class="line">    last_gc_nanotime <span class="type">uint64</span> <span class="comment">// last gc (monotonic time)</span></span><br><span class="line">    last_heap_inuse  <span class="type">uint64</span> <span class="comment">// heap_inuse at mark termination of the previous GC</span></span><br><span class="line">    ... ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="控制结构"><a class="markdownIt-Anchor" href="#控制结构"></a> 控制结构</h2>
<ul>
<li>
<p>Go 坚持“一件事情仅有一种做法的理念”，只保留了 for 这一种循环结构，去掉了 C 语言中的 while 和 do-while 循环结构；</p>
</li>
<li>
<p>Go 填平了 C 语言中 switch 分支结构中每个 case 语句都要以 break 收尾的“坑”；</p>
</li>
<li>
<p>Go 支持了 type switch 特性，让“类型”信息也可以作为分支选择的条件；</p>
</li>
<li>
<p>Go 的 switch 控制结构的 case 语句还支持表达式列表，让相同处理逻辑的多个分支可以合并为一个分支，等等。</p>
</li>
</ul>
<h3 id="if-分支"><a class="markdownIt-Anchor" href="#if-分支"></a> if 分支</h3>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> boolean_expression {</span><br><span class="line">    <span class="comment">// 新分支</span></span><br><span class="line">}</span><br><span class="line"><span class="comment">// 原分支</span></span><br></pre></td></tr></tbody></table></figure>
<p>第一，和 Go 函数一样，if 语句的分支代码块的左大括号与 if 关键字在同一行上，这也是 Go 代码风格的统一要求，gofmt 工具会帮助我们实现这一点；</p>
<p>第二，if 语句的布尔表达式整体不需要用括号包裹，一定程度上减少了开发人员敲击键盘的次数。而且，if 关键字后面的条件判断表达式的求值结果必须是布尔类型，即要么是 true，要么是 false：</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> runtime.GOOS == <span class="string">"linux"</span> {</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">"we are on linux os"</span>)    </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (runtime.GOOS == <span class="string">"linux"</span>) &amp;&amp; (runtime.GOARCH == <span class="string">"amd64"</span>) &amp;&amp;</span><br><span class="line">    (runtime.Compiler != <span class="string">"gccgo"</span>) {</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">"we are using standard go compiler on linux os for amd64"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><img src="/img/go%E5%AD%A6%E4%B9%A0/image-20250515144621388.png" alt="image-20250515144621388"></p>
<p><img src="/img/go%E5%AD%A6%E4%B9%A0/image-20250515144643734.png" alt="image-20250515144643734"></p>
<p><strong>左右移优先级大于+，-，这点和C++不同</strong></p>
<p>多分支：</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> boolean_expression1 {</span><br><span class="line">  <span class="comment">// 分支1</span></span><br><span class="line">} <span class="keyword">else</span> <span class="keyword">if</span> boolean_expression2 {</span><br><span class="line">  <span class="comment">// 分支2</span></span><br><span class="line">... ...</span><br><span class="line">} <span class="keyword">else</span> <span class="keyword">if</span> boolean_expressionN {</span><br><span class="line">  <span class="comment">// 分支N</span></span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">  <span class="comment">// 分支N+1</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价于：</span></span><br><span class="line"><span class="keyword">if</span> boolean_expression1 {</span><br><span class="line">    <span class="comment">// 分支1</span></span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">    <span class="keyword">if</span> boolean_expression2 {</span><br><span class="line">        <span class="comment">// 分支2</span></span><br><span class="line">    } <span class="keyword">else</span> { </span><br><span class="line">        <span class="keyword">if</span> boolean_expression3 {</span><br><span class="line">            <span class="comment">// 分支3</span></span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// 分支4</span></span><br><span class="line">        } </span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong>if 语句的自用变量</strong></p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">if</span> a, c := f(), h(); a &gt; <span class="number">0</span> {</span><br><span class="line">        <span class="built_in">println</span>(a)</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> b := f(); b &gt; <span class="number">0</span> {</span><br><span class="line">        <span class="built_in">println</span>(a, b)</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="built_in">println</span>(a, b, c)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>其中，a，b，c，在判断之前声明定义得变量，是自用变量。</p>
<p>至于这些变量的生命周期，则是从声明，到整个 if 结束。</p>
<p><strong>在 if 语句中声明自用变量是 Go 语言的一个惯用法</strong></p>
<p>不过Go 控制结构与短变量声明的结合也是“变量遮蔽”问题出没的重灾区。</p>
<p><strong>if 语句的“快乐路径”原则</strong></p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//伪代码段1：</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doSomething</span><span class="params">()</span></span> <span class="type">error</span> {</span><br><span class="line">  <span class="keyword">if</span> errorCondition1 {</span><br><span class="line">    <span class="comment">// some error logic</span></span><br><span class="line">    ... ...</span><br><span class="line">    <span class="keyword">return</span> err1</span><br><span class="line">  }</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// some success logic</span></span><br><span class="line">  ... ...</span><br><span class="line">  <span class="keyword">if</span> errorCondition2 {</span><br><span class="line">    <span class="comment">// some error logic</span></span><br><span class="line">    ... ...</span><br><span class="line">    <span class="keyword">return</span> err2</span><br><span class="line">  }</span><br><span class="line">  <span class="comment">// some success logic</span></span><br><span class="line">  ... ...</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">}</span><br><span class="line"><span class="comment">// 伪代码段2：</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doSomething</span><span class="params">()</span></span> <span class="type">error</span> {</span><br><span class="line">  <span class="keyword">if</span> successCondition1 {</span><br><span class="line">    <span class="comment">// some success logic</span></span><br><span class="line">    ... ...</span><br><span class="line">    <span class="keyword">if</span> successCondition2 {</span><br><span class="line">      <span class="comment">// some success logic</span></span><br><span class="line">      ... ...</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">      <span class="comment">// some error logic</span></span><br><span class="line">      ... ...</span><br><span class="line">      <span class="keyword">return</span> err2</span><br><span class="line">    }</span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line">    <span class="comment">// some error logic</span></span><br><span class="line">    ... ...</span><br><span class="line">    <span class="keyword">return</span> err1</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>显然代码段一优于代码段二。</p>
<p>也就是成功路径顺下来，if 语句处理失败情况并返回。</p>
<p>这种思路跟<code>if 语句如果返回则不允许写 else</code>有类似之处。原来叫快乐路径啊。</p>
<p>所谓“快乐路径”也就是成功逻辑的代码执行路径，它的特点是这样的：</p>
<ul>
<li>
<p>仅使用单分支控制结构；</p>
</li>
<li>
<p>当布尔表达式求值为 false 时，也就是出现错误时，在单分支中快速返回；</p>
</li>
<li>
<p>正常逻辑在代码布局上始终“靠左”，这样读者可以从上到下一眼看到该函数正常逻辑的全貌；</p>
</li>
<li>
<p>函数执行到最后一行代表一种成功状态。</p>
</li>
<li>
<p>尝试将“正常逻辑”提取出来，放到“快乐路径”中；</p>
</li>
<li>
<p>如果无法做到上一点，很可能是函数内的逻辑过于复杂，可以将深度缩进到 else 分支中的代码析出到一个函数中，再对原函数实施“快乐路径”原则。</p>
</li>
</ul>
<h3 id="for-循环"><a class="markdownIt-Anchor" href="#for-循环"></a> for 循环</h3>
<p>Go 只有一种循环语句，也就是 for 语句。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C.</span></span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {</span><br><span class="line">    sum += i;</span><br><span class="line">}</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, sum);</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Go. for 循环的经典形式</span></span><br><span class="line"><span class="keyword">var</span> sum <span class="type">int</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ {</span><br><span class="line">    sum += i</span><br><span class="line">}</span><br><span class="line"><span class="built_in">println</span>(sum)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多变量声明</span></span><br><span class="line"><span class="keyword">for</span> i, j, k := <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>; (i &lt; <span class="number">20</span>) &amp;&amp; (j &lt; <span class="number">10</span>) &amp;&amp; (k &lt; <span class="number">30</span>); i, j, k = i+<span class="number">1</span>, j+<span class="number">1</span>, k+<span class="number">5</span> {</span><br><span class="line">    sum += (i + j + k)</span><br><span class="line">    <span class="built_in">println</span>(sum)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 与C一样，();();() 这三个东西都可以省略。</span></span><br><span class="line">i := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> ; i &lt; <span class="number">10</span>; {</span><br><span class="line">    <span class="built_in">println</span>(i)</span><br><span class="line">    i++</span><br><span class="line">}  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 但是只保留 ;(); 时，可以更优化为：</span></span><br><span class="line">i := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i &lt; <span class="number">10</span> {</span><br><span class="line">    <span class="built_in">println</span>(i)</span><br><span class="line">    i++</span><br><span class="line">}  </span><br><span class="line"><span class="comment">// 也就是 while 循环</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果要求死循环：</span></span><br><span class="line"><span class="keyword">for</span> { </span><br><span class="line">   <span class="comment">// 循环体代码</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价于：</span></span><br><span class="line"><span class="keyword">for</span> <span class="literal">true</span> {</span><br><span class="line">    </span><br><span class="line">}</span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line"><span class="keyword">for</span> ;; {</span><br><span class="line">    </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong>for range 循环</strong></p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sl = []<span class="type">int</span>{<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>}</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(sl); i++ {</span><br><span class="line">    fmt.Printf(<span class="string">"sl[%d] = %d\n"</span>, i, sl[i])</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价于:</span></span><br><span class="line"><span class="keyword">for</span> i, v := <span class="keyword">range</span> sl {</span><br><span class="line">    fmt.Printf(<span class="string">"sl[%d] = %d\n"</span>, i, v)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 变种一：当我们不关心元素的值时，我们可以省略代表元素值的变量 v，</span></span><br><span class="line"><span class="comment">// 只声明代表下标值的变量 i：</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> sl {</span><br><span class="line">  <span class="comment">// ... </span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 变种二：如果我们不关心元素下标，只关心元素值，</span></span><br><span class="line"><span class="comment">// 那么我们可以用空标识符替代代表下标值的变量 i。</span></span><br><span class="line"><span class="comment">// 这里一定要注意，这个空标识符不能省略，</span></span><br><span class="line"><span class="comment">// 否则就与上面的“变种一”形式一样了，Go 编译器将无法区分：</span></span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> sl {</span><br><span class="line">  <span class="comment">// ... </span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 变种三：到这里，你肯定要问：</span></span><br><span class="line"><span class="comment">// 如果我们既不关心下标值，也不关心元素值，那是否能写成下面这样呢：</span></span><br><span class="line"><span class="keyword">for</span> _, _ = <span class="keyword">range</span> sl {</span><br><span class="line">  <span class="comment">// ... </span></span><br><span class="line">}</span><br><span class="line"><span class="comment">// 不太优雅：</span></span><br><span class="line"><span class="keyword">for</span> <span class="keyword">range</span> sl {</span><br><span class="line">  <span class="comment">// ... </span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong>string 类型</strong></p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">"中国人"</span></span><br><span class="line"><span class="keyword">for</span> i, v := <span class="keyword">range</span> s {</span><br><span class="line">    fmt.Printf(<span class="string">"%d %s 0x%x\n"</span>, i, <span class="type">string</span>(v), v)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>输出：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0 中 0x4e2d</span><br><span class="line">3 国 0x56fd</span><br><span class="line">6 人 0x4eba</span><br></pre></td></tr></tbody></table></figure>
<p>我们看到：for range 对于 string 类型来说，<strong>每次循环得到的 v 值是一个 Unicode 字符码点</strong>，也就是 rune 类型值，而不是一个字节，返回的第一个值 i 为<strong>该 Unicode 字符码点的内存编码（UTF-8）的第一个字节在字符串内存序列中的位置</strong>。</p>
<p><strong>map 的for-range</strong></p>
<p>Go 语言中，<strong>我们要对 map 进行循环操作，for range 是唯一的方法</strong>，for 经典循环形式是不支持对 map 类型变量的循环控制的。</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m = <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span> {</span><br><span class="line">  <span class="string">"Rob"</span> : <span class="number">67</span>,</span><br><span class="line">    <span class="string">"Russ"</span> : <span class="number">39</span>,</span><br><span class="line">    <span class="string">"John"</span> : <span class="number">29</span>,</span><br><span class="line">}</span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> m {</span><br><span class="line">    <span class="built_in">println</span>(k, v)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong>每次循环，循环变量 k 和 v 分别会被赋值为 map 键值对集合中一个元素的 key 值和 value 值</strong>。</p>
<p><strong>channel 的for-range</strong></p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> c = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"><span class="keyword">for</span> v := <span class="keyword">range</span> c {</span><br><span class="line">   <span class="comment">// ... </span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>在这个例子中，for range 每次从 channel 中读取一个元素后，会把它赋值给循环变量 v，并进入循环体。当 channel 中没有数据可读的时候，for range 循环会阻塞在对 channel 的读操作上。直到 channel 关闭时，for range 循环才会结束，这也是 for range 循环与 channel 配合时隐含的循环判断条件。</p>
<p><strong>带 label 的 continue 语句</strong></p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sum <span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> sl = []<span class="type">int</span>{<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>}</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(sl); i++ {</span><br><span class="line">    <span class="keyword">if</span> sl[i]%<span class="number">2</span> == <span class="number">0</span> {</span><br><span class="line">        <span class="comment">// 忽略切片中值为偶数的元素</span></span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    }</span><br><span class="line">    sum += sl[i]</span><br><span class="line">}</span><br><span class="line"><span class="built_in">println</span>(sum) <span class="comment">// 9</span></span><br></pre></td></tr></tbody></table></figure>
<p>这段代码与C无异。但 Go 语言中的 continue 在 C 语言 continue 语义的基础上<strong>又增加了对 label 的支持</strong>。</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">var</span> sum <span class="type">int</span></span><br><span class="line">    <span class="keyword">var</span> sl = []<span class="type">int</span>{<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>}</span><br><span class="line">loop:</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(sl); i++ {</span><br><span class="line">        <span class="keyword">if</span> sl[i]%<span class="number">2</span> == <span class="number">0</span> {</span><br><span class="line">            <span class="comment">// 忽略切片中值为偶数的元素</span></span><br><span class="line">            <span class="keyword">continue</span> loop</span><br><span class="line">        }</span><br><span class="line">        sum += sl[i]</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">println</span>(sum) <span class="comment">// 9</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>通常出现于<strong>嵌套循环语句</strong>中，<strong>被用于跳转到外层循环并继续执行外层循环语句的下一个迭代</strong></p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">var</span> sl = [][]<span class="type">int</span>{</span><br><span class="line">        {<span class="number">1</span>, <span class="number">34</span>, <span class="number">26</span>, <span class="number">35</span>, <span class="number">78</span>},</span><br><span class="line">        {<span class="number">3</span>, <span class="number">45</span>, <span class="number">13</span>, <span class="number">24</span>, <span class="number">99</span>},</span><br><span class="line">        {<span class="number">101</span>, <span class="number">13</span>, <span class="number">38</span>, <span class="number">7</span>, <span class="number">127</span>},</span><br><span class="line">        {<span class="number">54</span>, <span class="number">27</span>, <span class="number">40</span>, <span class="number">83</span>, <span class="number">81</span>},</span><br><span class="line">    }</span><br><span class="line">outerloop:</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(sl); i++ {</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="built_in">len</span>(sl[i]); j++ {</span><br><span class="line">            <span class="keyword">if</span> sl[i][j] == <span class="number">13</span> {</span><br><span class="line">                fmt.Printf(<span class="string">"found 13 at [%d, %d]\n"</span>, i, j)</span><br><span class="line">                <span class="keyword">continue</span> outerloop</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>一些学习过 goto 语句的同学可能就会问了，如果我把上述代码中的 continue 换成 goto 语句，是否也可以实现同样的效果？</p>
<p>答案是否定的！一旦使用 goto 跳转，那么<strong>不管是内层循环还是外层循环都会被终结，代码将会从 outerloop 这个 label 处，开始重新执行我们的嵌套循环语句，这与带 label 的 continue 的跳转语义是完全不同的</strong>。</p>
<p><strong>break 语句的使用</strong></p>
<p>Go 也 break 语句增加了对 label 的支持。</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gold = <span class="number">38</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">var</span> sl = [][]<span class="type">int</span>{</span><br><span class="line">        {<span class="number">1</span>, <span class="number">34</span>, <span class="number">26</span>, <span class="number">35</span>, <span class="number">78</span>},</span><br><span class="line">        {<span class="number">3</span>, <span class="number">45</span>, <span class="number">13</span>, <span class="number">24</span>, <span class="number">99</span>},</span><br><span class="line">        {<span class="number">101</span>, <span class="number">13</span>, <span class="number">38</span>, <span class="number">7</span>, <span class="number">127</span>},</span><br><span class="line">        {<span class="number">54</span>, <span class="number">27</span>, <span class="number">40</span>, <span class="number">83</span>, <span class="number">81</span>},</span><br><span class="line">    }</span><br><span class="line">outerloop:</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(sl); i++ {</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="built_in">len</span>(sl[i]); j++ {</span><br><span class="line">            <span class="keyword">if</span> sl[i][j] == gold {</span><br><span class="line">                fmt.Printf(<span class="string">"found gold at [%d, %d]\n"</span>, i, j)</span><br><span class="line">                <span class="keyword">break</span> outerloop</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>注意：标签只表示区域，而且必须先声明后跳转。</p>
<p><strong>for 语句的常见“坑”与避坑方法</strong></p>
<p><strong>问题一：循环变量的重用</strong></p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">var</span> m = []<span class="type">int</span>{<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>}  </span><br><span class="line">             </span><br><span class="line">    <span class="keyword">for</span> i, v := <span class="keyword">range</span> m {</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">            time.Sleep(time.Second * <span class="number">3</span>)</span><br><span class="line">            fmt.Println(i, v)</span><br><span class="line">        }()</span><br><span class="line">    }</span><br><span class="line">    time.Sleep(time.Second * <span class="number">10</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>可见，在func中，i，v是引用。</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//期望：</span><br><span class="line">0 1</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">3 4</span><br><span class="line">4 5</span><br><span class="line">//结果：</span><br><span class="line">4 5</span><br><span class="line">4 5</span><br><span class="line">4 5</span><br><span class="line">4 5</span><br><span class="line">4 5</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">var</span> m = []<span class="type">int</span>{<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>}</span><br><span class="line">    <span class="keyword">for</span> i, v := <span class="keyword">range</span> m {</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i, v <span class="type">int</span>)</span></span> {</span><br><span class="line">            time.Sleep(time.Second * <span class="number">3</span>)</span><br><span class="line">            fmt.Println(i, v)</span><br><span class="line">        }(i, v)</span><br><span class="line">    }</span><br><span class="line">    time.Sleep(time.Second * <span class="number">10</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>通过值传递就可以解决这个问题。</p>
<p><strong>问题二：参与循环的是 range 表达式的副本</strong></p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">var</span> a = [<span class="number">5</span>]<span class="type">int</span>{<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>}</span><br><span class="line">    <span class="keyword">var</span> r [<span class="number">5</span>]<span class="type">int</span></span><br><span class="line">    fmt.Println(<span class="string">"original a ="</span>, a)</span><br><span class="line">    <span class="keyword">for</span> i, v := <span class="keyword">range</span> a {</span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">0</span> {</span><br><span class="line">            a[<span class="number">1</span>] = <span class="number">12</span></span><br><span class="line">            a[<span class="number">2</span>] = <span class="number">13</span></span><br><span class="line">        }</span><br><span class="line">        r[i] = v</span><br><span class="line">    }</span><br><span class="line">    fmt.Println(<span class="string">"after for range loop, r ="</span>, r)</span><br><span class="line">    fmt.Println(<span class="string">"after for range loop, a ="</span>, a)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//期望：</span><br><span class="line">original a = [1 2 3 4 5]</span><br><span class="line">after for range loop, r = [1 12 13 4 5]</span><br><span class="line">after for range loop, a = [1 12 13 4 5]</span><br><span class="line">//结果：</span><br><span class="line">original a = [1 2 3 4 5]</span><br><span class="line">after for range loop, r = [1 2 3 4 5]</span><br><span class="line">after for range loop, a = [1 12 13 4 5]</span><br></pre></td></tr></tbody></table></figure>
<p>原因就是<strong>参与 for range 循环的是 range 表达式的副本。</strong></p>
<p>用切片可以解决这个问题：</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">var</span> a = [<span class="number">5</span>]<span class="type">int</span>{<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>}</span><br><span class="line">    <span class="keyword">var</span> r [<span class="number">5</span>]<span class="type">int</span></span><br><span class="line">    fmt.Println(<span class="string">"original a ="</span>, a)</span><br><span class="line">    <span class="keyword">for</span> i, v := <span class="keyword">range</span> a[:] { <span class="comment">// 切片或者使用指针 &amp;a</span></span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">0</span> {</span><br><span class="line">            a[<span class="number">1</span>] = <span class="number">12</span></span><br><span class="line">            a[<span class="number">2</span>] = <span class="number">13</span></span><br><span class="line">        }</span><br><span class="line">        r[i] = v</span><br><span class="line">    }</span><br><span class="line">    fmt.Println(<span class="string">"after for range loop, r ="</span>, r)</span><br><span class="line">    fmt.Println(<span class="string">"after for range loop, a ="</span>, a)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong>问题三：遍历 map 中元素的随机性</strong></p>
<h3 id="switch"><a class="markdownIt-Anchor" href="#switch"></a> switch</h3>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> initStmt; expr {</span><br><span class="line">    <span class="keyword">case</span> expr1:</span><br><span class="line">        <span class="comment">// 执行分支1</span></span><br><span class="line">    <span class="keyword">case</span> expr2:</span><br><span class="line">        <span class="comment">// 执行分支2</span></span><br><span class="line">    <span class="keyword">case</span> expr3_1, expr3_2, expr3_3:</span><br><span class="line">        <span class="comment">// 执行分支3</span></span><br><span class="line">    <span class="keyword">case</span> expr4:</span><br><span class="line">        <span class="comment">// 执行分支4</span></span><br><span class="line">    ... ...</span><br><span class="line">    <span class="keyword">case</span> exprN:</span><br><span class="line">        <span class="comment">// 执行分支N</span></span><br><span class="line">    <span class="keyword">default</span>: </span><br><span class="line">        <span class="comment">// 执行默认分支</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readByExtBySwitch</span><span class="params">(ext <span class="type">string</span>)</span></span> {</span><br><span class="line">    <span class="keyword">switch</span> ext {</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"json"</span>:</span><br><span class="line">        <span class="built_in">println</span>(<span class="string">"read json file"</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"jpg"</span>, <span class="string">"jpeg"</span>, <span class="string">"png"</span>, <span class="string">"gif"</span>:</span><br><span class="line">        <span class="built_in">println</span>(<span class="string">"read image file"</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"txt"</span>, <span class="string">"md"</span>:</span><br><span class="line">        <span class="built_in">println</span>(<span class="string">"read text file"</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"yml"</span>, <span class="string">"yaml"</span>:</span><br><span class="line">        <span class="built_in">println</span>(<span class="string">"read yaml file"</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"ini"</span>:</span><br><span class="line">        <span class="built_in">println</span>(<span class="string">"read ini file"</span>)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">println</span>(<span class="string">"unsupported file extension:"</span>, ext)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>关于 switch 求值顺序：</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">case1</span><span class="params">()</span></span> <span class="type">int</span> {</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">"eval case1 expr"</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">case2_1</span><span class="params">()</span></span> <span class="type">int</span> {</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">"eval case2_1 expr"</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> </span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">case2_2</span><span class="params">()</span></span> <span class="type">int</span> {</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">"eval case2_2 expr"</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> </span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">case3</span><span class="params">()</span></span> <span class="type">int</span> {</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">"eval case3 expr"</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span></span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">switchexpr</span><span class="params">()</span></span> <span class="type">int</span> {</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">"eval switch expr"</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">switch</span> switchexpr() {</span><br><span class="line">    <span class="keyword">case</span> case1():</span><br><span class="line">        <span class="built_in">println</span>(<span class="string">"exec case1"</span>)</span><br><span class="line">    <span class="keyword">case</span> case2_1(), case2_2():</span><br><span class="line">        <span class="built_in">println</span>(<span class="string">"exec case2"</span>)</span><br><span class="line">    <span class="keyword">case</span> case3():</span><br><span class="line">        <span class="built_in">println</span>(<span class="string">"exec case3"</span>)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">println</span>(<span class="string">"exec default"</span>)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>输出：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">eval switch expr</span><br><span class="line">eval case1 expr</span><br><span class="line">eval case2_1 expr</span><br><span class="line">eval case2_2 expr</span><br><span class="line">exec case2</span><br></pre></td></tr></tbody></table></figure>
<p>也就是说，Go的 switch 只是好看的 if 而已，不能像C一样来用优化性能。</p>
<p><strong>无论 default 分支出现在什么位置，它都只会在所有 case 都没有匹配上的情况下才会被执行的。</strong></p>
<p>Go 语言中只要类型支持比较操作，都可以作为 switch 语句中的表达式类型。</p>
<p>而且，当 switch 表达式的类型为布尔类型时，如果求值结果始终为 true，那么我们甚至可以省略 switch 后面的表达式，比如下面例子：</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 带有initStmt语句的switch语句</span></span><br><span class="line"><span class="keyword">switch</span> initStmt; {</span><br><span class="line">    <span class="keyword">case</span> bool_expr1:</span><br><span class="line">    <span class="keyword">case</span> bool_expr2:</span><br><span class="line">    ... ...</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 没有initStmt语句的switch语句</span></span><br><span class="line"><span class="keyword">switch</span> {</span><br><span class="line">    <span class="keyword">case</span> bool_expr1:</span><br><span class="line">    <span class="keyword">case</span> bool_expr2:</span><br><span class="line">    ... ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong>第二点：switch 语句支持声明临时变量。</strong></p>
<p>switch 语句的 initStmt 可用来声明只在这个 switch 隐式代码块中使用的变量，这种就近声明的变量最大程度地缩小了变量的作用域。</p>
<p><strong>第三点：case 语句支持表达式列表。</strong></p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">checkWorkday</span><span class="params">(a <span class="type">int</span>)</span></span> {</span><br><span class="line">    <span class="keyword">switch</span> a {</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>:</span><br><span class="line">        <span class="built_in">println</span>(<span class="string">"it is a work day"</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span>, <span class="number">7</span>:</span><br><span class="line">        <span class="built_in">println</span>(<span class="string">"it is a weekend day"</span>)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">println</span>(<span class="string">"are you live on earth"</span>)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>如果在少数场景下，你需要执行下一个 case 的代码逻辑，你可以显式使用 Go 提供的关键字 fallthrough 来实现，这也是 Go“显式”设计哲学的一个体现。</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">case1</span><span class="params">()</span></span> <span class="type">int</span> {</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">"eval case1 expr"</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">case2</span><span class="params">()</span></span> <span class="type">int</span> {</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">"eval case2 expr"</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">switchexpr</span><span class="params">()</span></span> <span class="type">int</span> {</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">"eval switch expr"</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">switch</span> switchexpr() {</span><br><span class="line">    <span class="keyword">case</span> case1():</span><br><span class="line">        <span class="built_in">println</span>(<span class="string">"exec case1"</span>)</span><br><span class="line">        <span class="keyword">fallthrough</span></span><br><span class="line">    <span class="keyword">case</span> case2():</span><br><span class="line">        <span class="built_in">println</span>(<span class="string">"exec case2"</span>)</span><br><span class="line">        <span class="keyword">fallthrough</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">println</span>(<span class="string">"exec default"</span>)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong>type switch</strong></p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">var</span> x <span class="keyword">interface</span>{} = <span class="number">13</span></span><br><span class="line">    <span class="keyword">switch</span> v := x.(<span class="keyword">type</span>) {</span><br><span class="line">    <span class="keyword">case</span> <span class="literal">nil</span>:</span><br><span class="line">        <span class="built_in">println</span>(<span class="string">"x is nil"</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">int</span>:</span><br><span class="line">        <span class="built_in">println</span>(<span class="string">"the type of x is int"</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">string</span>:</span><br><span class="line">        <span class="built_in">println</span>(<span class="string">"the type of x is string"</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">bool</span>:</span><br><span class="line">        <span class="built_in">println</span>(<span class="string">"the type of x is string"</span>)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">println</span>(<span class="string">"don't support the type"</span>)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>switch 关键字后面跟着的表达式为x.(type)，这种表达式形式是 switch 语句专有的，而且也只能在 switch 语句中使用。这个表达式中的 <strong>x 必须是一个接口类型变量</strong>，表达式的求值结果是这个接口类型变量对应的动态类型。</p>
<p><strong>v 存储的是变量 x 的动态类型对应的值信息</strong></p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> I <span class="keyword">interface</span> {</span><br><span class="line">      M()</span><br><span class="line">  }</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">type</span> T <span class="keyword">struct</span> {</span><br><span class="line">  }</span><br><span class="line">  </span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(T)</span></span> M() {</span><br><span class="line"> }</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">     <span class="keyword">var</span> t T</span><br><span class="line">     <span class="keyword">var</span> i I = t</span><br><span class="line">     <span class="keyword">switch</span> i.(<span class="keyword">type</span>) {</span><br><span class="line">     <span class="keyword">case</span> T:</span><br><span class="line">         <span class="built_in">println</span>(<span class="string">"it is type T"</span>)</span><br><span class="line">     <span class="keyword">case</span> <span class="type">int</span>:</span><br><span class="line">         <span class="built_in">println</span>(<span class="string">"it is type int"</span>)</span><br><span class="line">     <span class="keyword">case</span> <span class="type">string</span>:</span><br><span class="line">         <span class="built_in">println</span>(<span class="string">"it is type string"</span>)</span><br><span class="line">     }</span><br><span class="line"> }</span><br></pre></td></tr></tbody></table></figure>
<p>在这个例子中，我们在 type switch 中使用了自定义的接口类型 I。那么，理论上所有 case 后面的类型都只能是实现了接口 I 的类型。但在这段代码中，只有类型 T 实现了接口类型 I，Go 原生类型 int 与 string 都没有实现接口 I，于是在编译上述代码时，编译器会报出如下错误信息：</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">19</span>:<span class="number">2</span>: impossible <span class="keyword">type</span> <span class="keyword">switch</span> <span class="keyword">case</span>: i (<span class="keyword">type</span> I) cannot have dynamic <span class="keyword">type</span> <span class="type">int</span> (missing M method)</span><br><span class="line"><span class="number">21</span>:<span class="number">2</span>: impossible <span class="keyword">type</span> <span class="keyword">switch</span> <span class="keyword">case</span>: i (<span class="keyword">type</span> I) cannot have dynamic <span class="keyword">type</span> <span class="type">string</span> (missing M method)</span><br></pre></td></tr></tbody></table></figure>
<p><strong>跳不出循环的 break</strong></p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">var</span> sl = []<span class="type">int</span>{<span class="number">5</span>, <span class="number">19</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">12</span>}</span><br><span class="line">    <span class="keyword">var</span> firstEven <span class="type">int</span> = <span class="number">-1</span></span><br><span class="line">    <span class="comment">// find first even number of the interger slice</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(sl); i++ {</span><br><span class="line">        <span class="keyword">switch</span> sl[i] % <span class="number">2</span> {</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            firstEven = sl[i]</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="comment">// do nothing</span></span><br><span class="line">        }        </span><br><span class="line">    }         </span><br><span class="line">    <span class="built_in">println</span>(firstEven) </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>Go 语言规范中明确规定，<strong>不带 label 的 break 语句中断执行并跳出的，是同一函数内 break 语句所在的最内层的 for、switch 或 select</strong>。</p>
<h2 id="函数-一等公民"><a class="markdownIt-Anchor" href="#函数-一等公民"></a> 函数 - 一等公民</h2>
<p>在 Go 中，我们定义一个函数的最常用方式就是使用<strong>函数声明</strong>。我们以 Go 标准库 fmt 包提供的 Fprintf 函数为例，看一下一个<strong>普通 Go 函数的声明</strong>长啥样：</p>
<p><img src="/img/go%E5%AD%A6%E4%B9%A0/image-20250515160849170.png" alt="image-20250515160849170"></p>
<p><strong>第一部分是关键字 func</strong>，Go 函数声明必须以关键字 func 开始。</p>
<p><strong>第二部分是函数名</strong>。函数名是指代函数定义的标识符，函数声明后，我们会通过函数名这个标识符来使用这个函数。在同一个 Go 包中，函数名应该是唯一的，并且它也遵守 Go 标识符的导出规则，也就是我们之前说的，首字母大写的函数名指代的函数是可以在包外使用的，小写的就只在包内可见。</p>
<p>**第三部分是参数列表。**参数列表中声明了我们将要在函数体中使用的各个参数。参数列表紧接在函数名的后面，并用一个括号包裹。它使用逗号作为参数间的分隔符，而且每个参数的参数名在前，参数类型在后，这和变量声明中变量名与类型的排列方式是一致的。</p>
<p>另外，Go 函数支持变长参数，也就是一个形式参数可以对应数量不定的实际参数。Fprintf 就是一个支持变长参数的函数，你可以看到它第三个形式参数 a 就是一个变长参数，而且变长参数与普通参数在声明时的不同点，就在于它会在类型前面增加了一个“…”符号。</p>
<p><strong>第四部分是返回值列表</strong>。返回值承载了函数执行后要返回给调用者的结果，返回值列表声明了这些返回值的类型，返回值列表的位置紧接在参数列表后面，两者之间用一个空格隔开。不过，上图中比较特殊，Fprintf 函数的返回值列表不仅声明了返回值的类型，还声明了返回值的名称，这种返回值被称为<strong>具名返回值</strong>。</p>
<p><strong>最后，放在一对大括号内的是函数体</strong>，函数的具体实现都放在这里。不过，函数声明中的<strong>函数体是可选的</strong>。如果没有函数体，说明这个函数可能是在 Go 语言之外实现的，比如使用汇编语言实现，然后通过链接器将实现与声明中的函数名链接到一起。</p>
<p>把上面的函数声明等价转换为变量声明的形式看看：</p>
<p><img src="/img/go%E5%AD%A6%E4%B9%A0/image-20250515161300622-1747296780915-1.png" alt="image-20250515161300622"></p>
<p><strong>这不就是在声明一个类型为函数类型的变量吗</strong>！</p>
<p>函数声明中的 func 关键字、参数列表和返回值列表共同构成了<strong>函数类型</strong>。而参数列表与返回值列表的组合也被称为<strong>函数签名</strong>，它是决定两个函数类型是否相同的决定因素。<strong>函数类型</strong>也可以看成是由 func 关键字与函数签名组合而成的。</p>
<p>如：<code>func(io.Writer, string, ...interface{}) (int, error)</code></p>
<p>如果两个函数类型的函数签名是相同的，即便参数列表中的参数名，以及返回值列表中的返回值变量名都是不同的，那么这两个函数类型也是相同类型，比如下面两个函数类型：</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a <span class="type">int</span>, b <span class="type">string</span>)</span></span> (results []<span class="type">string</span>, err <span class="type">error</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c <span class="type">int</span>, d <span class="type">string</span>)</span></span> (sl []<span class="type">string</span>, err <span class="type">error</span>)</span><br></pre></td></tr></tbody></table></figure>
<p><strong>每个函数声明所定义的函数，仅仅是对应的函数类型的一个实例</strong></p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s := T{}      <span class="comment">// 使用复合类型字面值对结构体类型T的变量进行显式初始化</span></span><br><span class="line">f := <span class="function"><span class="keyword">func</span><span class="params">()</span></span>{} <span class="comment">// 使用变量声明形式的函数声明</span></span><br></pre></td></tr></tbody></table></figure>
<p>这里，T{}被称为复合类型字面值，那么处于同样位置的 func(){}是什么呢？Go 语言也为它准备了一个名字，叫“<strong>函数字面值</strong>（Function Literal）”。我们可以看到，函数字面值由函数类型与函数体组成，它特别像一个没有函数名的函数声明，因此我们也叫它<strong>匿名函数</strong>。</p>
<p><strong>函数参数</strong></p>
<p><img src="/img/go%E5%AD%A6%E4%B9%A0/image-20250515161931701.png" alt="image-20250515161931701"></p>
<p>函数参数列表中的参数，是函数声明的、用于函数体实现的局部变量。由于函数分为声明与使用两个阶段，在不同阶段，参数的称谓也有不同。在函数声明阶段，我们把参数列表中的参数叫做<strong>形式参数</strong>（Parameter，简称形参），在函数体中，我们使用的都是形参；而在函数实际调用时传入的参数被称为<strong>实际参数</strong>（Argument，简称实参）。</p>
<p>Go 语言中，函数参数传递采用是<strong>值传递</strong>的方式。所谓“值传递”，就是将实际参数在内存中的表示<strong>逐位拷贝</strong>（Bitwise Copy）到形式参数中。对于像整型、数组、结构体这类类型，它们的内存表示就是它们自身的数据内容，因此当这些类型作为实参类型时，值传递拷贝的就是它们自身，传递的开销也与它们自身的大小成正比。</p>
<p>但是像 string、切片、map 这些类型就不是了，它们的内存表示对应的是它们数据内容的“描述符”。当这些类型作为实参类型时，值传递拷贝的也是它们数据内容的“描述符”，不包括数据内容本身，所以这些类型传递的开销是固定的，与数据内容大小无关。这种只拷贝“描述符”，不拷贝实际数据内容的拷贝过程，也被称为**“浅拷贝”**。</p>
<p>不过函数参数的传递也有两个例外，当函数的形参为接口类型，或者形参是变长参数时，简单的值传递就不能满足要求了，这时 Go 编译器会介入：<strong>对于类型为接口类型的形参，Go 编译器会把传递的实参赋值给对应的接口类型形参；对于为变长参数的形参，Go 编译器会将零个或多个实参按一定形式转换为对应的变长形参。</strong></p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myAppend</span><span class="params">(sl []<span class="type">int</span>, elems ...<span class="type">int</span>)</span></span> []<span class="type">int</span> {</span><br><span class="line">    fmt.Printf(<span class="string">"%T\n"</span>, elems) <span class="comment">// []int</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(elems) == <span class="number">0</span> {</span><br><span class="line">        <span class="built_in">println</span>(<span class="string">"no elems to append"</span>)</span><br><span class="line">        <span class="keyword">return</span> sl</span><br><span class="line">    }</span><br><span class="line">    sl = <span class="built_in">append</span>(sl, elems...)</span><br><span class="line">    <span class="keyword">return</span> sl</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    sl := []<span class="type">int</span>{<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>}</span><br><span class="line">    sl = myAppend(sl) <span class="comment">// no elems to append</span></span><br><span class="line">    fmt.Println(sl) <span class="comment">// [1 2 3]</span></span><br><span class="line">    sl = myAppend(sl, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br><span class="line">    fmt.Println(sl) <span class="comment">// [1 2 3 4 5 6]</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>在 Go 中，<strong>变长参数实际上是通过切片来实现的</strong>。</p>
<p><strong>函数支持多返回值</strong></p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">()</span></span>                       <span class="comment">// 无返回值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">()</span></span> <span class="type">error</span>                 <span class="comment">// 仅有一个返回值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">()</span></span> (<span class="type">int</span>, <span class="type">string</span>, <span class="type">error</span>)  <span class="comment">// 有2或2个以上返回值</span></span><br></pre></td></tr></tbody></table></figure>
<p>为每个返回值声明变量名，这种带有名字的返回值被称为<strong>具名返回值</strong>（Named Return Value）。</p>
<p>**Go 标准库以及大多数项目代码中的函数，都选择了使用普通的非具名返回值形式。**但在一些特定场景下，具名返回值也会得到应用。</p>
<p><strong>函数是“一等公民”</strong></p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果一门编程语言对某种语言元素的创建和使用没有限制，我们可以像对待值（value）一样对待这种语法元素，那么我们就称这种语法元素是这门编程语言的“一等公民”。拥有“一等公民”待遇的语法元素可以存储在变量中，可以作为参数传递给函数，可以在函数内部创建并可以作为返回值从函数返回。</span><br></pre></td></tr></tbody></table></figure>
<p>（那么在C语言中，函数也是一等公民了？也能返回，存储，操作）</p>
<p><strong>特征一：Go 函数可以存储在变量中。</strong></p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    myFprintf = <span class="function"><span class="keyword">func</span><span class="params">(w io.Writer, format <span class="type">string</span>, a ...<span class="keyword">interface</span>{})</span></span> (<span class="type">int</span>, <span class="type">error</span>) {</span><br><span class="line">        <span class="keyword">return</span> fmt.Fprintf(w, format, a...)</span><br><span class="line">    }</span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    fmt.Printf(<span class="string">"%T\n"</span>, myFprintf) <span class="comment">// func(io.Writer, string, ...interface {}) (int, error)</span></span><br><span class="line">    myFprintf(os.Stdout, <span class="string">"%s\n"</span>, <span class="string">"Hello, Go"</span>) <span class="comment">// 输出Hello，Go</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>我们把新创建的一个匿名函数赋值给了一个名为 myFprintf 的变量，通过这个变量，我们便可以调用刚刚定义的匿名函数。</p>
<p><strong>特征二：支持在函数内创建并通过返回值返回。</strong></p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setup</span><span class="params">(task <span class="type">string</span>)</span></span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">"do some setup stuff for"</span>, task)</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">        <span class="built_in">println</span>(<span class="string">"do some teardown stuff for"</span>, task)</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    teardown := setup(<span class="string">"demo"</span>)</span><br><span class="line">    <span class="keyword">defer</span> teardown() <span class="comment">// 延迟，会在整个函数执行结束之后执行。同时倒序执行。</span></span><br><span class="line">    <span class="built_in">println</span>(<span class="string">"do some bussiness stuff"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>这个匿名函数使用了定义它的函数 setup 的局部变量 task，这样的匿名函数在 Go 中也被称为<strong>闭包</strong>（Closure）。</p>
<p>闭包本质上就是一个匿名函数或叫函数字面值，它们可以引用它的包裹函数，也就是创建它们的函数中定义的变量。然后，这些变量在包裹函数和匿名函数之间共享，只要闭包可以被访问，这些共享的变量就会继续存在。</p>
<p><strong>特征三：作为参数传入函数。</strong></p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">time.AfterFunc(time.Second*<span class="number">2</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> { <span class="built_in">println</span>(<span class="string">"timer fired"</span>) })</span><br></pre></td></tr></tbody></table></figure>
<p><strong>特征四：拥有自己的类型。</strong></p>
<p>我们甚至可以基于函数类型来自定义类型，就像基于整型、字符串类型等类型来自定义类型一样。下面代码中的 HandlerFunc、visitFunc 就是 Go 标准库中，基于函数类型进行自定义的类型：</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// $GOROOT/src/net/http/server.go</span></span><br><span class="line"><span class="keyword">type</span> HandlerFunc <span class="function"><span class="keyword">func</span><span class="params">(ResponseWriter, *Request)</span></span></span><br><span class="line"><span class="comment">// $GOROOT/src/sort/genzfunc.go</span></span><br><span class="line"><span class="keyword">type</span> visitFunc <span class="function"><span class="keyword">func</span><span class="params">(ast.Node)</span></span> ast.Visitor</span><br></pre></td></tr></tbody></table></figure>
<h2 id="多返回值与错误处理"><a class="markdownIt-Anchor" href="#多返回值与错误处理"></a> 多返回值与错误处理</h2>
<p>使用多返回值，返回一个单独表示错误状态的值，而不是让错误信息和返回信息耦合在一起。</p>
<p><strong>error 类型与错误值构造</strong></p>
<p>error 接口是 Go 原生内置的类型，它的定义如下：</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// $GOROOT/src/builtin/builtin.go</span></span><br><span class="line"><span class="keyword">type</span> <span class="keyword">interface</span> <span class="type">error</span> {</span><br><span class="line">    Error() <span class="type">string</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>任何实现了 error 的 Error 方法的类型的实例，都可以作为错误值赋值给 error 接口变量。那这里，问题就来了：<strong>难道为了构造一个错误值，我们还需要自定义一个新类型来实现 error 接口吗</strong>？</p>
<p>提供了两种方便 Go 开发者构造错误值的方法： errors.New和fmt.Errorf。</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">err := errors.New(<span class="string">"your first demo error"</span>)</span><br><span class="line">errWithCtx = fmt.Errorf(<span class="string">"index %d is out of bounds"</span>, i)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回类型是 errors.errorString</span></span><br><span class="line"><span class="comment">// $GOROOT/src/errors/errors.go</span></span><br><span class="line"><span class="keyword">type</span> errorString <span class="keyword">struct</span> {</span><br><span class="line">    s <span class="type">string</span></span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *errorString)</span></span> Error() <span class="type">string</span> {</span><br><span class="line">    <span class="keyword">return</span> e.s</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>它们给错误处理者提供的错误上下文（Error Context）只限于以字符串形式呈现的信息，也就是 Error 方法返回的信息。</p>
<p><strong>自定义错误类型</strong></p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// $GOROOT/src/net/net.go</span></span><br><span class="line"><span class="keyword">type</span> OpError <span class="keyword">struct</span> {</span><br><span class="line">    Op <span class="type">string</span></span><br><span class="line">    Net <span class="type">string</span></span><br><span class="line">    Source Addr</span><br><span class="line">    Addr Addr</span><br><span class="line">    Err <span class="type">error</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>可以提供更多上下文信息。</p>
<p>用error类型的好处：</p>
<ol>
<li>统一了错误类型。</li>
<li>错误是值。</li>
<li>易扩展，支持自定义错误上下文。</li>
</ol>
<h3 id="错误处理策略"><a class="markdownIt-Anchor" href="#错误处理策略"></a> 错误处理策略</h3>
<p><strong>策略一：透明错误处理策略</strong></p>
<p>最简单的错误策略莫过于完全不关心返回错误值携带的具体上下文信息，只要发生错误就进入唯一的错误处理执行路径，比如下面这段代码：</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">err := doSomething()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">    <span class="comment">// 不关心err变量底层错误值所携带的具体上下文信息</span></span><br><span class="line">    <span class="comment">// 执行简单错误处理逻辑并返回</span></span><br><span class="line">    ... ...</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>这也是 Go 语言中<strong>最常见的错误处理策略</strong>，80% 以上的 Go 错误处理情形都可以归类到这种策略下。在这种策略下，由于错误处理方并不关心错误值的上下文，所以错误值的构造方（如上面的函数doSomething）可以直接使用 Go 标准库提供的两个基本错误值构造方法errors.New和fmt.Errorf来构造错误值，就像下面这样：</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doSomething</span><span class="params">(...)</span></span> <span class="type">error</span> {</span><br><span class="line">    ... ...</span><br><span class="line">    <span class="keyword">return</span> errors.New(<span class="string">"some error occurred"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>这样构造出的错误值代表的上下文信息，对错误处理方是透明的，因此这种策略称为**“透明错误处理策略”**。在错误处理方不关心错误值上下文的前提下，透明错误处理策略能最大程度地减少错误处理方与错误值构造方之间的耦合关系。</p>
<p><strong>策略二：“哨兵”错误处理策略</strong></p>
<p>当错误处理方不能只根据“透明的错误值”就做出错误处理路径选取的情况下，错误处理方会尝试对返回的错误值进行检视，于是就有可能出现下面代码中的<strong>反模式</strong>：</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">data, err := b.Peek(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">    <span class="keyword">switch</span> err.Error() {</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"bufio: negative count"</span>:</span><br><span class="line">        <span class="comment">// ... ...</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">"bufio: buffer full"</span>:</span><br><span class="line">        <span class="comment">// ... ...</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">"bufio: invalid use of UnreadByte"</span>:</span><br><span class="line">        <span class="comment">// ... ...</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">// ... ...</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>但这种“反模式”会造成严重的<strong>隐式耦合</strong>。这也就意味着，错误值构造方不经意间的一次错误描述字符串的改动，都会造成错误处理方处理行为的变化，并且这种通过字符串比较的方式，对错误值进行检视的性能也很差。</p>
<p>Go 标准库采用了定义导出的（Exported）“哨兵”错误值的方式，来辅助错误处理方检视（inspect）错误值并做出错误处理分支的决策，比如下面的 bufio 包中定义的“哨兵错误”：</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// $GOROOT/src/bufio/bufio.go</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    ErrInvalidUnreadByte = errors.New(<span class="string">"bufio: invalid use of UnreadByte"</span>)</span><br><span class="line">    ErrInvalidUnreadRune = errors.New(<span class="string">"bufio: invalid use of UnreadRune"</span>)</span><br><span class="line">    ErrBufferFull        = errors.New(<span class="string">"bufio: buffer full"</span>)</span><br><span class="line">    ErrNegativeCount     = errors.New(<span class="string">"bufio: negative count"</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">data, err := b.Peek(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">    <span class="keyword">switch</span> err {</span><br><span class="line">    <span class="keyword">case</span> bufio.ErrNegativeCount:</span><br><span class="line">        <span class="comment">// ... ...</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">case</span> bufio.ErrBufferFull:</span><br><span class="line">        <span class="comment">// ... ...</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">case</span> bufio.ErrInvalidUnreadByte:</span><br><span class="line">        <span class="comment">// ... ...</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">// ... ...</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>（说白了就是约定一些常量来标志错误）</p>
<p>不过，对于 API 的开发者而言，**暴露“哨兵”错误值也意味着这些错误值和包的公共函数 / 方法一起成为了 API 的一部分。**一旦发布出去，开发者就要对它进行很好的维护。而“哨兵”错误值也让使用这些值的错误处理方对它产生了依赖。</p>
<p>从 Go 1.13 版本开始，标准库 errors 包提供了 Is 函数用于错误处理方对错误值的检视。Is 函数类似于把一个 error 类型变量与“哨兵”错误值进行比较，比如下面代码：</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类似 if err == ErrOutOfBounds{ … }</span></span><br><span class="line"><span class="keyword">if</span> errors.Is(err, ErrOutOfBounds) {</span><br><span class="line">    <span class="comment">// 越界的错误处理</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>不同的是，如果 error 类型变量的底层错误值是一个包装错误（Wrapped Error），errors.Is 方法会沿着该包装错误所在错误链（Error Chain)，与链上所有被包装的错误（Wrapped Error）进行比较，直至找到一个匹配的错误为止。下面是 Is 函数应用的一个例子：</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ErrSentinel = errors.New(<span class="string">"the underlying sentinel error"</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">  err1 := fmt.Errorf(<span class="string">"wrap sentinel: %w"</span>, ErrSentinel)</span><br><span class="line">  err2 := fmt.Errorf(<span class="string">"wrap err1: %w"</span>, err1)</span><br><span class="line">    <span class="built_in">println</span>(err2 == ErrSentinel) <span class="comment">//false</span></span><br><span class="line">  <span class="keyword">if</span> errors.Is(err2, ErrSentinel) {</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">"err2 is ErrSentinel"</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  }</span><br><span class="line">  <span class="built_in">println</span>(<span class="string">"err2 is not ErrSentinel"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>输出：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">false</span><br><span class="line">err2 is ErrSentinel</span><br></pre></td></tr></tbody></table></figure>
<p>我们看到，通过比较操作符对 err2 与 ErrSentinel 进行比较后，我们发现这二者并不相同。而 errors.Is 函数则会沿着 err2 所在错误链，向下找到被包装到最底层的“哨兵”错误值ErrSentinel。</p>
<p><strong>策略三：错误值类型检视策略</strong></p>
<p>上面我们看到，基于 Go 标准库提供的错误值构造方法构造的“哨兵”错误值，除了让错误处理方可以“有的放矢”的进行值比较之外，并没有提供其他有效的错误上下文信息。</p>
<p>由于错误值都通过 error 接口变量统一呈现，要得到底层错误类型携带的错误上下文信息，错误处理方需要使用 Go 提供的<strong>类型断言机制</strong>（Type Assertion）或<strong>类型选择机制</strong>（Type Switch），这种错误处理方式，我称之为<strong>错误值类型检视策略</strong>。</p>
<p>如：</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// $GOROOT/src/encoding/json/decode.go</span></span><br><span class="line"><span class="keyword">type</span> UnmarshalTypeError <span class="keyword">struct</span> {</span><br><span class="line">    Value  <span class="type">string</span>       </span><br><span class="line">    Type   reflect.Type </span><br><span class="line">    Offset <span class="type">int64</span>        </span><br><span class="line">    Struct <span class="type">string</span>       </span><br><span class="line">    Field  <span class="type">string</span>      </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>错误处理方可以通过错误类型检视策略，获得更多错误值的错误上下文信息，下面就是利用这一策略的 json 包的一个方法的实现：</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// $GOROOT/src/encoding/json/decode.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *decodeState)</span></span> addErrorContext(err <span class="type">error</span>) <span class="type">error</span> {</span><br><span class="line">    <span class="keyword">if</span> d.errorContext.Struct != <span class="literal">nil</span> || <span class="built_in">len</span>(d.errorContext.FieldStack) &gt; <span class="number">0</span> {</span><br><span class="line">        <span class="keyword">switch</span> err := err.(<span class="keyword">type</span>) {</span><br><span class="line">        <span class="keyword">case</span> *UnmarshalTypeError:</span><br><span class="line">            err.Struct = d.errorContext.Struct.Name()</span><br><span class="line">            err.Field = strings.Join(d.errorContext.FieldStack, <span class="string">"."</span>)</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>这里，一般自定义导出的错误类型以XXXError的形式命名。和“哨兵”错误处理策略一样，错误值类型检视策略，由于暴露了自定义的错误类型给错误处理方，因此这些错误类型也和包的公共函数 / 方法一起，成为了 API 的一部分。一旦发布出去，开发者就要对它们进行很好的维护。而它们也让使用这些类型进行检视的错误处理方对其产生了依赖。</p>
<p>从 Go 1.13 版本开始，标准库 errors 包提供了As函数给错误处理方检视错误值。As函数类似于通过类型断言判断一个 error 类型变量是否为特定的自定义错误类型，如下面代码所示：</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类似 if e, ok := err.(*MyError); ok { … }</span></span><br><span class="line"><span class="keyword">var</span> e *MyError</span><br><span class="line"><span class="keyword">if</span> errors.As(err, &amp;e) {</span><br><span class="line">    <span class="comment">// 如果err类型为*MyError，变量e将被设置为对应的错误值</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>不同的是，如果 error 类型变量的动态错误值是一个包装错误，errors.As函数会沿着该包装错误所在错误链，与链上所有被包装的错误的类型进行比较，直至找到一个匹配的错误类型，就像 errors.Is 函数那样。下面是As函数应用的一个例子：</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyError <span class="keyword">struct</span> {</span><br><span class="line">    e <span class="type">string</span></span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *MyError)</span></span> Error() <span class="type">string</span> {</span><br><span class="line">    <span class="keyword">return</span> e.e</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">var</span> err = &amp;MyError{<span class="string">"MyError error demo"</span>}</span><br><span class="line">    err1 := fmt.Errorf(<span class="string">"wrap err: %w"</span>, err)</span><br><span class="line">    err2 := fmt.Errorf(<span class="string">"wrap err1: %w"</span>, err1)</span><br><span class="line">    <span class="keyword">var</span> e *MyError</span><br><span class="line">    <span class="keyword">if</span> errors.As(err2, &amp;e) {</span><br><span class="line">        <span class="built_in">println</span>(<span class="string">"MyError is on the chain of err2"</span>)</span><br><span class="line">        <span class="built_in">println</span>(e == err)                  </span><br><span class="line">        <span class="keyword">return</span>                             </span><br><span class="line">    }                                      </span><br><span class="line">    <span class="built_in">println</span>(<span class="string">"MyError is not on the chain of err2"</span>)</span><br><span class="line">} </span><br></pre></td></tr></tbody></table></figure>
<p>输出：</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MyError is on the chain of err2</span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></tbody></table></figure>
<p><strong>策略四：错误行为特征检视策略</strong></p>
<p>第一种策略，也就是“透明错误处理策略”，有效降低了错误的构造方与错误处理方两者之间的耦合。虽然前面的策略二和策略三，都是我们实际编码中有效的错误处理策略，但其实使用这两种策略的代码，依然在错误的构造方与错误处理方两者之间建立了耦合。</p>
<p>在 Go 标准库中，我们发现了这样一种错误处理方式：<strong>将某个包中的错误类型归类，统一提取出一些公共的错误行为特征，并将这些错误行为特征放入一个公开的接口类型中</strong>。这种方式也被叫做错误行为特征检视策略。</p>
<p>如：</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// $GOROOT/src/net/net.go</span></span><br><span class="line"><span class="keyword">type</span> Error <span class="keyword">interface</span> {</span><br><span class="line">    <span class="type">error</span></span><br><span class="line">    Timeout() <span class="type">bool</span>  </span><br><span class="line">    Temporary() <span class="type">bool</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>我们看到，net.Error 接口包含两个用于判断错误行为特征的方法：Timeout 用来判断是否是超时（Timeout）错误，Temporary 用于判断是否是临时（Temporary）错误。</p>
<p>而错误处理方只需要依赖这个公共接口，就可以检视具体错误值的错误行为特征信息，并根据这些信息做出后续错误处理分支选择的决策。</p>
<p>这里，我们再看一个 http 包使用错误行为特征检视策略进行错误处理的例子，加深下理解：</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// $GOROOT/src/net/http/server.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(srv *Server)</span></span> Serve(l net.Listener) <span class="type">error</span> {</span><br><span class="line">    ... ...</span><br><span class="line">    <span class="keyword">for</span> {</span><br><span class="line">        rw, e := l.Accept()</span><br><span class="line">        <span class="keyword">if</span> e != <span class="literal">nil</span> {</span><br><span class="line">            <span class="keyword">select</span> {</span><br><span class="line">            <span class="keyword">case</span> &lt;-srv.getDoneChan():</span><br><span class="line">                <span class="keyword">return</span> ErrServerClosed</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> ne, ok := e.(net.Error); ok &amp;&amp; ne.Temporary() {</span><br><span class="line">                <span class="comment">// 注：这里对临时性(temporary)错误进行处理</span></span><br><span class="line">                ... ...</span><br><span class="line">                time.Sleep(tempDelay)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> e</span><br><span class="line">        }</span><br><span class="line">        ...</span><br><span class="line">    }</span><br><span class="line">    ... ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>在上面代码中，Accept 方法实际上返回的错误类型为*OpError，它是 net 包中的一个自定义错误类型，它实现了错误公共特征接口net.Error，如下代码所示：</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// $GOROOT/src/net/net.go</span></span><br><span class="line"><span class="keyword">type</span> OpError <span class="keyword">struct</span> {</span><br><span class="line">    ... ...</span><br><span class="line">    <span class="comment">// Err is the error that occurred during the operation.</span></span><br><span class="line">    Err <span class="type">error</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">type</span> temporary <span class="keyword">interface</span> {</span><br><span class="line">    Temporary() <span class="type">bool</span></span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *OpError)</span></span> Temporary() <span class="type">bool</span> {</span><br><span class="line">  <span class="keyword">if</span> ne, ok := e.Err.(*os.SyscallError); ok {</span><br><span class="line">      t, ok := ne.Err.(temporary)</span><br><span class="line">      <span class="keyword">return</span> ok &amp;&amp; t.Temporary()</span><br><span class="line">  }</span><br><span class="line">  t, ok := e.Err.(temporary)</span><br><span class="line">  <span class="keyword">return</span> ok &amp;&amp; t.Temporary()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="健壮简洁的函数"><a class="markdownIt-Anchor" href="#健壮简洁的函数"></a> 健壮简洁的函数</h2>
<p><strong>健壮性的“三不要”原则</strong></p>
<p><strong>原则一：不要相信任何外部输入的参数。</strong></p>
<p>为了保证函数的健壮性，函数需要对所有输入的参数进行合法性的检查。一旦发现问题，立即终止函数的执行，返回预设的错误值。</p>
<p><strong>原则二：不要忽略任何一个错误。</strong></p>
<p>调用标准库或第三方包提供的函数或方法时，我们不能假定它一定会成功，我们一定要显式地检查这些调用返回的错误值。一旦发现错误，要及时终止函数执行，防止错误继续传播。</p>
<p><strong>原则三：不要假定异常不会发生。</strong></p>
<p>通常意义上的异常，指的是硬件异常、操作系统异常、语言运行时异常，还有更大可能是代码中潜在 bug 导致的异常，比如代码中出现了以 0 作为分母，或者是数组越界访问等情况。</p>
<p><strong>Go 语言的异常：panic</strong></p>
<p>panic 指的是 Go 程序在运行时出现的一个异常情况。如果异常出现了，但没有被捕获并恢复，Go 程序的执行就会被终止，即便出现异常的位置不在主 Goroutine 中也会这样。</p>
<p>panic 主要有两类来源，一类是来自 <strong>Go 运行时</strong>，另一类则是 <strong>Go 开发人员通过 panic 函数主动触发的</strong>。无论是哪种，一旦 panic 被触发，后续 Go 程序的执行过程都是一样的，这个过程被 Go 语言称为 <strong>panicking</strong>。</p>
<p>以手工调用 panic 函数触发 panic 为例，对 panicking 这个过程进行了诠释：当函数 F 调用 panic 函数时，函数 F 的执行将停止。不过，函数 F 中已进行求值的 deferred 函数都会得到正常执行，执行完这些 deferred 函数后，函数 F 才会把控制权返还给其调用者。</p>
<p>对于函数 F 的调用者而言，函数 F 之后的行为就如同调用者调用的函数是 panic 一样，该panicking过程将继续在栈上进行下去，直到当前 Goroutine 中的所有函数都返回为止，然后 Go 程序将崩溃退出。</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">"call foo"</span>)</span><br><span class="line">    bar()</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">"exit foo"</span>)</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bar</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">"call bar"</span>)</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">"panic occurs in bar"</span>)</span><br><span class="line">    zoo()</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">"exit bar"</span>)</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">zoo</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">"call zoo"</span>)</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">"exit zoo"</span>)</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">"call main"</span>)</span><br><span class="line">    foo()</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">"exit main"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>输出为：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">call main</span><br><span class="line">call foo</span><br><span class="line">call bar</span><br><span class="line">panic: panic occurs in bar</span><br></pre></td></tr></tbody></table></figure>
<p>Go 也提供了捕捉 panic 并恢复程序正常执行秩序的方法，我们可以通过 <strong>recover 函数</strong> 来实现这一点。</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bar</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">        <span class="keyword">if</span> e := <span class="built_in">recover</span>(); e != <span class="literal">nil</span> {</span><br><span class="line">            fmt.Println(<span class="string">"recover the panic:"</span>, e)</span><br><span class="line">        }</span><br><span class="line">    }()</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">"call bar"</span>)</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">"panic occurs in bar"</span>)</span><br><span class="line">    zoo()</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">"exit bar"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>recover 是 Go 内置的专门用于恢复 panic 的函数，它必须被放在一个 defer 函数中才能生效。如果 recover 捕捉到 panic，它就会返回以 panic 的具体内容为错误上下文信息的错误值。如果没有 panic 发生，那么 recover 将返回 nil。而且，如果 panic 被 recover 捕捉到，panic 引发的 panicking 过程就会停止。</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">call main</span><br><span class="line">call foo</span><br><span class="line">call bar</span><br><span class="line">recover the panic: panic occurs in bar</span><br><span class="line">exit foo</span><br><span class="line">exit main</span><br></pre></td></tr></tbody></table></figure>
<p><strong>如何应对 panic？</strong></p>
<p>其实大可不必。</p>
<p>*<strong>第一点：评估程序对 panic 的忍受度</strong></p>
<p>首先，我们应该知道一个事实：<strong>不同应用对异常引起的程序崩溃退出的忍受度是不一样的</strong>。</p>
<p><strong>第二点：提示潜在 bug</strong></p>
<p>C 语言中有个很好用的辅助函数，断言（assert 宏）。在使用 C 编写代码时，我们经常在一些代码执行路径上，使用断言来表达这段执行路径上某种条件一定为真的信心。</p>
<p>不过，Go 语言标准库中并没有提供断言之类的辅助函数，但我们可以使用 panic，部分模拟断言对潜在 bug 的提示功能。比如，下面就是标准库encoding/json包使用 panic 指示潜在 bug 的一个例子：</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// $GOROOT/src/encoding/json/decode.go</span></span><br><span class="line">... ...</span><br><span class="line"><span class="comment">//当一些本不该发生的事情导致我们结束处理时，phasePanicMsg将被用作panic消息</span></span><br><span class="line"><span class="comment">//它可以指示JSON解码器中的bug，或者</span></span><br><span class="line"><span class="comment">//在解码器执行时还有其他代码正在修改数据切片。</span></span><br><span class="line"><span class="keyword">const</span> phasePanicMsg = <span class="string">"JSON decoder out of sync - data changing underfoot?"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *decodeState)</span></span> init(data []<span class="type">byte</span>) *decodeState {</span><br><span class="line">    d.data = data</span><br><span class="line">    d.off = <span class="number">0</span></span><br><span class="line">    d.savedError = <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">if</span> d.errorContext != <span class="literal">nil</span> {</span><br><span class="line">        d.errorContext.Struct = <span class="literal">nil</span></span><br><span class="line">        <span class="comment">// Reuse the allocated space for the FieldStack slice.</span></span><br><span class="line">        d.errorContext.FieldStack = d.errorContext.FieldStack[:<span class="number">0</span>]</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> d</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *decodeState)</span></span> valueQuoted() <span class="keyword">interface</span>{} {</span><br><span class="line">    <span class="keyword">switch</span> d.opcode {</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">panic</span>(phasePanicMsg)</span><br><span class="line">    <span class="keyword">case</span> scanBeginArray, scanBeginObject:</span><br><span class="line">        d.skip()</span><br><span class="line">        d.scanNext()</span><br><span class="line">    <span class="keyword">case</span> scanBeginLiteral:</span><br><span class="line">        v := d.literalInterface()</span><br><span class="line">        <span class="keyword">switch</span> v.(<span class="keyword">type</span>) {</span><br><span class="line">        <span class="keyword">case</span> <span class="literal">nil</span>, <span class="type">string</span>:</span><br><span class="line">            <span class="keyword">return</span> v</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> unquotedValue{}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>在 Go 标准库中，<strong>大多数 panic 的使用都是充当类似断言的作用的</strong>。</p>
<p><strong>第三点：不要混淆异常与错误</strong></p>
<p><strong>使用 defer 简化函数实现</strong></p>
<p><strong>Go 中是否有现成的语法元素，可以帮助我们简化 Go 函数的设计和实现</strong>。我也把答案剧透给你，有的，它就是 <strong>defer</strong>。</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doSomething</span><span class="params">()</span></span> <span class="type">error</span> {</span><br><span class="line">    <span class="keyword">var</span> mu sync.Mutex</span><br><span class="line">    mu.Lock()</span><br><span class="line">    r1, err := OpenResource1()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">        mu.Unlock()</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    }</span><br><span class="line">    r2, err := OpenResource2()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">        r1.Close()</span><br><span class="line">        mu.Unlock()</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    }</span><br><span class="line">    r3, err := OpenResource3()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">        r2.Close()</span><br><span class="line">        r1.Close()</span><br><span class="line">        mu.Unlock()</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 使用r1，r2, r3</span></span><br><span class="line">    err = doWithResources() </span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">        r3.Close()</span><br><span class="line">        r2.Close()</span><br><span class="line">        r1.Close()</span><br><span class="line">        mu.Unlock()</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    }</span><br><span class="line">    r3.Close()</span><br><span class="line">    r2.Close()</span><br><span class="line">    r1.Close()</span><br><span class="line">    mu.Unlock()</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>函数的实现需要确保，无论函数的执行流是按预期顺利进行，还是出现错误，这些资源在函数退出时都要被及时、正确地释放。为此，我们需要尤为关注函数中的错误处理，在错误处理时不能遗漏对资源的释放。</p>
<p><strong>Go 语言引入 defer 的初衷，就是解决这些问题。</strong></p>
<p>defer 是 Go 语言提供的一种延迟调用机制，defer 的运作离不开函数。</p>
<ul>
<li>在 Go 中，只有在函数（和方法）内部才能使用 defer；</li>
<li>defer 关键字后面只能接函数（或方法），这些函数被称为 <strong>deferred 函数</strong>。defer 将它们注册到其所在 Goroutine 中，用于存放 deferred 函数的栈数据结构中，这些 deferred 函数将在执行 defer 的函数退出前，按后进先出（LIFO）的顺序被程序调度执行（如下图所示）。</li>
</ul>
<p><img src="/img/go%E5%AD%A6%E4%B9%A0/image-20250515214246610.png" alt="image-20250515214246610"></p>
<p>deferred 函数是一个可以在任何情况下为函数进行<strong>收尾工作</strong>的好“伙伴”。</p>
<p><strong>defer 的注意事项</strong></p>
<p><strong>第一点：明确哪些函数可以作为 deferred 函数</strong></p>
<p>对于有返回值的自定义函数或方法，返回值会在 deferred 函数被调度执行的时候被自动丢弃。</p>
<p>Go 语言中除了自定义函数 / 方法，还有 Go 语言内置的 / 预定义的函数，这里我给出了 Go 语言内置函数的完全列表：</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Functions:</span><br><span class="line">  <span class="built_in">append</span> <span class="built_in">cap</span> <span class="built_in">close</span> <span class="built_in">complex</span> <span class="built_in">copy</span> <span class="built_in">delete</span> <span class="built_in">imag</span> <span class="built_in">len</span></span><br><span class="line">  <span class="built_in">make</span> <span class="built_in">new</span> <span class="built_in">panic</span> <span class="built_in">print</span> <span class="built_in">println</span> <span class="built_in">real</span> <span class="built_in">recover</span></span><br></pre></td></tr></tbody></table></figure>
<p>不过，对于那些不能直接作为 deferred 函数的内置函数，我们可以使用一个包裹它的匿名函数来间接满足要求，以 append 为例是这样的：</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">  _ = <span class="built_in">append</span>(sl, <span class="number">11</span>)</span><br><span class="line">}()</span><br></pre></td></tr></tbody></table></figure>
<p><strong>第二点：注意 defer 关键字后面表达式的求值时机</strong></p>
<p><strong>defer 关键字后面的表达式，是在将 deferred 函数注册到 deferred 函数栈的时候进行求值的。而不是在执行的时候求值的。</strong></p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo1</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= <span class="number">3</span>; i++ {</span><br><span class="line">        <span class="keyword">defer</span> fmt.Println(i)</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo2</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= <span class="number">3</span>; i++ {</span><br><span class="line">        <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">(n <span class="type">int</span>)</span></span> {</span><br><span class="line">            fmt.Println(n)</span><br><span class="line">        }(i)</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo3</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= <span class="number">3</span>; i++ {</span><br><span class="line">        <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">            fmt.Println(i)</span><br><span class="line">        }()</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    fmt.Println(<span class="string">"foo1 result:"</span>)</span><br><span class="line">    foo1()</span><br><span class="line">    fmt.Println(<span class="string">"\nfoo2 result:"</span>)</span><br><span class="line">    foo2()</span><br><span class="line">    fmt.Println(<span class="string">"\nfoo3 result:"</span>)</span><br><span class="line">    foo3()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>输出：</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">foo1 result:</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line">foo2 result:</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line">foo3 result:</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></tbody></table></figure>
<p>无论以何种形式将函数注册到 defer 中，deferred 函数的参数值都是在注册的时候进行求值的。只是要注意，defer中访问的直接访问，而不是传递的值。</p>
<p><strong>第三点：知晓 defer 带来的性能损耗</strong></p>
<h2 id="理解方法的本质"><a class="markdownIt-Anchor" href="#理解方法的本质"></a> 理解“方法”的本质</h2>
<p>Go 语言从设计伊始，就不支持经典的面向对象语法元素，比如类、对象、继承，等等，但 Go 语言仍保留了名为“方法（method）”的语法元素。method 是Go 践行组合设计哲学的一种实现层面的需要。这个我们后面课程会展开细讲，这里你先了解一下就可以了。</p>
<p><img src="/img/go%E5%AD%A6%E4%B9%A0/image-20250515215703976.png" alt="image-20250515215703976"></p>
<p>Go 中方法的声明和函数的声明有很多相似之处，我们可以参照着来学习。比如，Go 的方法也是以 func 关键字修饰的，并且和函数一样，也包含方法名（对应函数名）、参数列表、返回值列表与方法体（对应函数体）。</p>
<p>Go 方法的声明有<strong>六个组成部分</strong>，多的一个就是图中的 receiver 部分。在 receiver 部分声明的参数，Go 称之为 receiver 参数，<strong>这个 receiver 参数也是方法与类型之间的纽带，也是方法与函数的最大不同。</strong></p>
<p>Go 中的<strong>方法必须是归属于一个类型的</strong>，而<strong>receiver 参数的类型就是这个方法归属的类型</strong>，或者说这个方法就是这个类型的一个方法。</p>
<p>比如上面例子，<code>ListenAndServerTLS</code>是 <code>*Server</code> 类型的方法，但不是<code>Server</code>类型的方法。<strong>不过猜也知道，指针相当于引用传递，否则为值传递。</strong></p>
<p>Go语言不支持重载。</p>
<p>（感觉有点像方法在类外面实现）</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *T或T)</span></span> MethodName(参数列表) (返回值列表) {</span><br><span class="line">    <span class="comment">// 方法体</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong>方法接收器（receiver）参数、函数 / 方法参数，以及返回值变量对应的作用域范围，都是函数 / 方法体对应的显式代码块</strong>。</p>
<p>receiver 部分的参数名不能与方法参数列表中的形参名，以及具名返回值中的变量名存在冲突，必须在这个方法的作用域中具有唯一性。</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span>{}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t T)</span></span> M(t <span class="type">string</span>) { <span class="comment">// 编译器报错：duplicate argument t (重复声明参数t)</span></span><br><span class="line">    ... ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>除了 receiver 参数名字要保证唯一外，Go 语言对 receiver 参数的基类型也有约束，那就是 <strong>receiver 参数的基类型本身不能为指针类型或接口类型</strong>。</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyInt *<span class="type">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r MyInt)</span></span> String() <span class="type">string</span> { <span class="comment">// r的基类型为MyInt，编译器报错：invalid receiver type MyInt (MyInt is a pointer type)</span></span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(<span class="string">"%d"</span>, *(*<span class="type">int</span>)(r))</span><br><span class="line">}</span><br><span class="line"><span class="keyword">type</span> MyReader io.Reader</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r MyReader)</span></span> Read(p []<span class="type">byte</span>) (<span class="type">int</span>, <span class="type">error</span>) { <span class="comment">// r的基类型为MyReader，编译器报错：invalid receiver type MyReader (MyReader is an interface type)</span></span><br><span class="line">    <span class="keyword">return</span> r.Read(p)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>Go 要求，<strong>方法声明要与 receiver 参数的基类型声明放在同一个包内</strong>。</p>
<p><strong>我们不能为原生类型（诸如 int、float64、map 等）添加方法</strong>。</p>
<p><strong>不能跨越 Go 包为其他包的类型声明新方法</strong>。</p>
<p><strong>方法的本质是什么？</strong></p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> { </span><br><span class="line">    a <span class="type">int</span></span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t T)</span></span> Get() <span class="type">int</span> {  </span><br><span class="line">    <span class="keyword">return</span> t.a </span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *T)</span></span> Set(a <span class="type">int</span>) <span class="type">int</span> { </span><br><span class="line">    t.a = a </span><br><span class="line">    <span class="keyword">return</span> t.a </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> t T</span><br><span class="line">t.Get()</span><br><span class="line">(&amp;t).Set(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价于：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> t T</span><br><span class="line">T.Get(t)</span><br><span class="line">(*T).Set(&amp;t, <span class="number">1</span>)</span><br></pre></td></tr></tbody></table></figure>
<p>这种直接以类型名 T 调用方法的表达方式，被称为 <strong>Method Expression</strong>。通过 Method Expression 这种形式，类型 T 只能调用 T 的方法集合（Method Set）中的方法，同理类型 *T 也只能调用 *T 的方法集合中的方法。</p>
<p><strong>Method Expression</strong> 有些类似于 C++ 中的静态方法（Static Method），C++ 中的静态方法在使用时，以该 C++ 类的某个对象实例作为第一个参数，而 Go 语言的 Method Expression 在使用时，同样以 receiver 参数所代表的类型实例作为第一个参数。</p>
<p><strong>Go 语言中的方法的本质就是，一个以方法的 receiver 参数作为第一个参数的普通函数</strong>。</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">var</span> t T</span><br><span class="line">    f1 := (*T).Set <span class="comment">// f1的类型，也是*T类型Set方法的类型：func (t *T, int)int</span></span><br><span class="line">    f2 := T.Get    <span class="comment">// f2的类型，也是T类型Get方法的类型：func(t T)int</span></span><br><span class="line">    fmt.Printf(<span class="string">"the type of f1 is %T\n"</span>, f1) <span class="comment">// the type of f1 is func(*main.T, int) int</span></span><br><span class="line">    fmt.Printf(<span class="string">"the type of f2 is %T\n"</span>, f2) <span class="comment">// the type of f2 is func(main.T) int</span></span><br><span class="line">    f1(&amp;t, <span class="number">3</span>)</span><br><span class="line">    fmt.Println(f2(t)) <span class="comment">// 3</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>给出一个例子：</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">type</span> field <span class="keyword">struct</span> {</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *field)</span></span> <span class="built_in">print</span>() {</span><br><span class="line">    fmt.Println(p.name)</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    data1 := []*field{{<span class="string">"one"</span>}, {<span class="string">"two"</span>}, {<span class="string">"three"</span>}}</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> data1 {</span><br><span class="line">        <span class="keyword">go</span> v.<span class="built_in">print</span>()</span><br><span class="line">    }</span><br><span class="line">    data2 := []field{{<span class="string">"four"</span>}, {<span class="string">"five"</span>}, {<span class="string">"six"</span>}}</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> data2 {</span><br><span class="line">        <span class="keyword">go</span> v.<span class="built_in">print</span>()</span><br><span class="line">    }</span><br><span class="line">    time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>在Go 1.22之前可能输出：</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">one</span><br><span class="line">two</span><br><span class="line">three</span><br><span class="line">six</span><br><span class="line">six</span><br><span class="line">six</span><br></pre></td></tr></tbody></table></figure>
<p>在Go 1.22以及之后可能输出：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">one</span><br><span class="line">two</span><br><span class="line">three</span><br><span class="line">four</span><br><span class="line">five</span><br><span class="line">six</span><br></pre></td></tr></tbody></table></figure>
<p>因为标准的改变：<a target="_blank" rel="noopener" href="https://go.dev/blog/loopvar-preview">loopvar-preview</a></p>
<h2 id="方法集合以及-receive-类型"><a class="markdownIt-Anchor" href="#方法集合以及-receive-类型"></a> 方法集合以及 receive 类型</h2>
<p><strong>receiver 参数类型对 Go 方法的影响</strong></p>
<p>说白了不就是引用传递和值拷贝的区别呗。</p>
<p><strong>选择 receiver 参数类型的第一个原则</strong></p>
<p><strong>如果 Go 方法要把对 receiver 参数代表的类型实例的修改，反映到原类型实例上，那么我们应该选择 *T 作为 receiver 参数的类型</strong>。</p>
<p><strong>无论是 T 类型实例，还是 *T 类型实例，都既可以调用 receiver 为 T 类型的方法，也可以调用 receiver 为 *T 类型的方法</strong>。</p>
<p><strong>选择 receiver 参数类型的第二个原则</strong></p>
<p><strong>如果 receiver 参数类型的 size 较大</strong>，以值拷贝形式传入就会导致较大的性能开销，这时我们选择 *T 作为 receiver 类型可能更好些。</p>
<p><strong>方法集合</strong></p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Interface <span class="keyword">interface</span> {</span><br><span class="line">    M1()</span><br><span class="line">    M2()</span><br><span class="line">}</span><br><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span>{}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t T)</span></span> M1()  {}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *T)</span></span> M2() {}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">var</span> t T</span><br><span class="line">    <span class="keyword">var</span> pt *T</span><br><span class="line">    <span class="keyword">var</span> i Interface</span><br><span class="line">    i = pt</span><br><span class="line">    i = t <span class="comment">// cannot use t (type T) as type Interface in assignment: T does not implement Interface (M2 method has pointer receiver)</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong>T 没有实现 Interface 类型方法列表中的 M2，因此类型 T 的实例 t 不能赋值给 Interface 变量</strong>。</p>
<p>同时，<strong>方法集合也是用来判断一个类型是否实现了某接口类型的唯一手段</strong>，可以说，“<strong>方法集合决定了接口实现</strong>”。</p>
<p><strong>选择 receiver 参数类型的第三个原则</strong></p>
<p>这个原则的选择依据就是 <strong>T 类型是否需要实现某个接口</strong>，也就是是否存在将 T 类型的变量赋值给某接口类型变量的情况。</p>
<p><strong>T 类型需要实现某个接口</strong>，那我们就要使用 T 作为 receiver 参数的类型，来满足接口类型方法集合中的所有方法。</p>
<h2 id="方法用类型嵌入模拟继承"><a class="markdownIt-Anchor" href="#方法用类型嵌入模拟继承"></a> 方法：用类型嵌入模拟“继承”？</h2>
<p>**难道还有某种自定义类型的方法不是自己显式实现的吗？**当然有！这就是我们这讲中要重点讲解的内容：<strong>如何让某个自定义类型“继承”其他类型的方法实现</strong>。</p>
<p><strong>老师，你不是说过 Go 不支持经典的面向对象编程范式吗？怎么还会有继承这一说法呢</strong>？没错！Go 语言从设计伊始，就决定不支持经典面向对象的编程范式与语法元素，所以我们这里只是借用了“继承”这个词汇而已，说是“继承”，实则依旧是一种<strong>组合</strong>的思想。</p>
<p>继承”，我们是通过 Go 语言的**类型嵌入（Type Embedding）**来实现的。</p>
<p><strong>接口类型的类型嵌入</strong></p>
<p><strong>接口类型声明了由一个方法集合代表的接口</strong></p>
<p><strong>接口类型 E 替代上面接口类型 I 定义中 M1 和 M2</strong></p>
<p><strong>接口类型嵌入的语义就是新接口类型（如接口类型 I）将嵌入的接口类型（如接口类型 E）的方法集合，并入到自己的方法集合中</strong>。</p>
<p><strong>Go 语言中基于已有接口类型构建新接口类型的惯用法</strong>。</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// $GOROOT/src/io/io.go</span></span><br><span class="line"><span class="keyword">type</span> Reader <span class="keyword">interface</span> {</span><br><span class="line">    Read(p []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>)</span><br><span class="line">}</span><br><span class="line"><span class="keyword">type</span> Writer <span class="keyword">interface</span> {</span><br><span class="line">    Write(p []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>)</span><br><span class="line">}</span><br><span class="line"><span class="keyword">type</span> Closer <span class="keyword">interface</span> {</span><br><span class="line">    Close() <span class="type">error</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ReadWriter <span class="keyword">interface</span> {</span><br><span class="line">    Reader</span><br><span class="line">    Writer</span><br><span class="line">}</span><br><span class="line"><span class="keyword">type</span> ReadCloser <span class="keyword">interface</span> {</span><br><span class="line">    Reader</span><br><span class="line">    Closer</span><br><span class="line">}</span><br><span class="line"><span class="keyword">type</span> WriteCloser <span class="keyword">interface</span> {</span><br><span class="line">    Writer</span><br><span class="line">    Closer</span><br><span class="line">}</span><br><span class="line"><span class="keyword">type</span> ReadWriteCloser <span class="keyword">interface</span> {</span><br><span class="line">    Reader</span><br><span class="line">    Writer</span><br><span class="line">    Closer</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Interface1 <span class="keyword">interface</span> {</span><br><span class="line">    M1()</span><br><span class="line">}</span><br><span class="line"><span class="keyword">type</span> Interface2 <span class="keyword">interface</span> {</span><br><span class="line">    M1()</span><br><span class="line">    M2()</span><br><span class="line">}</span><br><span class="line"><span class="keyword">type</span> Interface3 <span class="keyword">interface</span> {</span><br><span class="line">    Interface1</span><br><span class="line">    Interface2 <span class="comment">// Error: duplicate method M1</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">type</span> Interface4 <span class="keyword">interface</span> {</span><br><span class="line">    Interface2</span><br><span class="line">    M2() <span class="comment">// Error: duplicate method M2</span></span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong>结构体类型的类型嵌入</strong></p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> S <span class="keyword">struct</span> {</span><br><span class="line">    A <span class="type">int</span></span><br><span class="line">    b <span class="type">string</span></span><br><span class="line">    c T</span><br><span class="line">    p *P</span><br><span class="line">    _ [<span class="number">10</span>]<span class="type">int8</span></span><br><span class="line">    F <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong>带有嵌入字段（Embedded Field）的结构体定义</strong>。</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> T1 <span class="type">int</span></span><br><span class="line"><span class="keyword">type</span> t2 <span class="keyword">struct</span>{</span><br><span class="line">    n <span class="type">int</span></span><br><span class="line">    m <span class="type">int</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">type</span> I <span class="keyword">interface</span> {</span><br><span class="line">    M1()</span><br><span class="line">}</span><br><span class="line"><span class="keyword">type</span> S1 <span class="keyword">struct</span> {</span><br><span class="line">    T1</span><br><span class="line">    *t2</span><br><span class="line">    I            </span><br><span class="line">    a <span class="type">int</span></span><br><span class="line">    b <span class="type">string</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>结构体字段的方式就叫做<strong>结构体的类型嵌入</strong>，这些字段也被叫做<strong>嵌入字段（Embedded Field）</strong>。</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyInt <span class="type">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *MyInt)</span></span> Add(m <span class="type">int</span>) {</span><br><span class="line">    *n = *n + MyInt(m)</span><br><span class="line">}</span><br><span class="line"><span class="keyword">type</span> t <span class="keyword">struct</span> {</span><br><span class="line">    a <span class="type">int</span></span><br><span class="line">    b <span class="type">int</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">type</span> S <span class="keyword">struct</span> {</span><br><span class="line">    *MyInt</span><br><span class="line">    t</span><br><span class="line">    io.Reader</span><br><span class="line">    s <span class="type">string</span></span><br><span class="line">    n <span class="type">int</span></span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    m := MyInt(<span class="number">17</span>)</span><br><span class="line">    r := strings.NewReader(<span class="string">"hello, go"</span>)</span><br><span class="line">    s := S{</span><br><span class="line">        MyInt: &amp;m,</span><br><span class="line">        t: t{</span><br><span class="line">            a: <span class="number">1</span>,</span><br><span class="line">            b: <span class="number">2</span>,</span><br><span class="line">        },</span><br><span class="line">        Reader: r,</span><br><span class="line">        s:      <span class="string">"demo"</span>,</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">var</span> sl = <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="built_in">len</span>(<span class="string">"hello, go"</span>))</span><br><span class="line">    s.Reader.Read(sl)</span><br><span class="line">    fmt.Println(<span class="type">string</span>(sl)) <span class="comment">// hello, go</span></span><br><span class="line">    s.MyInt.Add(<span class="number">5</span>)</span><br><span class="line">    fmt.Println(*(s.MyInt)) <span class="comment">// 22</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>Go 方法的 receiver 的基类型一样，嵌入字段类型的底层类型不能为指针类型。而且，嵌入字段的名字在结构体定义也必须是唯一的，这也意味这如果两个类型的名字相同，它们无法同时作为嵌入字段放到同一个结构体定义中。不过，这些约束你了解一下就可以了，一旦违反，Go 编译器会提示你的。</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sl = <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="built_in">len</span>(<span class="string">"hello, go"</span>))</span><br><span class="line">s.Read(sl) </span><br><span class="line">fmt.Println(<span class="type">string</span>(sl))</span><br><span class="line">s.Add(<span class="number">5</span>) </span><br><span class="line">fmt.Println(*(s.MyInt))</span><br></pre></td></tr></tbody></table></figure>
<p>上端代码可以正常运行。</p>
<p><strong>Read 方法与 Add 方法就是类型 S 方法集合中的方法</strong>。</p>
<p>这两个方法就来自结构体类型 S 的两个嵌入字段 Reader 和 MyInt。结构体类型 S“继承”了 Reader 字段的方法 Read 的实现，也“继承”了 *MyInt 的 Add 方法的实现。注意，我这里的“继承”用了引号，说明这并不是真正的继承，它只是 Go 语言的一种“障眼法”。</p>
<p>Go 发现结构体类型 S 自身并没有定义 Read 方法，于是 Go 会查看 S 的嵌入字段对应的类型是否定义了 Read 方法。这个时候，Reader 字段就被找了出来，之后 s.Read 的调用就被转换为 s.Reader.Read 调用。</p>
<p><img src="/img/go%E5%AD%A6%E4%B9%A0/image-20250516172428884.png" alt="image-20250516172428884"></p>
<p><strong>类型嵌入与方法集合</strong></p>
<p>接口类型只能嵌入接口类型。而结构体类型对嵌入类型的要求就比较宽泛了，可以是任意自定义类型或接口类型。</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> I <span class="keyword">interface</span> {</span><br><span class="line">    M1()</span><br><span class="line">    M2()</span><br><span class="line">}</span><br><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> {</span><br><span class="line">    I</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(T)</span></span> M3() {}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">var</span> t T</span><br><span class="line">    <span class="keyword">var</span> p *T</span><br><span class="line">    dumpMethodSet(t)</span><br><span class="line">    dumpMethodSet(p)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>需要无交集：</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> E1 <span class="keyword">interface</span> {</span><br><span class="line">      M1()</span><br><span class="line">      M2()</span><br><span class="line">      M3()</span><br><span class="line">  }</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">type</span> E2 <span class="keyword">interface</span> {</span><br><span class="line">     M1()</span><br><span class="line">     M2()</span><br><span class="line">     M4()</span><br><span class="line"> }</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">type</span> T <span class="keyword">struct</span> {</span><br><span class="line">     E1</span><br><span class="line">     E2</span><br><span class="line"> }</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">     t := T{}</span><br><span class="line">     t.M1()</span><br><span class="line">     t.M2()</span><br><span class="line"> }</span><br></pre></td></tr></tbody></table></figure>
<p><strong>defined 类型与 alias 类型的方法集合</strong></p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> I <span class="keyword">interface</span> {</span><br><span class="line">    M1()</span><br><span class="line">    M2()</span><br><span class="line">}</span><br><span class="line"><span class="keyword">type</span> T <span class="type">int</span></span><br><span class="line"><span class="keyword">type</span> NT T <span class="comment">// 基于已存在的类型T创建新的defined类型NT</span></span><br><span class="line"><span class="keyword">type</span> NI I <span class="comment">// 基于已存在的接口类型I创建新defined接口类型NI</span></span><br></pre></td></tr></tbody></table></figure>
<p>新定义的 defined 类型与原 defined 类型是不同的类型，那么它们的方法集合上又会有什么关系呢？新类型是否“继承”原 defined 类型的方法集合呢？对于那些基于接口类型创建的 defined 的接口类型，它们的方法集合与原接口类型的方法集合是一致的。</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span>{}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(T)</span></span> M1()  {}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*T)</span></span> M2() {}</span><br><span class="line"><span class="keyword">type</span> T1 T</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">  <span class="keyword">var</span> t T</span><br><span class="line">  <span class="keyword">var</span> pt *T</span><br><span class="line">  <span class="keyword">var</span> t1 T1</span><br><span class="line">  <span class="keyword">var</span> pt1 *T1</span><br><span class="line">  dumpMethodSet(t)</span><br><span class="line">  dumpMethodSet(t1)</span><br><span class="line">  dumpMethodSet(pt)</span><br><span class="line">  dumpMethodSet(pt1)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>输出：</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">main.T<span class="string">'s method set:</span></span><br><span class="line"><span class="string">- M1</span></span><br><span class="line"><span class="string">main.T1'</span>s method set is empty!</span><br><span class="line">*main.T<span class="string">'s method set:</span></span><br><span class="line"><span class="string">- M1</span></span><br><span class="line"><span class="string">- M2</span></span><br><span class="line"><span class="string">*main.T1'</span>s method set is empty!</span><br></pre></td></tr></tbody></table></figure>
<p>T1 的定义方式由类型声明改成了类型别名</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span>{}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(T)</span></span> M1()  {}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*T)</span></span> M2() {}</span><br><span class="line"><span class="keyword">type</span> T1 = T</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">var</span> t T</span><br><span class="line">    <span class="keyword">var</span> pt *T</span><br><span class="line">    <span class="keyword">var</span> t1 T1</span><br><span class="line">    <span class="keyword">var</span> pt1 *T1</span><br><span class="line">    dumpMethodSet(t)</span><br><span class="line">    dumpMethodSet(t1)</span><br><span class="line">    dumpMethodSet(pt)</span><br><span class="line">    dumpMethodSet(pt1)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>输出：</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">main.T<span class="string">'s method set:</span></span><br><span class="line"><span class="string">- M1</span></span><br><span class="line"><span class="string">main.T'</span>s method set:</span><br><span class="line">- M1</span><br><span class="line">*main.T<span class="string">'s method set:</span></span><br><span class="line"><span class="string">- M1</span></span><br><span class="line"><span class="string">- M2</span></span><br><span class="line"><span class="string">*main.T'</span>s method set:</span><br><span class="line">- M1</span><br><span class="line">- M2</span><br></pre></td></tr></tbody></table></figure>
<p>无论原类型是接口类型还是非接口类型，类型别名都与原类型拥有完全相同的方法集合。</p>
<h1 id="接口"><a class="markdownIt-Anchor" href="#接口"></a> 接口</h1>
<h2 id="接口-2"><a class="markdownIt-Anchor" href="#接口-2"></a> 接口</h2>
<p><strong>接口类型是由 type 和 interface 关键字定义的一组方法集合</strong></p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyInterface <span class="keyword">interface</span> {</span><br><span class="line">    M1(<span class="type">int</span>) <span class="type">error</span></span><br><span class="line">    M2(io.Writer, ...<span class="type">string</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面两种等价：</span></span><br><span class="line"><span class="keyword">type</span> MyInterface <span class="keyword">interface</span> {</span><br><span class="line">    M1(a <span class="type">int</span>) <span class="type">error</span></span><br><span class="line">    M2(w io.Writer, strs ...<span class="type">string</span>)</span><br><span class="line">}</span><br><span class="line"><span class="keyword">type</span> MyInterface <span class="keyword">interface</span> {</span><br><span class="line">    M1(n <span class="type">int</span>) <span class="type">error</span></span><br><span class="line">    M2(w io.Writer, args ...<span class="type">string</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>我们可以看到，接口类型 MyInterface 所表示的接口的方法集合，包含两个方法 M1 和 M2。<strong>之所以称 M1 和 M2 为“方法”，更多是从这个接口的实现者的角度考虑的</strong>。</p>
<p>Go 语言要求接口类型声明中的<strong>方法必须是具名的</strong>，并且<strong>方法名字在这个接口类型的方法集合中是唯一的</strong>。</p>
<p><strong>在 Go 接口类型的方法集合中放入首字母小写的非导出方法也是合法的</strong></p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// $GOROOT/src/context.go</span></span><br><span class="line"><span class="comment">// A canceler is a context type that can be canceled directly. The</span></span><br><span class="line"><span class="comment">// implementations are *cancelCtx and *timerCtx.</span></span><br><span class="line"><span class="keyword">type</span> canceler <span class="keyword">interface</span> {</span><br><span class="line">    cancel(removeFromParent <span class="type">bool</span>, err <span class="type">error</span>) <span class="comment">// 非导入</span></span><br><span class="line">    Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>{}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>如果一个接口类型定义中没有一个方法，那么它的方法集合就为空。如：</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> EmptyInterface <span class="keyword">interface</span> {</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>这个方法集合为空的接口类型就被称为<strong>空接口类型</strong>，但通常我们不需要自己显式定义这类空接口类型，我们直接使用<code>interface{}</code>这个类型字面值作为所有空接口类型的代表就可以了。</p>
<p>接口类型一旦被定义后，它就和其他 Go 类型一样可以用于声明变量。这些类型为接口类型的变量被称为<strong>接口类型变量</strong>，如果没有被显式赋予初值，接口类型变量的默认值为 nil。如果要为接口类型变量显式赋予初值，我们就要为接口类型变量选择合法的右值。</p>
<p>Go 规定：<strong>如果一个类型 T 的方法集合是某接口类型 I 的方法集合的等价集合或超集，我们就说类型 T 实现了接口类型 I，那么类型 T 的变量就可以作为合法的右值赋值给接口类型 I 的变量</strong>。</p>
<p>如果一个变量的类型是空接口类型，由于空接口类型的方法集合为空，这就意味着任何类型都实现了空接口的方法集合，所以我们可以将任何类型的值作为右值，赋值给空接口类型的变量，比如下面例子：</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i <span class="keyword">interface</span>{} = <span class="number">15</span> <span class="comment">// ok</span></span><br><span class="line">i = <span class="string">"hello, golang"</span> <span class="comment">// ok</span></span><br><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span>{}</span><br><span class="line"><span class="keyword">var</span> t T</span><br><span class="line">i = t  <span class="comment">// ok</span></span><br><span class="line">i = &amp;t <span class="comment">// ok</span></span><br></pre></td></tr></tbody></table></figure>
<p>Go 标准库在内的一些通用数据结构与算法的实现，都使用了空类型interface{}作为数据元素的类型，这样我们就无需为每种支持的元素类型单独做一份代码拷贝了。</p>
<p>Go 语言还支持接口类型变量赋值的“逆操作”，也就是通过接口类型变量“还原”它的右值的类型与值信息，这个过程被称为**“类型断言（Type Assertion）”**。类型断言通常使用下面的语法形式：</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v, ok := i.(T) </span><br></pre></td></tr></tbody></table></figure>
<p>其中 i 是某一个接口类型变量，如果 T 是一个非接口类型且 T 是想要还原的类型，那么这句代码的含义就是<strong>断言存储在接口类型变量 i 中的值的类型为 T</strong>。</p>
<p>类型断言也支持：</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v := i.(T)</span><br></pre></td></tr></tbody></table></figure>
<p>但如果 i 的类型不是 T 那么会抛出panic</p>
<p><strong>Go 语言接口定义的惯例，尽量定义“小接口”。</strong></p>
<p>接口类型的背后，是通过把类型的行为抽象成<strong>契约</strong>，建立双方共同遵守的约定，这种契约将双方的耦合降到了最低的程度。</p>
<p>Go 选择了<strong>去繁就简</strong>的形式，这主要体现在以下两点上：</p>
<ul>
<li>
<p><strong>隐式契约，无需签署，自动生效</strong></p>
<p>Go 语言中接口类型与它的实现者之间的关系是隐式的，不需要像其他语言（比如 Java）那样要求实现者显式放置“implements”进行修饰，实现者只需要实现接口方法集合中的全部方法便算是遵守了契约，并立即生效了。</p>
</li>
<li>
<p><strong>更倾向于“小契约”</strong></p>
<p>这点也不难理解。你想，如果契约太繁杂了就会束缚了手脚，缺少了灵活性，抑制了表现力。所以 Go 选择了使用“小契约”，表现在代码上就是<strong>尽量定义小接口，即方法个数在 1~3 个之间的接口</strong>。Go 语言之父 Rob Pike 曾说过的“接口越大，抽象程度越弱”，这也是 Go 社区倾向定义小接口的另外一种表述。</p>
</li>
</ul>
<h2 id="接口的动与静"><a class="markdownIt-Anchor" href="#接口的动与静"></a> 接口的动与静</h2>
<p><strong>接口是 Go 这门静态语言中唯一“动静兼备”的语法特性</strong>。</p>
<p><strong>接口的静态特性与动态特性</strong></p>
<p>接口的<strong>静态特性</strong>体现在<strong>接口类型变量具有静态类型</strong>，比如var err error中变量 err 的静态类型为 error。拥有静态类型，那就意味着编译器会在编译阶段对所有接口类型变量的赋值操作进行类型检查，编译器会检查右值的类型是否实现了该接口方法集合中的所有方法。如果不满足，就会报错：</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> err <span class="type">error</span> = <span class="number">1</span> <span class="comment">// cannot use 1 (type int) as type error in assignment: int does not implement error (missing Error method)</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>而接口的<strong>动态特性</strong>，就体现在接口类型变量在运行时还存储了右值的真实类型信息，这个右值的真实类型被称为接口类型变量的<strong>动态类型</strong>。你看一下下面示例代码：</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> err <span class="type">error</span></span><br><span class="line">err = errors.New(<span class="string">"error1"</span>)</span><br><span class="line">fmt.Printf(<span class="string">"%T\n"</span>, err)  <span class="comment">// *errors.errorString</span></span><br></pre></td></tr></tbody></table></figure>
<p>由接口实现多态，某种意义上也是纯虚类。</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> QuackableAnimal <span class="keyword">interface</span> {</span><br><span class="line">    Quack()</span><br><span class="line">}</span><br><span class="line"><span class="keyword">type</span> Duck <span class="keyword">struct</span>{}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(Duck)</span></span> Quack() {</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">"duck quack!"</span>)</span><br><span class="line">}</span><br><span class="line"><span class="keyword">type</span> Dog <span class="keyword">struct</span>{}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(Dog)</span></span> Quack() {</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">"dog quack!"</span>)</span><br><span class="line">}</span><br><span class="line"><span class="keyword">type</span> Bird <span class="keyword">struct</span>{}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(Bird)</span></span> Quack() {</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">"bird quack!"</span>)</span><br><span class="line">}                         </span><br><span class="line">                          </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AnimalQuackInForest</span><span class="params">(a QuackableAnimal)</span></span> {</span><br><span class="line">    a.Quack()             </span><br><span class="line">}                         </span><br><span class="line">                          </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {             </span><br><span class="line">    animals := []QuackableAnimal{<span class="built_in">new</span>(Duck), <span class="built_in">new</span>(Dog), <span class="built_in">new</span>(Bird)}</span><br><span class="line">    <span class="keyword">for</span> _, animal := <span class="keyword">range</span> animals {</span><br><span class="line">        AnimalQuackInForest(animal)</span><br><span class="line">    }  </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>接口类型的动静特性让我们看到了接口类型的强大，但在日常使用过程中，很多人都会产生各种困惑，其中最经典的一个困惑莫过于“nil 的 error 值不等于 nil”了。下面我们来详细看一下。</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyError <span class="keyword">struct</span> {</span><br><span class="line">    <span class="type">error</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">var</span> ErrBad = MyError{</span><br><span class="line">    <span class="type">error</span>: errors.New(<span class="string">"bad things happened"</span>),</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bad</span><span class="params">()</span></span> <span class="type">bool</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">returnsError</span><span class="params">()</span></span> <span class="type">error</span> {</span><br><span class="line">    <span class="keyword">var</span> p *MyError = <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">if</span> bad() {</span><br><span class="line">        p = &amp;ErrBad</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> p</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    err := returnsError()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">        fmt.Printf(<span class="string">"error occur: %+v\n"</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    }</span><br><span class="line">    fmt.Println(<span class="string">"ok"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>输出：<code>error occur: &lt;nil&gt;</code></p>
<p>原因是，<code>err error</code> 中 <code>error</code> 是一个接口类型，那么<code>err</code>变成了一个指向<code>*MyError nil</code>的<code>error</code>被初始化了，所以不是<code>nil</code>了。</p>
<p><strong>接口类型变量的内部表示</strong></p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// $GOROOT/src/runtime/runtime2.go</span></span><br><span class="line"><span class="keyword">type</span> iface <span class="keyword">struct</span> {</span><br><span class="line">    tab  *itab</span><br><span class="line">    data unsafe.Pointer</span><br><span class="line">}</span><br><span class="line"><span class="keyword">type</span> eface <span class="keyword">struct</span> {</span><br><span class="line">    _type *_type</span><br><span class="line">    data  unsafe.Pointer</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>
<p>eface 用于表示没有方法的空接口（<strong>e</strong>mpty inter<strong>face</strong>）类型变量，也就是 interface{}类型的变量；</p>
</li>
<li>
<p>iface 用于表示其余拥有方法的接口 <strong>i</strong>nter<strong>face</strong> 类型变量。</p>
</li>
</ul>
<p>这两个结构的共同点是它们都有两个指针字段，并且第二个指针字段的功能相同，都是指向当前赋值给该接口类型变量的动态类型变量的值。</p>
<p>那它们的不同点在哪呢？就在于 eface 表示的空接口类型并没有方法列表，因此它的第一个指针字段指向一个_type类型结构，这个结构为该接口类型变量的动态类型的信息，它的定义是这样的：</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// $GOROOT/src/runtime/type.go</span></span><br><span class="line"><span class="keyword">type</span> _type <span class="keyword">struct</span> {</span><br><span class="line">    size       <span class="type">uintptr</span></span><br><span class="line">    ptrdata    <span class="type">uintptr</span> <span class="comment">// size of memory prefix holding all pointers</span></span><br><span class="line">    hash       <span class="type">uint32</span></span><br><span class="line">    tflag      tflag</span><br><span class="line">    align      <span class="type">uint8</span></span><br><span class="line">    fieldAlign <span class="type">uint8</span></span><br><span class="line">    kind       <span class="type">uint8</span></span><br><span class="line">    <span class="comment">// function for comparing objects of this type</span></span><br><span class="line">    <span class="comment">// (ptr to object A, ptr to object B) -&gt; ==?</span></span><br><span class="line">    equal <span class="function"><span class="keyword">func</span><span class="params">(unsafe.Pointer, unsafe.Pointer)</span></span> <span class="type">bool</span></span><br><span class="line">    <span class="comment">// gcdata stores the GC type data for the garbage collector.</span></span><br><span class="line">    <span class="comment">// If the KindGCProg bit is set in kind, gcdata is a GC program.</span></span><br><span class="line">    <span class="comment">// Otherwise it is a ptrmask bitmap. See mbitmap.go for details.</span></span><br><span class="line">    gcdata    *<span class="type">byte</span></span><br><span class="line">    str       nameOff</span><br><span class="line">    ptrToThis typeOff</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>而 iface 除了要存储动态类型信息之外，还要存储接口本身的信息（接口的类型信息、方法列表信息等）以及动态类型所实现的方法的信息，因此 iface 的第一个字段指向一个itab类型结构。itab 结构的定义如下：</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// $GOROOT/src/runtime/runtime2.go</span></span><br><span class="line"><span class="keyword">type</span> itab <span class="keyword">struct</span> {</span><br><span class="line">    inter *interfacetype</span><br><span class="line">    _type *_type</span><br><span class="line">    hash  <span class="type">uint32</span> <span class="comment">// copy of _type.hash. Used for type switches.</span></span><br><span class="line">    _     [<span class="number">4</span>]<span class="type">byte</span></span><br><span class="line">    fun   [<span class="number">1</span>]<span class="type">uintptr</span> <span class="comment">// variable sized. fun[0]==0 means _type does not implement inter.</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>也就是说，我们判断两个接口类型变量是否相同，只需要判断 _type/tab 是否相同，以及 data 指针指向的内存空间所存储的数据值是否相同就可以了。</p>
<p>引入一些 <strong>helper 函数</strong>。借助这些函数，我们可以清晰地输出接口类型变量的内部表示，这样就可以一目了然地看出两个变量是否相等了。</p>
<p><strong>第一种：nil 接口变量</strong></p>
<p>无论是空接口类型还是非空接口类型变量，一旦变量值为 nil，那么它们内部表示均为(0x0,0x0)，也就是类型信息、数据值信息均为空。</p>
<p><strong>第二种：空接口类型变量</strong></p>
<p><strong>对于空接口类型变量，只有 _type 和 data 所指数据内容一致的情况下，两个空接口类型变量之间才能划等号</strong>。另外，Go 在创建 eface 时一般会为 data 重新分配新内存空间，将动态类型变量的值复制到这块内存空间，并将 data 指针指向这块内存空间。因此我们多数情况下看到的 data 指针值都是不同的。</p>
<p><strong>第三种：非空接口类型变量</strong></p>
<p>非空接口类型变量的类型信息并不为空，数据指针为空，因此它与 nil（0x0,0x0）之间不能划等号。</p>
<p><strong>第四种：空接口类型变量与非空接口类型变量的等值比较</strong></p>
<p>Go 在进行等值比较时，类型比较使用的是 eface 的 _type 和 iface 的 tab._type，因此就像我们在这个例子中看到的那样，当 eif 和 err 都被赋值为T(5)时，两者之间是划等号的。</p>
<p><strong>接口类型的装箱（boxing）原理</strong></p>
<p>**装箱（boxing）**是编程语言领域的一个基础概念，一般是指把一个值类型转换成引用类型，比如在支持装箱概念的 Java 语言中，将一个 int 变量转换成 Integer 对象就是一个装箱操作。</p>
<p>在 Go 语言中，将任意类型赋值给一个接口类型变量也是<strong>装箱</strong>操作。有了前面对接口类型变量内部表示的学习，我们知道<strong>接口类型的装箱实际就是创建一个 eface 或 iface 的过程</strong>。接下来我们就来简要描述一下这个过程，也就是接口类型的装箱原理。</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// interface_internal.go</span></span><br><span class="line">  <span class="keyword">type</span> T <span class="keyword">struct</span> {</span><br><span class="line">      n <span class="type">int</span></span><br><span class="line">      s <span class="type">string</span></span><br><span class="line">  }</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="params">(T)</span></span> M1() {}</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="params">(T)</span></span> M2() {}</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">type</span> NonEmptyInterface <span class="keyword">interface</span> {</span><br><span class="line">      M1()</span><br><span class="line">      M2()</span><br><span class="line">  }</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">      <span class="keyword">var</span> t = T{</span><br><span class="line">          n: <span class="number">17</span>,</span><br><span class="line">          s: <span class="string">"hello, interface"</span>,</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">var</span> ei <span class="keyword">interface</span>{}</span><br><span class="line">      ei = t</span><br><span class="line"> </span><br><span class="line">      <span class="keyword">var</span> i NonEmptyInterface</span><br><span class="line">      i = t</span><br><span class="line">      fmt.Println(ei)</span><br><span class="line">      fmt.Println(i)</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure>
<p>这个例子中，对 ei 和 i 两个接口类型变量的赋值都会触发装箱操作</p>
<h2 id="go-接口的应用模式或惯例"><a class="markdownIt-Anchor" href="#go-接口的应用模式或惯例"></a> <strong>Go 接口的应用模式或惯例</strong>。</h2>
<p>Go 语言之父 Rob Pike 曾说过：<strong>如果 C++ 和 Java 是关于类型层次结构和类型分类的语言，那么 Go 则是关于组合的语言。</strong></p>
<p><strong>编程语言的语法元素间和语言特性也存在着正交的情况，并且通过将这些正交的特性组合起来，我们可以实现更为高级的特性</strong>。</p>
<p>正交的语法元素：</p>
<ul>
<li>
<p>Go 语言无类型体系（Type Hierarchy），没有父子类的概念，类型定义是正交独立的；</p>
</li>
<li>
<p>方法和类型是正交的，每种类型都可以拥有自己的方法集合，方法本质上只是一个将 receiver 参数作为第一个参数的函数而已；</p>
</li>
<li>
<p>接口与它的实现者之间无“显式关联”，也就说接口与 Go 语言其他部分也是正交的</p>
</li>
</ul>
<p>在这些正交语法元素当中，<strong>接口作为 Go 语言提供的具有天然正交性的语法元素</strong>，在 Go 程序的静态结构搭建与耦合设计中扮演着至关重要的角色。</p>
<p>组合：</p>
<p><img src="/img/go%E5%AD%A6%E4%B9%A0/image-20250516213400509.png" alt="image-20250516213400509"></p>
<p><strong>垂直组合</strong></p>
<p>Go 语言通过类型的组合而不是继承让单一类型<strong>承载更多的功能</strong>。由于这种方式与硬件配置升级的垂直扩展很类似，所以这里我们叫它<strong>垂直组合</strong>。</p>
<p><strong>这样的垂直组合更多应用在新类型的定义方面</strong>。通过这种垂直组合，我们可以达到方法实现的复用、接口定义重用等目的。</p>
<p><strong>第一种：通过嵌入接口构建接口</strong></p>
<p>通过在接口定义中嵌入其他接口类型，实现接口行为聚合，组成大接口。</p>
<p><strong>第二种：通过嵌入接口构建结构体类型</strong></p>
<p>在结构体中嵌入接口，可以用于快速构建满足某一个接口的结构体类型，来满足某单元测试的需要，之后我们只需要实现少数需要的接口方法就可以了。</p>
<p><strong>第三种：通过嵌入结构体类型构建新结构体类型</strong></p>
<p>在结构体中嵌入接口类型名和在结构体中嵌入其他结构体，都是“委派模式（delegate）”的一种应用。对新结构体类型的方法调用，可能会被“委派”给该结构体内部嵌入的结构体的实例，通过这种方式构建的新结构体类型就“继承”了被嵌入的结构体的方法的实现。</p>
<p>嵌入接口类型在内的各种垂直组合更多用于类型定义层面，本质上它是一种<strong>类型组合</strong>，也是一种类型之间的耦合方式。</p>
<p><strong>水平组合</strong></p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Save</span><span class="params">(f *os.File, data []<span class="type">byte</span>)</span></span> <span class="type">error</span></span><br></pre></td></tr></tbody></table></figure>
<p>这个函数拓展性太差，依赖于不必要的 <code>*os.File</code> 类型。但是 <code>Save</code> 函数只需要参数<code>f</code>支持<code>Write()</code>函数即可。所以应该依赖于抽象（接口），而不是依赖于具体（具体的<code>*os.File</code>结构体）</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Save</span><span class="params">(w io.Writer, data []<span class="type">byte</span>)</span></span> <span class="type">error</span></span><br></pre></td></tr></tbody></table></figure>
<p>这样才对。</p>
<p><strong>接口应用的几种模式</strong></p>
<p>通过接口进行水平组合的基本模式就是：<strong>使用接受接口类型参数的函数或方法</strong>。</p>
<p><strong>基本模式</strong></p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">YourFuncName</span><span class="params">(param YourInterfaceType)</span></span></span><br></pre></td></tr></tbody></table></figure>
<p><img src="/img/go%E5%AD%A6%E4%B9%A0/image-20250517111748401.png" alt="image-20250517111748401"></p>
<p><strong>创建模式</strong></p>
<p>Go 社区流传一个经验法则：“接受接口，返回结构体（Accept interfaces, return structs）”，这其实就是一种把接口作为“关节”的应用模式。这个经验法则多用于创建某一结构体类型的实例。</p>
<p>如：</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// $GOROOT/src/sync/cond.go</span></span><br><span class="line"><span class="keyword">type</span> Cond <span class="keyword">struct</span> {</span><br><span class="line">    ... ...</span><br><span class="line">    L Locker</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCond</span><span class="params">(l Locker)</span></span> *Cond {</span><br><span class="line">    <span class="keyword">return</span> &amp;Cond{L: l}</span><br><span class="line">}</span><br><span class="line"><span class="comment">// $GOROOT/src/log/log.go</span></span><br><span class="line"><span class="keyword">type</span> Logger <span class="keyword">struct</span> {</span><br><span class="line">    mu     sync.Mutex </span><br><span class="line">    prefix <span class="type">string</span>     </span><br><span class="line">    flag   <span class="type">int</span>        </span><br><span class="line">    out    io.Writer  </span><br><span class="line">    buf    []<span class="type">byte</span>    </span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(out io.Writer, prefix <span class="type">string</span>, flag <span class="type">int</span>)</span></span> *Logger {</span><br><span class="line">    <span class="keyword">return</span> &amp;Logger{out: out, prefix: prefix, flag: flag}</span><br><span class="line">}</span><br><span class="line"><span class="comment">// $GOROOT/src/log/log.go</span></span><br><span class="line"><span class="keyword">type</span> Writer <span class="keyword">struct</span> {</span><br><span class="line">    err <span class="type">error</span></span><br><span class="line">    buf []<span class="type">byte</span></span><br><span class="line">    n   <span class="type">int</span></span><br><span class="line">    wr  io.Writer</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewWriterSize</span><span class="params">(w io.Writer, size <span class="type">int</span>)</span></span> *Writer {</span><br><span class="line">    <span class="comment">// Is it already a Writer?</span></span><br><span class="line">    b, ok := w.(*Writer)</span><br><span class="line">    <span class="keyword">if</span> ok &amp;&amp; <span class="built_in">len</span>(b.buf) &gt;= size {</span><br><span class="line">        <span class="keyword">return</span> b</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> size &lt;= <span class="number">0</span> {</span><br><span class="line">        size = defaultBufSize</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> &amp;Writer{</span><br><span class="line">        buf: <span class="built_in">make</span>([]<span class="type">byte</span>, size),</span><br><span class="line">        wr:  w,</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>用New当作对外接口，创建一个结构体。</p>
<p><strong>包装器模式</strong></p>
<p>在基本模式的基础上，当返回值的类型与参数类型相同时，我们能得到下面形式的函数原型：</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">YourWrapperFunc</span><span class="params">(param YourInterfaceType)</span></span> YourInterfaceType</span><br></pre></td></tr></tbody></table></figure>
<p>通过这个函数，我们可以实现对输入参数的类型的包装，并在不改变被包装类型（输入参数类型）的定义的情况下，返回具备新功能特性的、实现相同接口类型的新类型。这种接口应用模式我们叫它<strong>包装器模式</strong>，也叫装饰器模式。包装器多用于对输入数据的过滤、变换等操作。</p>
<p>Go 标准库中一个典型的<strong>包装器模式</strong>的应用：</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// $GOROOT/src/io/io.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LimitReader</span><span class="params">(r Reader, n <span class="type">int64</span>)</span></span> Reader { <span class="keyword">return</span> &amp;LimitedReader{r, n} }</span><br><span class="line"><span class="keyword">type</span> LimitedReader <span class="keyword">struct</span> {</span><br><span class="line">    R Reader <span class="comment">// underlying reader</span></span><br><span class="line">    N <span class="type">int64</span>  <span class="comment">// max bytes remaining</span></span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *LimitedReader)</span></span> Read(p []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>) {</span><br><span class="line">    <span class="comment">// ... ...</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>通过 LimitReader 函数的包装后，我们得到了一个具有新功能特性的 io.Reader 接口的实现类型，也就是 LimitedReader。这个新类型在 Reader 的语义基础上实现了对读取字节个数的限制。</p>
<p>调用时相当于：<code>caller &lt;-&gt; limitreader &lt;-&gt; read</code> 实现包装</p>
<p>相当于功能取并。</p>
<p><strong>适配器模式</strong></p>
<p>适配器模式不是基本模式的直接衍生模式。</p>
<p>适配器模式的核心是适配器函数类型（Adapter Function Type）。适配器函数类型是一个辅助水平组合实现的“工具”类型。这里我要再强调一下，<strong>它是一个类型</strong>。它可以将一个满足特定函数签名的普通函数，显式转换成自身类型的实例，转换后的实例同时也是某个接口类型的实现者。</p>
<p><strong>中间件</strong></p>
<p>最后，我们来介绍下中间件这个应用模式。中间件（Middleware）这个词的含义可大可小。在 Go Web 编程中，“中间件”常常指的是一个实现了 http.Handler 接口的 http.HandlerFunc 类型实例。实质上，这里的<strong>中间件就是包装模式和适配器模式结合的产物</strong>。</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">validateAuth</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">error</span> {</span><br><span class="line">    <span class="keyword">if</span> s != <span class="string">"123456"</span> {</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">"%s"</span>, <span class="string">"bad auth token"</span>)</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">greetings</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> {</span><br><span class="line">    fmt.Fprintf(w, <span class="string">"Welcome!"</span>)</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">logHandler</span><span class="params">(h http.Handler)</span></span> http.Handler {</span><br><span class="line">    <span class="keyword">return</span> http.HandlerFunc(<span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> {</span><br><span class="line">        t := time.Now()</span><br><span class="line">        log.Printf(<span class="string">"[%s] %q %v\n"</span>, r.Method, r.URL.String(), t)</span><br><span class="line">        h.ServeHTTP(w, r)</span><br><span class="line">    })</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">authHandler</span><span class="params">(h http.Handler)</span></span> http.Handler {</span><br><span class="line">    <span class="keyword">return</span> http.HandlerFunc(<span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> {</span><br><span class="line">        err := validateAuth(r.Header.Get(<span class="string">"auth"</span>))</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">            http.Error(w, <span class="string">"bad auth param"</span>, http.StatusUnauthorized)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        }</span><br><span class="line">        h.ServeHTTP(w, r)</span><br><span class="line">    })</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    http.ListenAndServe(<span class="string">":8080"</span>, logHandler(authHandler(http.HandlerFunc(greetings))))</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>所谓中间件（如：logHandler、authHandler）本质就是一个包装函数（支持链式调用），但它的内部利用了适配器函数类型（http.HandlerFunc），将一个普通函数（比如例子中的几个匿名函数）转型为实现了 http.Handler 的类型的实例。</p>
<p><strong>尽量避免使用空接口作为函数参数类型</strong></p>
<h1 id="并发"><a class="markdownIt-Anchor" href="#并发"></a> 并发</h1>
<p>“Go 并发”这个词拆开来看，它包含两方面内容，一个是并发的概念，另一个是 Go 针对并发设计给出的自身的实现方案，也就是 goroutine、channel、select 这些 Go 并发的语法特性。</p>
<p><strong>这种将程序分成多个可独立执行的部分的结构化程序的设计方法，就是并发设计</strong>。</p>
<p><strong>并发不是并行，并发关乎结构，并行关乎执行</strong>。</p>
<p>并发考虑的是如何将应用划分为多个互相配合的、可独立执行的模块的问题。采用并发设计的程序并不一定是并行执行的。</p>
<p><strong>Go 的并发方案：goroutine</strong></p>
<p>Go 并没有使用操作系统线程作为承载分解后的代码片段（模块）的基本执行单元，而是实现了goroutine这一<strong>由 Go 运行时（runtime）负责调度的、轻量的用户级线程</strong>，为并发程序设计提供原生支持。</p>
<p>Go 语言通过go关键字+函数/方法的方式创建一个 goroutine。创建后，新 goroutine 将拥有独立的代码执行流，并与创建它的 goroutine 一起被 Go 运行时调度。</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> fmt.Println(<span class="string">"I am a goroutine"</span>)</span><br><span class="line"><span class="keyword">var</span> c = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(a, b <span class="type">int</span>)</span></span> {</span><br><span class="line">    c &lt;- a + b</span><br><span class="line">}(<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment">// $GOROOT/src/net/http/server.go</span></span><br><span class="line">c := srv.newConn(rw)</span><br><span class="line"><span class="keyword">go</span> c.serve(connCtx)</span><br></pre></td></tr></tbody></table></figure>
<p>创建 goroutine 后，go 关键字不会返回 goroutine id 之类的唯一标识 goroutine 的 id，你也不要尝试去得到这样的 id 并依赖它。</p>
<p>多数情况下，我们不需要考虑对 goroutine 的退出进行控制：<strong>goroutine 的执行函数的返回，就意味着 goroutine 退出。</strong></p>
<p><strong>goroutine 间的通信</strong></p>
<p>我们可以说传统语言的并发模型是<strong>基于对内存的共享的</strong>。</p>
<p>Go 语言从设计伊始，就将解决上面这个传统并发模型的问题作为 Go 的一个目标，并在新并发模型设计中借鉴了著名计算机科学家Tony Hoare提出的 **CSP（Communicationing Sequential Processes，通信顺序进程）**并发模型。</p>
<p>在 Tony Hoare 眼中，<strong>一个符合 CSP 模型的并发程序应该是一组通过输入输出原语连接起来的 P 的集合</strong>。</p>
<p><strong>Go 始终推荐以 CSP 并发模型风格构建并发程序</strong></p>
<p><strong>Goroutine 调度器</strong></p>
<p>Goroutine 调度器的实现不是一蹴而就的，它的调度模型与算法也是几经演化，从最初的 G-M 模型、到 G-P-M 模型，从不支持抢占，到支持协作式抢占，再到支持基于信号的异步抢占，Goroutine 调度器经历了不断地优化与打磨。</p>
<p><img src="/img/go%E5%AD%A6%E4%B9%A0/image-20250517155122487.png" alt="image-20250517155122487"></p>
<p>有人说过：<strong>“计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决。”</strong></p>
<ul>
<li>G:  代表 Goroutine，存储了 Goroutine 的执行栈信息、Goroutine 状态以及 Goroutine 的任务函数等，而且 G 对象是可以重用的；</li>
<li>P:  代表逻辑 processor，P 的数量决定了系统内最大可并行的 G 的数量，P 的最大作用还是其拥有的各种 G 对象队列、链表、一些缓存和状态；</li>
<li>M:  M 代表着真正的执行计算资源。在绑定有效的 P 后，进入一个调度循环，而调度循环的机制大致是<strong>从 P 的本地运行队列以及全局队列中获取 G，切换到 G 的执行栈上并执行 G 的函数，调用 goexit 做清理工作并回到 M，如此反复</strong>。M 并不保留 G 状态，这是 G 可以跨 M 调度的基础。</li>
</ul>
<p><strong>G 被抢占调度</strong></p>
<p>除非极端的无限循环，否则只要 G 调用函数，Go 运行时就有了抢占 G 的机会。</p>
<h2 id="channel"><a class="markdownIt-Anchor" href="#channel"></a> channel</h2>
<p><strong>创建 channel</strong></p>
<p>和切片、结构体、map 等一样，channel 也是一种复合数据类型。也就是说，我们在声明一个 channel 类型变量时，必须给出其具体的元素类型。</p>
<p><code>var ch chan int</code></p>
<p>如果 channel 类型变量在声明时没有被赋予初值，那么它的默认值为 nil。并且，和其他复合数据类型支持使用复合类型字面值作为变量初始值不同，为 channel 类型变量赋初值的唯一方法就是使用 <strong>make</strong> 这个 Go 预定义的函数，比如下面代码：</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ch1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)    <span class="comment">// 无缓冲的channel</span></span><br><span class="line">ch2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">5</span>) <span class="comment">// 有缓冲的channel</span></span><br></pre></td></tr></tbody></table></figure>
<p>这两种类型的变量关于发送（send）与接收（receive）的特性是不同的。</p>
<p><strong>发送与接收</strong></p>
<p>Go 提供了&lt;-操作符用于对 channel 类型变量进行发送与接收操作：</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ch1 &lt;- <span class="number">13</span>    <span class="comment">// 将整型字面值13发送到无缓冲channel类型变量ch1中</span></span><br><span class="line">n := &lt;- ch1  <span class="comment">// 从无缓冲channel类型变量ch1中接收一个整型值存储到整型变量n中</span></span><br><span class="line">ch2 &lt;- <span class="number">17</span>    <span class="comment">// 将整型字面值17发送到带缓冲channel类型变量ch2中</span></span><br><span class="line">m := &lt;- ch2  <span class="comment">// 从带缓冲channel类型变量ch2中接收一个整型值存储到整型变量m中</span></span><br></pre></td></tr></tbody></table></figure>
<p><strong>channel 是用于 Goroutine 间通信的</strong>，所以绝大多数对 channel 的读写都被分别放在了不同的 Goroutine 中。</p>
<p>由于无缓冲 channel 的运行时层实现不带有缓冲区，所以 Goroutine 对无缓冲 channel 的接收和发送操作是同步的。也就是说，对同一个无缓冲 channel，只有对它进行接收操作的 Goroutine 和对它进行发送操作的 Goroutine 都存在的情况下，通信才能得以进行，否则单方面的操作会让对应的 Goroutine 陷入挂起状态，比如下面示例代码：</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    ch1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    ch1 &lt;- <span class="number">13</span> <span class="comment">// fatal error: all goroutines are asleep - deadlock!</span></span><br><span class="line">    n := &lt;-ch1</span><br><span class="line">    <span class="built_in">println</span>(n)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>上面出现错误：提示我们所有 Goroutine 都处于休眠状态，程序处于死锁状态。</p>
<p>要想解除这种错误状态，我们只需要将接收操作，或者发送操作放到另外一个 Goroutine 中就可以了，比如下面代码：</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    ch1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">        ch1 &lt;- <span class="number">13</span> <span class="comment">// 将发送操作放入一个新goroutine中执行</span></span><br><span class="line">    }()</span><br><span class="line">    n := &lt;-ch1</span><br><span class="line">    <span class="built_in">println</span>(n)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>结论：<strong>对无缓冲 channel 类型的发送与接收操作，一定要放在两个不同的 Goroutine 中进行，否则会导致 deadlock</strong>。</p>
<p>和无缓冲 channel 相反，带缓冲 channel 的运行时层实现带有缓冲区，因此，对带缓冲 channel 的发送操作在缓冲区未满、接收操作在缓冲区非空的情况下是<strong>异步</strong>的（发送或接收不需要阻塞等待）。</p>
<p>对一个带缓冲 channel 来说，在缓冲区未满的情况下，对它进行发送操作的 Goroutine 并不会阻塞挂起；在缓冲区有数据的情况下，对它进行接收操作的 Goroutine 也不会阻塞挂起。</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ch2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">1</span>)</span><br><span class="line">n := &lt;-ch2 <span class="comment">// 由于此时ch2的缓冲区中无数据，因此对其进行接收操作将导致goroutine挂起</span></span><br><span class="line">ch3 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">1</span>)</span><br><span class="line">ch3 &lt;- <span class="number">17</span>  <span class="comment">// 向ch3发送一个整型数17</span></span><br><span class="line">ch3 &lt;- <span class="number">27</span>  <span class="comment">// 由于此时ch3中缓冲区已满，再向ch3发送数据也将导致goroutine挂起</span></span><br></pre></td></tr></tbody></table></figure>
<p>使用操作符&lt;-，我们还可以声明<strong>只发送 channel 类型</strong>（send-only）和<strong>只接收 channel 类型</strong>（recv-only），我们接着看下面这个例子：</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ch1 := <span class="built_in">make</span>(<span class="keyword">chan</span>&lt;- <span class="type">int</span>, <span class="number">1</span>) <span class="comment">// 只发送channel类型</span></span><br><span class="line">ch2 := <span class="built_in">make</span>(&lt;-<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">1</span>) <span class="comment">// 只接收channel类型</span></span><br><span class="line">&lt;-ch1       <span class="comment">// invalid operation: &lt;-ch1 (receive from send-only type chan&lt;- int)</span></span><br><span class="line">ch2 &lt;- <span class="number">13</span>   <span class="comment">// invalid operation: ch2 &lt;- 13 (send to receive-only type &lt;-chan int)</span></span><br></pre></td></tr></tbody></table></figure>
<p>试图从一个只发送 channel 类型变量中接收数据，或者向一个只接收 channel 类型发送数据，都会导致编译错误。通常只发送 channel 类型和只接收 channel 类型，会被用作函数的参数类型或返回值，用于限制对 channel 内的操作，或者是明确可对 channel 进行的操作的类型，比如下面这个例子：</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">produce</span><span class="params">(ch <span class="keyword">chan</span>&lt;- <span class="type">int</span>)</span></span> {</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ {</span><br><span class="line">        ch &lt;- i + <span class="number">1</span></span><br><span class="line">        time.Sleep(time.Second)</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">close</span>(ch) <span class="comment">// 关闭</span></span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">consume</span><span class="params">(ch &lt;-<span class="keyword">chan</span> <span class="type">int</span>)</span></span> {</span><br><span class="line">    <span class="keyword">for</span> n := <span class="keyword">range</span> ch {</span><br><span class="line">        <span class="built_in">println</span>(n)</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">5</span>)</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    wg.Add(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">        produce(ch)</span><br><span class="line">        wg.Done()</span><br><span class="line">    }()</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">        consume(ch)</span><br><span class="line">        wg.Done()</span><br><span class="line">    }()</span><br><span class="line">    wg.Wait()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong>关闭 channel</strong></p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">n := &lt;- ch      <span class="comment">// 当ch被关闭后，n将被赋值为ch元素类型的零值</span></span><br><span class="line">m, ok := &lt;-ch   <span class="comment">// 当ch被关闭后，m将被赋值为ch元素类型的零值, ok值为false</span></span><br><span class="line"><span class="keyword">for</span> v := <span class="keyword">range</span> ch { <span class="comment">// 当ch被关闭后，for range循环结束</span></span><br><span class="line">    ... ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>produce 函数在发送完数据后，调用 Go 内置的 close 函数关闭了 channel。channel 关闭后，所有等待从这个 channel 接收数据的操作都将返回。</p>
<p>通过“comma, ok”惯用法或 for range 语句，我们可以准确地判定 channel 是否被关闭。而单纯采用n := &lt;-ch形式的语句，我们就无法判定从 ch 返回的元素类型零值，究竟是不是因为 channel 被关闭后才返回的。</p>
<p>channel 是在 produce 函数中被关闭的，这也是 channel 的一个使用惯例，那就是<strong>发送端负责关闭 channel</strong>。</p>
<p>发送端没有像接受端那样的、可以安全判断 channel 是否被关闭了的方法。同时，一旦向一个已经关闭的 channel 执行发送操作，这个操作就会引发 panic，比如下面这个示例：</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">5</span>)</span><br><span class="line"><span class="built_in">close</span>(ch)</span><br><span class="line">ch &lt;- <span class="number">13</span> <span class="comment">// panic: send on closed channel</span></span><br></pre></td></tr></tbody></table></figure>
<p><strong>select</strong></p>
<p>当涉及同时对多个 channel 进行操作时，我们会结合 Go 为 CSP 并发模型提供的另外一个原语 <strong>select</strong>，一起使用。</p>
<p>通过 select，我们可以同时在多个 channel 上进行发送 / 接收操作：</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> {</span><br><span class="line"><span class="keyword">case</span> x := &lt;-ch1:     <span class="comment">// 从channel ch1接收数据</span></span><br><span class="line">  ... ...</span><br><span class="line"><span class="keyword">case</span> y, ok := &lt;-ch2: <span class="comment">// 从channel ch2接收数据，并根据ok值判断ch2是否已经关闭</span></span><br><span class="line">  ... ...</span><br><span class="line"><span class="keyword">case</span> ch3 &lt;- z:       <span class="comment">// 将z值发送到channel ch3中:</span></span><br><span class="line">  ... ...</span><br><span class="line"><span class="keyword">default</span>:             <span class="comment">// 当上面case中的channel通信均无法实施时，执行该默认分支</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>当 select 语句中没有 default 分支，而且所有 case 中的 channel 操作都阻塞了的时候，整个 select 语句都将被阻塞，直到某一个 case 上的 channel 变成可发送，或者某个 case 上的 channel 变成可接收，select 语句才可以继续进行下去。</p>
<p>看到这里你应该能感受到，channel 和 select 两种原语的操作都十分简单，它们都遵循了 Go 语言**“追求简单”**的设计哲学，但它们却为 Go 并发程序带来了强大的表达能力。学习了这些基础用法后，接下来我们再深一层，看看 Go 并发原语 channel 的一些惯用法。同样地，这里我们也分成无缓冲 channel 和带缓冲 channel 两种情况来分析。</p>
<p><strong>无缓冲 channel 的惯用法</strong></p>
<p>无缓冲 channel 兼具通信和同步特性，在并发程序中应用颇为广泛。</p>
<p><strong>第一种用法：用作信号传递</strong></p>
<p>无缓冲 channel 用作信号传递的时候，有两种情况，分别是 1 对 1 通知信号和 1 对 n 通知信号。我们先来分析下 1 对 1 通知信号这种情况。</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> signal <span class="keyword">struct</span>{}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">"worker is working..."</span>)</span><br><span class="line">    time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">spawn</span><span class="params">(f <span class="keyword">func</span>()</span></span>) &lt;-<span class="keyword">chan</span> signal {</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> signal)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">        <span class="built_in">println</span>(<span class="string">"worker start to work..."</span>)</span><br><span class="line">        f()</span><br><span class="line">        c &lt;- signal(<span class="keyword">struct</span>{}{})</span><br><span class="line">    }()</span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">"start a worker..."</span>)</span><br><span class="line">    c := spawn(worker)</span><br><span class="line">    &lt;-c</span><br><span class="line">    fmt.Println(<span class="string">"worker work done!"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>有些时候，无缓冲 channel 还被用来实现 <strong>1 对 n 的信号通知</strong>机制。这样的信号通知机制，常被用于协调多个 Goroutine 一起工作</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(i <span class="type">int</span>)</span></span> {</span><br><span class="line">    fmt.Printf(<span class="string">"worker %d: is working...\n"</span>, i)</span><br><span class="line">    time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">    fmt.Printf(<span class="string">"worker %d: works done\n"</span>, i)</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">spawnGroup</span><span class="params">(f <span class="keyword">func</span>(i <span class="type">int</span>)</span></span>, num <span class="type">int</span>, groupSignal &lt;-<span class="keyword">chan</span> signal) &lt;-<span class="keyword">chan</span> signal {</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> signal)</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; num; i++ {</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> {</span><br><span class="line">            &lt;-groupSignal</span><br><span class="line">            fmt.Printf(<span class="string">"worker %d: start to work...\n"</span>, i)</span><br><span class="line">            f(i)</span><br><span class="line">            wg.Done()</span><br><span class="line">        }(i + <span class="number">1</span>)</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">        wg.Wait()</span><br><span class="line">        c &lt;- signal(<span class="keyword">struct</span>{}{})</span><br><span class="line">    }()</span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    fmt.Println(<span class="string">"start a group of workers..."</span>)</span><br><span class="line">    groupSignal := <span class="built_in">make</span>(<span class="keyword">chan</span> signal)</span><br><span class="line">    c := spawnGroup(worker, <span class="number">5</span>, groupSignal)</span><br><span class="line">    time.Sleep(<span class="number">5</span> * time.Second)</span><br><span class="line">    fmt.Println(<span class="string">"the group of workers start to work..."</span>)</span><br><span class="line">    <span class="built_in">close</span>(groupSignal)</span><br><span class="line">    &lt;-c</span><br><span class="line">    fmt.Println(<span class="string">"the group of workers work done!"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>这个例子中，main goroutine 创建了一组 5 个 worker goroutine，这些 Goroutine 启动后会阻塞在名为 groupSignal 的无缓冲 channel 上。</p>
<p><strong>第二种用法：用于替代锁机制</strong></p>
<p>无缓冲 channel 具有同步特性，这让它在某些场合可以替代锁，让我们的程序更加清晰，可读性也更好。我们可以对比下两个方案，直观地感受一下。</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> counter <span class="keyword">struct</span> {</span><br><span class="line">    c <span class="keyword">chan</span> <span class="type">int</span></span><br><span class="line">    i <span class="type">int</span></span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCounter</span><span class="params">()</span></span> *counter {</span><br><span class="line">    cter := &amp;counter{</span><br><span class="line">        c: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>),</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">        <span class="keyword">for</span> {</span><br><span class="line">            cter.i++</span><br><span class="line">            cter.c &lt;- cter.i</span><br><span class="line">        }</span><br><span class="line">    }()</span><br><span class="line">    <span class="keyword">return</span> cter</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cter *counter)</span></span> Increase() <span class="type">int</span> {</span><br><span class="line">    <span class="keyword">return</span> &lt;-cter.c</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    cter := NewCounter()</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ {</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> {</span><br><span class="line">            v := cter.Increase()</span><br><span class="line">            fmt.Printf(<span class="string">"goroutine-%d: current counter value is %d\n"</span>, i, v)</span><br><span class="line">            wg.Done()</span><br><span class="line">        }(i)</span><br><span class="line">    }</span><br><span class="line">    wg.Wait()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>我们将计数器操作全部交给一个独立的 Goroutine 去处理，并通过无缓冲 channel 的同步阻塞特性，实现了计数器的控制。这样其他 Goroutine 通过 Increase 函数试图增加计数器值的动作，实质上就转化为了一次无缓冲 channel 的接收动作。</p>
<p><strong>带缓冲 channel 的惯用法</strong></p>
<p>带缓冲的 channel 与无缓冲的 channel 的最大不同之处，就在于它的<strong>异步性</strong>。</p>
<p><strong>第一种用法：用作消息队列</strong></p>
<p>无缓冲 channel 更多用于信号 / 事件管道相比，可自行设置容量、异步收发的带缓冲 channel 更适合被用作为消息队列，并且，带缓冲 channel 在数据收发的性能上要明显好于无缓冲 channel。</p>
<ul>
<li>
<p>无论是 1 收 1 发还是多收多发，带缓冲 channel 的收发性能都要好于无缓冲 channel；</p>
</li>
<li>
<p>对于带缓冲 channel 而言，发送与接收的 Goroutine 数量越多，收发性能会有所下降；</p>
</li>
<li>
<p>对于带缓冲 channel 而言，选择适当容量会在一定程度上提升收发性能。</p>
</li>
</ul>
<p><strong>第二种用法：用作计数信号量（counting semaphore）</strong></p>
<p>Go 并发设计的一个惯用法，就是将带缓冲 channel 用作计数信号量（counting semaphore）。带缓冲 channel 中的当前数据个数代表的是，当前同时处于活动状态（处理业务）的 Goroutine 的数量，而带缓冲 channel 的容量（capacity），就代表了允许同时处于活动状态的 Goroutine 的最大数量。向带缓冲 channel 的一个发送操作表示获取一个信号量，而从 channel 的一个接收操作则表示释放一个信号量。</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> active = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>{}, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">var</span> jobs = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">10</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">8</span>; i++ {</span><br><span class="line">            jobs &lt;- (i + <span class="number">1</span>)</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">close</span>(jobs)</span><br><span class="line">    }()</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    <span class="keyword">for</span> j := <span class="keyword">range</span> jobs {</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(j <span class="type">int</span>)</span></span> {</span><br><span class="line">            active &lt;- <span class="keyword">struct</span>{}{}</span><br><span class="line">            log.Printf(<span class="string">"handle job: %d\n"</span>, j)</span><br><span class="line">            time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">            &lt;-active</span><br><span class="line">            wg.Done()</span><br><span class="line">        }(j)</span><br><span class="line">    }</span><br><span class="line">    wg.Wait()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>这个示例创建了一组 Goroutine 来处理 job，同一时间允许最多 3 个 Goroutine 处于活动状态。</p>
<p>这个示例使用了一个容量（capacity）为 3 的带缓冲 channel: <strong>active</strong> 作为计数信号量，这意味着允许同时处于<strong>活动状态</strong>的最大 Goroutine 数量为 3。</p>
<p><strong>len(channel) 的应用</strong></p>
<p><strong>len</strong> 是 Go 语言的一个内置函数，它支持接收数组、切片、map、字符串和 channel 类型的参数，并返回对应类型的“长度”，也就是一个整型值。</p>
<p>针对 channel ch 的类型不同，len(ch) 有如下两种语义：</p>
<ul>
<li>
<p>当 ch 为无缓冲 channel 时，len(ch) 总是返回 0；</p>
</li>
<li>
<p>当 ch 为带缓冲 channel 时，len(ch) 返回当前 channel ch 中尚未被读取的元素个数。</p>
</li>
</ul>
<p>channel 原语用于多个 Goroutine 间的通信，一旦多个 Goroutine 共同对 channel 进行收发操作，len(channel) 就会在多个 Goroutine 间形成“竞态”。单纯地依靠 len(channel) 来判断 channel 中元素状态，是不能保证在后续对 channel 的收发时 channel 状态是不变的。这是因为，判断状态和执行操作，这不是原子的。</p>
<p>为了正常运行，常见的方法是将“判空与读取”放在一个“事务”中，将“判满与写入”放在一个“事务”中，而这类“事务”我们可以通过 select 实现。</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tryRecv</span><span class="params">(c &lt;-<span class="keyword">chan</span> <span class="type">int</span>)</span></span> (<span class="type">int</span>, <span class="type">bool</span>) {</span><br><span class="line">    <span class="keyword">select</span> {</span><br><span class="line">    <span class="keyword">case</span> i := &lt;-c:</span><br><span class="line">        <span class="keyword">return</span> i, <span class="literal">true</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>, <span class="literal">false</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">trySend</span><span class="params">(c <span class="keyword">chan</span>&lt;- <span class="type">int</span>, i <span class="type">int</span>)</span></span> <span class="type">bool</span> {</span><br><span class="line">    <span class="keyword">select</span> {</span><br><span class="line">    <span class="keyword">case</span> c &lt;- i:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>但是这种方法有一个“问题”，那就是它改变了 channel 的状态，会让 channel 接收了一个元素或发送一个元素到 channel。</p>
<p>如果只想侦测 channel 状态，只能用 len(channel)</p>
<p><strong>nil channel 的妙用</strong></p>
<p>如果一个 channel 类型变量的值为 nil，我们称它为 <strong>nil channel</strong>。nil channel 有一个特性，那就是对 nil channel 的读写都会发生阻塞。</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">  <span class="keyword">var</span> c <span class="keyword">chan</span> <span class="type">int</span></span><br><span class="line">  &lt;-c <span class="comment">//阻塞</span></span><br><span class="line">}</span><br><span class="line">或者：</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">  <span class="keyword">var</span> c <span class="keyword">chan</span> <span class="type">int</span></span><br><span class="line">  c&lt;<span class="number">-1</span>  <span class="comment">//阻塞</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>因为 <code>channel close</code>之后，接收方还是可以接收，不会阻塞。</p>
<p>但是 <code>channel nil</code> 之后，接收方就会阻塞了。</p>
<p>在 <code>select</code> 块中比较有用。</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    ch1, ch2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>), <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">        time.Sleep(time.Second * <span class="number">5</span>)</span><br><span class="line">        ch1 &lt;- <span class="number">5</span></span><br><span class="line">        <span class="built_in">close</span>(ch1)</span><br><span class="line">    }()</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">        time.Sleep(time.Second * <span class="number">7</span>)</span><br><span class="line">        ch2 &lt;- <span class="number">7</span></span><br><span class="line">        <span class="built_in">close</span>(ch2)</span><br><span class="line">    }()</span><br><span class="line">    <span class="keyword">for</span> {</span><br><span class="line">        <span class="keyword">select</span> {</span><br><span class="line">        <span class="keyword">case</span> x, ok := &lt;-ch1:</span><br><span class="line">            <span class="keyword">if</span> !ok {</span><br><span class="line">                ch1 = <span class="literal">nil</span></span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                fmt.Println(x)</span><br><span class="line">            }</span><br><span class="line">        <span class="keyword">case</span> x, ok := &lt;-ch2:</span><br><span class="line">            <span class="keyword">if</span> !ok {</span><br><span class="line">                ch2 = <span class="literal">nil</span></span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                fmt.Println(x)</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> ch1 == <span class="literal">nil</span> &amp;&amp; ch2 == <span class="literal">nil</span> {</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    fmt.Println(<span class="string">"program end"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong>对一个 nil channel 执行获取操作，这个操作将阻塞</strong>。</p>
<p><strong>与 select 结合使用的一些惯用法</strong></p>
<p><strong>第一种用法：利用 default 分支避免阻塞</strong></p>
<p><strong>第二种用法：实现超时机制</strong></p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">()</span></span> {</span><br><span class="line">  <span class="keyword">select</span> {</span><br><span class="line">  <span class="keyword">case</span> &lt;-c:</span><br><span class="line">       <span class="comment">// ... do some stuff</span></span><br><span class="line">  <span class="keyword">case</span> &lt;-time.After(<span class="number">30</span> *time.Second):</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>Go 语言标准库提供的 timer 实际上是由 Go 运行时自行维护的，而不是操作系统级的定时器资源，它的使用代价要比操作系统级的低许多。但即便如此，作为 time.Timer 的使用者，我们也要尽量减少在使用 Timer 时给 Go 运行时和 Go 垃圾回收带来的压力，要及时调用 timer 的 Stop 方法回收 Timer 资源。</p>
<p><strong>第三种用法：实现心跳机制</strong></p>
<p>结合 time 包的 Ticker，我们可以实现带有心跳机制的 select。这种机制让我们可以在监听 channel 的同时，执行一些<strong>周期性的任务</strong>，比如下面这段代码：</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">()</span></span> {</span><br><span class="line">  heartbeat := time.NewTicker(<span class="number">30</span> * time.Second)</span><br><span class="line">  <span class="keyword">defer</span> heartbeat.Stop()</span><br><span class="line">  <span class="keyword">for</span> {</span><br><span class="line">    <span class="keyword">select</span> {</span><br><span class="line">    <span class="keyword">case</span> &lt;-c:</span><br><span class="line">      <span class="comment">// ... do some stuff</span></span><br><span class="line">    <span class="keyword">case</span> &lt;- heartbeat.C:</span><br><span class="line">      <span class="comment">//... do heartbeat stuff</span></span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="共享"><a class="markdownIt-Anchor" href="#共享"></a> 共享</h2>
<p><strong>sync 包低级同步原语可以用在哪？</strong></p>
<p>一般情况下，建议优先使用 CSP 并发模型进行并发程序设计。但是在下面一些场景中，我们依然需要 sync 包提供的低级同步原语。</p>
<p><strong>首先是需要高性能的临界区（critical section）同步机制场景。</strong></p>
<p>在 Go 中，channel 并发原语也可以用于对数据对象访问的同步，我们可以把 channel 看成是一种高级的同步原语，它自身的实现也是建构在低级同步原语之上的。也正因为如此，channel 自身的性能与低级同步原语相比要略微逊色，开销要更大。</p>
<p><strong>第二种就是在不想转移结构体对象所有权，但又要保证结构体内部状态数据的同步访问的场景。</strong></p>
<p>基于 channel 的并发设计，有一个特点：在 Goroutine 间通过 channel 转移数据对象的所有权。所以，只有拥有数据对象所有权（从 channel 接收到该数据）的 Goroutine 才可以对该数据对象进行状态变更。</p>
<p>如果你的设计中没有转移结构体对象所有权，但又要保证结构体内部状态数据在多个 Goroutine 之间同步访问，那么你可以使用 sync 包提供的低级同步原语来实现，比如最常用的sync.Mutex。</p>
<p><strong>sync 包中同步原语使用的注意事项</strong></p>
<p>在 sync 包的注释中（在$GOROOT/src/sync/mutex.go文件的头部注释），我们看到这样一行说明：<code>// Values containing the types defined in this package should not be copied.</code></p>
<p>翻译过来就是：“不应复制那些包含了此包中类型的值”。</p>
<p>那么，为什么首次使用 Mutex 等 sync 包中定义的结构类型后，我们不应该再对它们进行复制操作呢？我们以 Mutex 这个同步原语为例，看看它的实现是怎样的。</p>
<p>Go 标准库中 sync.Mutex 的定义是这样的：</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// $GOROOT/src/sync/mutex.go</span></span><br><span class="line"><span class="keyword">type</span> Mutex <span class="keyword">struct</span> {</span><br><span class="line">    state <span class="type">int32</span>  <span class="comment">// state：表示当前互斥锁的状态；</span></span><br><span class="line">    sema  <span class="type">uint32</span> <span class="comment">// sema：用于控制锁状态的信号量。</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>初始情况下，Mutex 的实例处于 <strong>Unlocked</strong> 状态（state 和 sema 均为 0）。对 Mutex 实例的复制也就是两个整型字段的复制。一旦发生复制，原变量与副本就是两个单独的内存块，各自发挥同步作用，互相就没有了关联。</p>
<p>因为发生复制后，原变量与副本保护就是两个无关联的Mutex了，应该使用指针传递。</p>
<p>如果对使用过的、sync 包中的类型的示例进行复制，并使用了复制后得到的副本，将导致不可预期的结果。所以，在使用 sync 包中的类型的时候，我们推荐通过<strong>闭包</strong>方式，或者是**传递类型实例（或包裹该类型的类型实例）的地址（指针）**的方式进行。这就是使用 sync 包时最值得我们注意的事项。</p>
<p><strong>互斥锁（Mutex）还是读写锁（RWMutex）？</strong></p>
<p><strong>互斥锁</strong> ：</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mu sync.Mutex</span><br><span class="line">mu.Lock()   <span class="comment">// 加锁</span></span><br><span class="line">doSomething()</span><br><span class="line">mu.Unlock() <span class="comment">// 解锁</span></span><br></pre></td></tr></tbody></table></figure>
<p>互斥锁的两个原则：</p>
<ul>
<li>
<p><strong>尽量减少在锁中的操作</strong>。这可以减少其他因 Goroutine 阻塞而带来的损耗与延迟。</p>
</li>
<li>
<p><strong>一定要记得调用 Unlock 解锁</strong>。忘记解锁会导致程序局部死锁，甚至是整个程序死锁，会导致严重的后果。同时，我们也可以结合第 23 讲学习到的 defer，优雅地执行解锁操作。</p>
</li>
</ul>
<p><strong>读写锁：</strong></p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> rwmu sync.RWMutex</span><br><span class="line">rwmu.RLock()   <span class="comment">//加读锁</span></span><br><span class="line">readSomething()</span><br><span class="line">rwmu.RUnlock() <span class="comment">//解读锁</span></span><br><span class="line">rwmu.Lock()    <span class="comment">//加写锁</span></span><br><span class="line">changeSomething()</span><br><span class="line">rwmu.Unlock()  <span class="comment">//解写锁</span></span><br></pre></td></tr></tbody></table></figure>
<p><strong>互斥锁（Mutex）是临时区同步原语的首选</strong>，它常被用来对结构体对象的内部状态、缓存等进行保护，是使用最为广泛的临界区同步原语。相比之下，读写锁的应用就没那么广泛了，只活跃于它擅长的场景下。</p>
<p><strong>读写锁适合应用在具有一定并发量且读多写少的场合</strong>。在大量并发读的情况下，多个 Goroutine 可以同时持有读锁，从而减少在锁竞争中等待的时间。</p>
<p><strong>条件变量</strong></p>
<p>sync.Cond是传统的条件变量原语概念在 Go 语言中的实现。我们可以把一个条件变量理解为一个容器，这个容器中存放着一个或一组等待着某个条件成立的 Goroutine。</p>
<p>用来对条件进行轮询的时候使用。</p>
<p>使用方法如下：</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> signal <span class="keyword">struct</span>{}</span><br><span class="line"><span class="keyword">var</span> ready <span class="type">bool</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(i <span class="type">int</span>)</span></span> {</span><br><span class="line">  fmt.Printf(<span class="string">"worker %d: is working...\n"</span>, i)</span><br><span class="line">  time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">  fmt.Printf(<span class="string">"worker %d: works done\n"</span>, i)</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">spawnGroup</span><span class="params">(f <span class="keyword">func</span>(i <span class="type">int</span>)</span></span>, num <span class="type">int</span>, groupSignal *sync.Cond) &lt;-<span class="keyword">chan</span> signal {</span><br><span class="line">  c := <span class="built_in">make</span>(<span class="keyword">chan</span> signal)</span><br><span class="line">  <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; num; i++ {</span><br><span class="line">    wg.Add(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> {</span><br><span class="line">      groupSignal.L.Lock()</span><br><span class="line">      <span class="keyword">for</span> !ready {</span><br><span class="line">        groupSignal.Wait()</span><br><span class="line">      }</span><br><span class="line">      groupSignal.L.Unlock()</span><br><span class="line">      fmt.Printf(<span class="string">"worker %d: start to work...\n"</span>, i)</span><br><span class="line">      f(i)</span><br><span class="line">      wg.Done()</span><br><span class="line">    }(i + <span class="number">1</span>)</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">    wg.Wait()</span><br><span class="line">    c &lt;- signal(<span class="keyword">struct</span>{}{})</span><br><span class="line">  }()</span><br><span class="line">  <span class="keyword">return</span> c</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">  fmt.Println(<span class="string">"start a group of workers..."</span>)</span><br><span class="line">  groupSignal := sync.NewCond(&amp;sync.Mutex{})</span><br><span class="line">  c := spawnGroup(worker, <span class="number">5</span>, groupSignal)</span><br><span class="line">  time.Sleep(<span class="number">5</span> * time.Second) <span class="comment">// 模拟ready前的准备工作</span></span><br><span class="line">  fmt.Println(<span class="string">"the group of workers start to work..."</span>)</span><br><span class="line">  groupSignal.L.Lock()</span><br><span class="line">  ready = <span class="literal">true</span></span><br><span class="line">  groupSignal.Broadcast()</span><br><span class="line">  groupSignal.L.Unlock()</span><br><span class="line">  &lt;-c</span><br><span class="line">  fmt.Println(<span class="string">"the group of workers work done!"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>sync.Cond实例的初始化，需要一个满足实现了sync.Locker接口的类型实例，通常我们使用sync.Mutex。</p>
<p>条件变量需要这个互斥锁来同步临界区，保护用作条件的数据。加锁后，各个等待条件成立的 Goroutine 判断条件是否成立，如果不成立，则调用sync.Cond的 Wait 方法进入等待状态。Wait 方法在 Goroutine 挂起前会进行 Unlock 操作。</p>
<p>和sync.Mutex 、sync.RWMutex等相比，sync.Cond 应用的场景更为有限，只有在需要“等待某个条件成立”的场景下，Cond 才有用武之地。</p>
<p><strong>原子操作（atomic operations）</strong></p>
<p>atomic 包提供了两大类原子操作接口，一类是针对整型变量的，包括有符号整型、无符号整型以及对应的指针类型；另外一类是针对自定义类型的。因此，第一类原子操作接口的存在让 atomic 包天然适合去实现某一个共享整型变量的并发同步。</p>
<p>atomic 原子操作的特性：随着并发量提升，使用 atomic 实现的<strong>共享变量</strong>的并发读写性能表现更为稳定，尤其是原子读操作，和 sync 包中的读写锁原语比起来，atomic 表现出了更好的伸缩性和高性能。</p>
<p>atomic 包更适合<strong>一些对性能十分敏感、并发量较大且读多写少的场合</strong>。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="https://Dog-Du.github.io">DogDu</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="https://dog-du.github.io/posts/27248.html">https://dog-du.github.io/posts/27248.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%AD%A6%E4%B9%A0/">学习</a><a class="post-meta__tags" href="/tags/%E6%9C%AA%E5%AE%8C%E6%88%90/">未完成</a><a class="post-meta__tags" href="/tags/Go/">Go</a></div><div class="post-share"><div class="social-share" data-image="/img/top_img.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/posts/8453.html" title="读论文-Architecture of a Database System"><img class="cover" src="/img/top_img.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">Previous</div><div class="info-item-2">读论文-Architecture of a Database System</div></div><div class="info-2"><div class="info-item-1">英语很差，看论文很费解，但是看了一下作者居然有 Stonebraker，这下耐着性子慢慢读这 119 页了。整体上是一个翻译。</div></div></div></a><a class="pagination-related" href="/posts/8921.html" title="读论文-Learning to Optimize Join Queries With Deep Reinforcement Learning"><img class="cover" src="/img/top_img.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">Next</div><div class="info-item-2">读论文-Learning to Optimize Join Queries With Deep Reinforcement Learning</div></div><div class="info-2"><div class="info-item-1">读论文-Learning to Optimize Join Queries With Deep Reinforcement Learning</div></div></div></a></nav><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> Comments</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/head.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">DogDu</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">19</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">17</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">2</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Dog-Du"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is DogDu's Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE"><span class="toc-text"> 环境配置</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E5%8C%85%E7%AE%A1%E7%90%86"><span class="toc-text"> 简单包管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#init-%E5%87%BD%E6%95%B0go-%E5%8C%85%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%87%BD%E6%95%B0"><span class="toc-text"> init 函数：Go 包的初始化函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E8%AF%AD%E6%B3%95"><span class="toc-text"> 简单语法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E"><span class="toc-text"> 变量声明：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%9D%97%E4%B8%8E%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-text"> 代码块与作用域</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B"><span class="toc-text"> 类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#rune-%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%AD%97%E7%AC%A6%E5%AD%97%E9%9D%A2%E5%80%BC"><span class="toc-text"> rune 类型与字符字面值</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F"><span class="toc-text"> 常量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%8D%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text"> 复合数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-text"> 数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-text"> 多维数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%87%E7%89%87"><span class="toc-text"> 切片</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%87%E7%89%87%E7%9A%84%E5%8A%A8%E6%80%81%E6%89%A9%E5%AE%B9"><span class="toc-text"> 切片的动态扩容</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#map%E7%B1%BB%E5%9E%8B"><span class="toc-text"> map类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E%E4%B8%8E%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text"> 声明与初始化。</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%8D%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-text"> 复合数据类型：结构体</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84"><span class="toc-text"> 控制结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#if-%E5%88%86%E6%94%AF"><span class="toc-text"> if 分支</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#for-%E5%BE%AA%E7%8E%AF"><span class="toc-text"> for 循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#switch"><span class="toc-text"> switch</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0-%E4%B8%80%E7%AD%89%E5%85%AC%E6%B0%91"><span class="toc-text"> 函数 - 一等公民</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E8%BF%94%E5%9B%9E%E5%80%BC%E4%B8%8E%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86"><span class="toc-text"> 多返回值与错误处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E7%AD%96%E7%95%A5"><span class="toc-text"> 错误处理策略</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%81%A5%E5%A3%AE%E7%AE%80%E6%B4%81%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-text"> 健壮简洁的函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%90%86%E8%A7%A3%E6%96%B9%E6%B3%95%E7%9A%84%E6%9C%AC%E8%B4%A8"><span class="toc-text"> 理解“方法”的本质</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E9%9B%86%E5%90%88%E4%BB%A5%E5%8F%8A-receive-%E7%B1%BB%E5%9E%8B"><span class="toc-text"> 方法集合以及 receive 类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E5%B5%8C%E5%85%A5%E6%A8%A1%E6%8B%9F%E7%BB%A7%E6%89%BF"><span class="toc-text"> 方法：用类型嵌入模拟“继承”？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3"><span class="toc-text"> 接口</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3-2"><span class="toc-text"> 接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8A%A8%E4%B8%8E%E9%9D%99"><span class="toc-text"> 接口的动与静</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#go-%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%BA%94%E7%94%A8%E6%A8%A1%E5%BC%8F%E6%88%96%E6%83%AF%E4%BE%8B"><span class="toc-text"> Go 接口的应用模式或惯例。</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91"><span class="toc-text"> 并发</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#channel"><span class="toc-text"> channel</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB"><span class="toc-text"> 共享</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Posts</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/38177.html" title="Rust学习">Rust学习</a><time datetime="2025-05-18T10:44:22.000Z" title="Created 2025-05-18 18:44:22">2025-05-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/8921.html" title="读论文-Learning to Optimize Join Queries With Deep Reinforcement Learning">读论文-Learning to Optimize Join Queries With Deep Reinforcement Learning</a><time datetime="2025-05-16T02:17:35.000Z" title="Created 2025-05-16 10:17:35">2025-05-16</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/27248.html" title="Go学习">Go学习</a><time datetime="2025-05-11T03:36:44.000Z" title="Created 2025-05-11 11:36:44">2025-05-11</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By DogDu</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.3</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="Scroll to Comments"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null

  const commentCount = n => {
    const isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
    if (isCommentCount) {
      isCommentCount.textContent= n
    }
  }

  const initGitalk = (el, path) => {
    if (isShuoshuo) {
      window.shuoshuoComment.destroyGitalk = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }

    const gitalk = new Gitalk({
      clientID: 'Ov23lip70wbjDSj3yXVa',
      clientSecret: '229af146a5a288cca20082b54bcaf2ea896347af',
      repo: 'Dog-Du.github.io',
      owner: 'Dog-Du',
      admin: ['Dog-Du'],
      updateCountCallback: commentCount,
      ...option,
      id: (decodeURIComponent(location.pathname)).substring(0, 48),
      distractionFreeMode: false
    })

    gitalk.render('gitalk-container')
  }

  const loadGitalk = async(el, path) => {
    if (typeof Gitalk === 'function') initGitalk(el, path)
    else {
      await btf.getCSS('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css')
      await btf.getScript('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js')
      initGitalk(el, path)
    }
  }

  if (isShuoshuo) {
    'Gitalk' === 'Gitalk'
      ? window.shuoshuoComment = { loadComment: loadGitalk }
      : window.loadOtherComment = loadGitalk
    return
  }

  if ('Gitalk' === 'Gitalk' || !false) {
    if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
    else loadGitalk()
  } else {
    window.loadOtherComment = loadGitalk
  }
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>