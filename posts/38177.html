<!DOCTYPE html><html lang="cn-ZH" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Rust学习 | DogDu's blog</title><meta name="author" content="DogDu"><meta name="copyright" content="DogDu"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="学习Rust基本语法">
<meta property="og:type" content="article">
<meta property="og:title" content="Rust学习">
<meta property="og:url" content="https://dog-du.github.io/posts/38177.html">
<meta property="og:site_name" content="DogDu&#39;s blog">
<meta property="og:description" content="学习Rust基本语法">
<meta property="og:locale" content="cn_ZH">
<meta property="og:image" content="https://dog-du.github.io/img/top_img.jpg">
<meta property="article:published_time" content="2025-05-18T10:44:22.000Z">
<meta property="article:modified_time" content="2025-05-22T01:54:11.959Z">
<meta property="article:author" content="DogDu">
<meta property="article:tag" content="Rust">
<meta property="article:tag" content="学习">
<meta property="article:tag" content="未完成">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://dog-du.github.io/img/top_img.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Rust学习",
  "url": "https://dog-du.github.io/posts/38177.html",
  "image": "https://dog-du.github.io/img/top_img.jpg",
  "datePublished": "2025-05-18T10:44:22.000Z",
  "dateModified": "2025-05-22T01:54:11.959Z",
  "author": [
    {
      "@type": "Person",
      "name": "DogDu",
      "url": "https://dog-du.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/head.jpg"><link rel="canonical" href="https://dog-du.github.io/posts/38177.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":300,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Rust学习',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="alternate" href="/atom.xml" title="DogDu's blog" type="application/atom+xml">
</head><body><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/top_img.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="/img/head.jpg" alt="Logo"><span class="site-name">DogDu's blog</span></a><a class="nav-page-title" href="/"><span class="site-name">Rust学习</span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">Rust学习</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2025-05-18T10:44:22.000Z" title="Created 2025-05-18 18:44:22">2025-05-18</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2025-05-22T01:54:11.959Z" title="Updated 2025-05-22 09:54:11">2025-05-22</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%AD%A6%E4%B9%A0%E7%B1%BB/">学习类</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p><a target="_blank" rel="noopener" href="https://kaisery.github.io/trpl-zh-cn/title-page.html">Rust 程序设计语言 - Rust 程序设计语言 简体中文版</a></p>
<h1 id="常见编程概念"><a class="markdownIt-Anchor" href="#常见编程概念"></a> 常见编程概念</h1>
<h2 id="变量"><a class="markdownIt-Anchor" href="#变量"></a> 变量</h2>
<p><strong>变量</strong></p>
<p>变量默认是不可改变的（immutable）。</p>
<p>在变量前面添加 <code>mut</code> 可以声明其可变。</p>
<p>如：</p>
<p><strong>常量</strong></p>
<p>类似于不可变变量，<em>常量 (constants)</em> 是绑定到一个名称的不允许改变的值，不过常量与变量还是有一些区别。</p>
<p>不允许对常量使用 <code>mut</code>。声明常量使用 <code>const</code> 关键字而不是 <code>let</code>，并且 <em>必须</em> 注明值的类型。常量只能被设置为常量表达式，而不可以是其他任何只能在运行时计算出的值。</p>
<p>如：</p>
<p><code>const THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3;</code></p>
<p>Rust 对常量的命名约定是在单词之间使用全大写加下划线。</p>
<p><strong>遮蔽</strong></p>
<p>可以定义一个与之前变量同名的新变量。称之为第一个变量被第二个 <strong>遮蔽（Shadowing）</strong> 了，这意味着当您使用变量的名称时，编译器将看到第二个变量。</p>
<p>可以用相同变量名称来遮蔽一个变量，以及重复使用 <code>let</code> 关键字来多次遮蔽。</p>
<p>当不小心尝试对变量重新赋值时，如果没有使用 <code>let</code> 关键字，就会导致编译时错误。</p>
<p>通过使用 <code>let</code>，我们可以用这个值进行一些计算，不过计算完之后变量仍然是不可变的。</p>
<p><code>mut</code> 与遮蔽的另一个区别是，当再次使用 <code>let</code> 时，实际上创建了一个新变量，我们可以改变值的类型，并且复用这个名字。</p>
<h2 id="数据类型"><a class="markdownIt-Anchor" href="#数据类型"></a> 数据类型</h2>
<p>Rust 是 <strong>静态类型</strong>（<em>statically typed</em>）语言，也就是说在编译时就必须知道所有变量的类型。根据值及其使用方式，编译器通常可以推断出我们想要用的类型。</p>
<p>当多种类型均有可能时，必须增加类型注解。</p>
<h3 id="标量"><a class="markdownIt-Anchor" href="#标量"></a> 标量</h3>
<p><strong>标量</strong>（<em>scalar</em>）类型代表一个单独的值。Rust 有四种基本的标量类型：整型、浮点型、布尔类型和字符类型。</p>
<p><strong>整型</strong></p>
<p><code>isize</code> 和 <code>usize</code> 类型依赖运行程序的计算机架构：64 位架构上它们是 64 位的，32 位架构上它们是 32 位的。</p>
<p>数字字面值允许使用类型后缀，例如 <code>57u8</code> 来指定类型</p>
<p>允许使用 <code>_</code> 做为分隔符以方便读数</p>
<p>整数溢出：</p>
<p><code>release</code>下不会检测，但是<code>debug</code>下会检测，并抛出<code>panic</code>。</p>
<p><strong>浮点型</strong></p>
<p>默认为 <code>f64</code>，也有 <code>f32</code></p>
<p><strong>数值运算</strong></p>
<p>支持基本数学运算：加法、减法、乘法、除法和取余。整数除法会向零舍入到最接近的整数。</p>
<p><code>    let truncated = -5 / 3; // 结果为 -1</code></p>
<p><strong>布尔类型</strong></p>
<p><code>false</code> 和 <code>true</code></p>
<p><strong>字符类型</strong></p>
<p>Rust 的 <code>char</code> 类型是语言中最原始的字母类型。</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">c</span> = <span class="string">'z'</span>;</span><br><span class="line">   <span class="keyword">let</span> <span class="variable">z</span>: <span class="type">char</span> = <span class="string">'ℤ'</span>; <span class="comment">// with explicit type annotation</span></span><br><span class="line">   <span class="keyword">let</span> <span class="variable">heart_eyed_cat</span> = <span class="string">'😻'</span>;</span><br></pre></td></tr></tbody></table></figure>
<p>单引号声明 <code>char</code> 字面值，而与之相反的是，使用双引号声明字符串字面值。</p>
<p>Rust 的 <code>char</code> 类型的大小为四个字节 (four bytes)，并代表了一个 Unicode 标量值（Unicode Scalar Value），这意味着它可以比 ASCII 表示更多内容。</p>
<h3 id="复合类型"><a class="markdownIt-Anchor" href="#复合类型"></a> 复合类型</h3>
<p><strong>复合类型</strong>（<em>Compound types</em>）可以将多个值组合成一个类型。Rust 有两个原生的复合类型：元组（tuple）和数组（array）。</p>
<p><strong>元组类型</strong></p>
<p>元组是一个将多个不同类型的值组合进一个复合类型的主要方式。</p>
<p>元组长度固定：一旦声明，其长度不会增大或缩小。</p>
<p>元组创建：</p>
<p><code>let tup: (i32, f64, u8) = (500, 6.4, 1);</code></p>
<p>从元组中获取单个值，可以使用模式匹配（pattern matching）来解构（destructure）元组值。</p>
<p><code>let tup = (500, 6.4, 1);</code></p>
<p><code>let (x, y, z) = tup;</code></p>
<p><code>let (x, y, z) = (1, 1.1, 3);</code></p>
<p><code>let</code> 和一个模式将 <code>tup</code> 分成了三个不同的变量，<code>x</code>、<code>y</code> 和 <code>z</code>。这叫做 <strong>解构</strong>（<em>destructuring</em>），因为它将一个元组拆成了三个部分。</p>
<p>访问：使用点号（<code>.</code>）后跟值的索引来直接访问所需的元组元素。</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span>: (<span class="type">i32</span>, <span class="type">f64</span>, <span class="type">u8</span>) = (<span class="number">500</span>, <span class="number">6.4</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">let</span> <span class="variable">five_hundred</span> = x.<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">let</span> <span class="variable">six_point_four</span> = x.<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">let</span> <span class="variable">one</span> = x.<span class="number">2</span>;</span><br></pre></td></tr></tbody></table></figure>
<p>不带任何值的元组有个特殊的名称，叫做 <strong>单元（unit）</strong> 元组。这种值以及对应的类型都写作 <code>()</code>，表示空值或空的返回类型。如果表达式不返回任何其他值，则会隐式返回单元值。</p>
<p><strong>数组类型</strong></p>
<p>与元组不同，数组中的每个元素的类型必须相同。</p>
<p>Rust 中的数组长度是固定的。</p>
<p><code>let a = [1, 2, 3, 4, 5];</code></p>
<p>当你想要在栈（stack）而不是在堆（heap）上为数据分配空间，或者是想要确保总是有固定数量的元素时，数组非常有用。</p>
<p>数组不如 vector 类型灵活。vector 类型是标准库提供的一个 <strong>允许</strong> 增长和缩小长度的类似数组的集合类型。当不确定是应该使用数组还是 vector 的时候，那么很可能应该使用 vector。</p>
<p><code>let months = ["January", "February", "March", "April", "May", "June", "July",              "August", "September", "October", "November", "December"];</code></p>
<p>编写数组的类型：在方括号中包含每个元素的类型，后跟分号，再后跟数组元素的数量。</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">a</span>: [<span class="type">i32</span>; <span class="number">5</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br></pre></td></tr></tbody></table></figure>
<p><strong>访问数组元素</strong></p>
<p>数组是可以在栈 (stack) 上分配的已知固定大小的单个内存块。</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">first</span> = a[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">second</span> = a[<span class="number">1</span>];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong>无效的数组元素访问</strong></p>
<p>程序在索引操作中使用一个无效的值时导致 <strong>运行时</strong> 错误。程序带着错误信息退出。</p>
<p>当尝试用索引访问一个元素时，Rust 会检查指定的索引是否小于数组的长度。</p>
<p>如果索引超出了数组长度，Rust 会 <em>panic</em>。</p>
<p>这种检查必须在运行时进行，特别是在这种情况下，因为编译器不可能知道用户在以后运行代码时将输入什么值。</p>
<p>##　函数</p>
<p><code>fn</code> 关键字，它用来声明新函数。</p>
<p>Rust 代码中的函数和变量名使用 <em>snake case</em> 规范风格。在 snake case 中，所有字母都是小写并使用下划线分隔单词。</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Hello, world!"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">another_function</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">another_function</span>() {</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Another function."</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>源码中 <code>another_function</code> 定义在 <code>main</code> 函数 <strong>之后</strong>；也可以定义在之前。Rust 不关心函数定义所在的位置，只要函数被调用时出现在调用之处可见的作用域内就行。</p>
<p><strong>参数</strong></p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="title function_ invoke__">another_function</span>(<span class="number">5</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">another_function</span>(x: <span class="type">i32</span>) {</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"The value of x is: {x}"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>在函数签名中，<strong>必须</strong> 声明每个参数的类型。</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">print_labeled_measurement</span>(value: <span class="type">i32</span>, unit_label: <span class="type">char</span>) {</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"The measurement is: {value}{unit_label}"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="语句与表达式"><a class="markdownIt-Anchor" href="#语句与表达式"></a> <strong>语句与表达式</strong></h3>
<p>函数体由一系列的语句和一个可选的结尾表达式构成。</p>
<p>Rust 是一门基于表达式（expression-based）的语言。</p>
<ul>
<li><strong>语句</strong>（<em>Statements</em>）是执行一些操作但不返回值的指令。</li>
<li><strong>表达式</strong>（<em>Expressions</em>）计算并产生一个值。</li>
</ul>
<p>函数定义也是语句，<strong>调用</strong>函数并不是语句。</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = (<span class="keyword">let</span> <span class="variable">y</span> = <span class="number">6</span>); <span class="comment">// 报错，let y = 6 是语句而不是表达式</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">y</span> = {</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">3</span>;</span><br><span class="line">        x + <span class="number">1</span></span><br><span class="line">    }; <span class="comment">// 不报错，是语句，因为 x + 1 后面没有加分号;</span></span><br></pre></td></tr></tbody></table></figure>
<p><strong>具有返回值的函数</strong></p>
<p>不对返回值命名，但要在箭头（<code>-&gt;</code>）后声明它的类型。</p>
<p>在 Rust 中，函数的返回值等同于函数体最后一个表达式的值。</p>
<p>使用 <code>return</code> 关键字和指定值，可从函数中提前返回；但大部分函数隐式的返回最后的表达式。</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">five</span>() <span class="punctuation">-&gt;</span> <span class="type">i32</span> {</span><br><span class="line">    <span class="number">5</span></span><br><span class="line">} <span class="comment">// 返回 5 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">five</span>() <span class="punctuation">-&gt;</span> <span class="type">i32</span> {</span><br><span class="line">    <span class="number">5</span>;</span><br><span class="line">} <span class="comment">// 报错，因为有分号; 不是表达式</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="注释"><a class="markdownIt-Anchor" href="#注释"></a> 注释</h2>
<p>用<code>//</code> 会无视该行其后面的内容。</p>
<p>使用 <code>///</code> 可以使用markdown语法。</p>
<h2 id="控制流"><a class="markdownIt-Anchor" href="#控制流"></a> 控制流</h2>
<h3 id="if-else-if-else"><a class="markdownIt-Anchor" href="#if-else-if-else"></a> <strong>if - else if - else</strong></h3>
<p><code>if</code>关键字后面条件<strong>必须</strong>是 <code>bool</code> 值。如果条件不是 <code>bool</code> 值，我们将得到一个错误。</p>
<p>在<code>let</code>中使用：<code>let number = if 3 &gt; 2 { 5 } else { 6 }; </code></p>
<p>当然，和 <code>? :</code>三目运算符一样，必须类型一样。</p>
<p>而且，<code>if</code>语句必须都返回一样的类型。</p>
<p>比如：</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="number">3</span> &gt; <span class="number">2</span> {</span><br><span class="line">	<span class="number">5</span>  <span class="comment">// 返回i32</span></span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">	<span class="number">6</span>; <span class="comment">// 返回()</span></span><br><span class="line">} <span class="comment">// 错误，返回类型不一致。</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="loop-while-for"><a class="markdownIt-Anchor" href="#loop-while-for"></a> <strong>loop、while、for</strong></h3>
<p><strong>loop</strong></p>
<p>无限循环，除非<code>break</code></p>
<p><strong>从循环返回值</strong></p>
<p>在用于停止循环的 <code>break</code> 表达式后添加你希望返回的值；</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">counter</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = <span class="keyword">loop</span> {</span><br><span class="line">        counter += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> counter == <span class="number">10</span> {</span><br><span class="line">            <span class="keyword">break</span> counter * <span class="number">2</span>;</span><br><span class="line">        }</span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"The result is {result}"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong>循环标签：跳出多层循环</strong></p>
<p>如果存在嵌套循环，<code>break</code> 和 <code>continue</code> 应用于此时最内层的循环。你可以选择在一个循环上指定一个 <strong>循环标签</strong>（<em>loop label</em>），然后将标签与 <code>break</code> 或 <code>continue</code> 一起使用，使这些关键字应用于已标记的循环而不是最内层的循环。</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">count</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="symbol">'counting_up</span>: <span class="keyword">loop</span> {</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"count = {count}"</span>);</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">remaining</span> = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">loop</span> {</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"remaining = {remaining}"</span>);</span><br><span class="line">            <span class="keyword">if</span> remaining == <span class="number">9</span> {</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> count == <span class="number">2</span> {</span><br><span class="line">                <span class="keyword">break</span> <span class="symbol">'counting_up</span>;</span><br><span class="line">            }</span><br><span class="line">            remaining -= <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        count += <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"End count = {count}"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong>即使有标签也可以在标签后面添加返回值。</strong></p>
<p>如：<code>break ‘counting_up 123;</code></p>
<p><strong>while</strong></p>
<p>与<code>loop</code>差不多。</p>
<p><strong>for 遍历</strong></p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">element</span> <span class="keyword">in</span> a {</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"the value is: {element}"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>或者使用</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">4</span> { </span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> (<span class="number">0</span>..<span class="number">4</span>).<span class="title function_ invoke__">rev</span>() { <span class="comment">// 从 3 到 0</span></span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h1 id="所有权"><a class="markdownIt-Anchor" href="#所有权"></a> 所有权</h1>
<p><strong>所有权</strong>（<em>ownership</em>）是 Rust 用于如何管理内存的一组规则。</p>
<p>Rust 则选择了第三种方式：通过所有权系统管理内存，编译器在编译时会根据一系列的规则进行检查。如果违反了任何这些规则，程序都不能编译。在运行时，所有权系统的任何功能都不会减慢程序的运行。</p>
<h2 id="栈stack与堆heap"><a class="markdownIt-Anchor" href="#栈stack与堆heap"></a> <a target="_blank" rel="noopener" href="https://kaisery.github.io/trpl-zh-cn/ch04-01-what-is-ownership.html#%E6%A0%88stack%E4%B8%8E%E5%A0%86heap">栈（Stack）与堆（Heap）</a></h2>
<p>跟踪哪部分代码正在使用堆上的哪些数据，最大限度的减少堆上的重复数据的数量，以及清理堆上不再使用的数据确保不会耗尽空间，这些问题正是所有权系统要处理的。一旦理解了所有权，你就不需要经常考虑栈和堆了，不过明白了所有权的主要目的就是管理堆数据，能够帮助解释为什么所有权要以这种方式工作。</p>
<p><strong>所有权规则</strong></p>
<ol>
<li>Rust 中的每一个值都有一个 <strong>所有者</strong>（<em>owner</em>）。</li>
<li>值在任一时刻有且只有一个所有者。</li>
<li>当所有者离开作用域，这个值将被丢弃。</li>
</ol>
<p><strong>变量作用域</strong></p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">{                      <span class="comment">// s 在这里无效，它尚未声明</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="string">"hello"</span>;   <span class="comment">// 从此处起，s 是有效的</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 s</span></span><br><span class="line">}                      <span class="comment">// 此作用域已结束，s 不再有效</span></span><br></pre></td></tr></tbody></table></figure>
<p><strong>String 类型</strong></p>
<p><code>String</code>类型管理被分配到堆上的数据，所以能够存储在编译时未知大小的文本。可以使用 <code>from</code> 函数基于字符串字面值来创建 <code>String</code>。</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"hello"</span>);</span><br><span class="line">s.<span class="title function_ invoke__">push_str</span>(<span class="string">", world!"</span>); <span class="comment">// push_str() 在字符串后追加字面值</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"{s}"</span>); <span class="comment">// 将打印 `hello, world!`</span></span><br></pre></td></tr></tbody></table></figure>
<p><code>String</code> 可变而字面值却不行</p>
<p><strong>内存与分配</strong></p>
<p>Rust 采取了一个不同的策略：内存在拥有它的变量离开作用域后就被自动释放。</p>
<p>当变量离开作用域，Rust 为我们调用一个特殊的函数。这个函数叫做 <a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/ops/trait.Drop.html#tymethod.drop"><code>drop</code></a>可以放置释放内存的代码。Rust 在结尾的 <code>}</code> 处自动调用 <code>drop</code>。类似于<code>RAII</code></p>
<p><strong>移动的变量与数据交互</strong></p>
<p>在 Rust 中，多个变量可以采取不同的方式与同一数据进行交互。</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">y</span> = x;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"hello"</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s2</span> = s1;</span><br></pre></td></tr></tbody></table></figure>
<p><img src="/img/rust%E5%AD%A6%E4%B9%A0/image-20250518203127261.png" alt="image-20250518203127261"></p>
<p>当我们将 <code>s1</code> 赋值给 <code>s2</code>，<code>String</code> 的数据被复制了，这意味着我们从栈上拷贝了它的指针、长度和容量。我们并没有复制指针指向的堆上数据。</p>
<p>这就有了一个问题：当 <code>s2</code> 和 <code>s1</code> 离开作用域，它们都会尝试释放相同的内存。这是一个叫做 <strong>二次释放</strong>（<em>double free</em>）的错误。</p>
<p>为了确保内存安全，在 <code>let s2 = s1;</code> 之后，Rust 认为 <code>s1</code> 不再有效，因此 Rust 不需要在 <code>s1</code> 离开作用域后清理任何东西。</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"hello"</span>);</span><br><span class="line">   <span class="keyword">let</span> <span class="variable">s2</span> = s1;</span><br><span class="line">   <span class="built_in">println!</span>(<span class="string">"{s1} {s2}"</span>); <span class="comment">// 报错，s1被move到s2，s1失效。</span></span><br></pre></td></tr></tbody></table></figure>
<p>这里还隐含了一个设计选择：Rust 永远也不会自动创建数据的 “深拷贝”。因此，任何<strong>自动</strong>的复制都可以被认为是对运行时性能影响较小的。</p>
<p><strong>作用域与赋值</strong></p>
<p>作用域、所有权和通过 <code>drop</code> 函数释放内存之间的关系反过来也同样成立。</p>
<p>当你给一个已有的变量赋一个全新的值时，Rust 将会立即调用 <code>drop</code> 并释放原始值的内存。</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"hello"</span>);</span><br><span class="line">s = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"ahoy"</span>);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"{s}, world!"</span>);</span><br></pre></td></tr></tbody></table></figure>
<p><strong>使用克隆的变量与数据交互</strong></p>
<p>如果我们 <strong>确实</strong> 需要深度复制 <code>String</code> 中堆上的数据，而不仅仅是栈上的数据，可以使用一个叫做 <code>clone</code> 的常用方法。</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"hello"</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s2</span> = s1.<span class="title function_ invoke__">clone</span>();</span><br></pre></td></tr></tbody></table></figure>
<p><strong>只在数据上的数据：拷贝</strong></p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">y</span> = x;</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"x = {x}, y = {y}"</span>);</span><br></pre></td></tr></tbody></table></figure>
<p>原因是像整型这样的在编译时已知大小的类型被整个存储在栈上，所以拷贝其实际的值是快速的。这意味着没有理由在创建变量 <code>y</code> 后使 <code>x</code> 无效。换句话说，这里没有深浅拷贝的区别，所以这里调用 <code>clone</code> 并不会与通常的浅拷贝有什么不同，我们可以不用管它。</p>
<p>Rust 有一个叫做 <code>Copy</code> trait 的特殊注解，可以用在类似整型这样的存储在栈上的类型。如果一个类型实现了 <code>Copy</code> trait，那么一个旧的变量在将其赋值给其他变量后仍然有效。</p>
<p>Rust 不允许自身或其任何部分实现了 <code>Drop</code> trait 的类型使用 <code>Copy</code> trait。如果我们对其值离开作用域时需要特殊处理的类型使用 <code>Copy</code> 注解，将会出现一个编译时错误。要学习如何为你的类型添加 <code>Copy</code> 注解以实现该 trait，请阅读附录 C 中的 <a target="_blank" rel="noopener" href="https://kaisery.github.io/trpl-zh-cn/appendix-03-derivable-traits.html">“可派生的 trait”</a>。</p>
<p>作为一个通用的规则，任何一组简单标量值的组合都可以实现 <code>Copy</code>，任何不需要分配内存或某种形式资源的类型都可以实现 <code>Copy</code> 。如下是一些 <code>Copy</code> 的类型：</p>
<ul>
<li>所有整数类型，比如 <code>u32</code>。</li>
<li>布尔类型，<code>bool</code>，它的值是 <code>true</code> 和 <code>false</code>。</li>
<li>所有浮点数类型，比如 <code>f64</code>。</li>
<li>字符类型，<code>char</code>。</li>
<li>元组，当且仅当其包含的类型也都实现 <code>Copy</code> 的时候。比如，<code>(i32, i32)</code> 实现了 <code>Copy</code>，但 <code>(i32, String)</code> 就没有。</li>
</ul>
<p><strong>所有权和函数</strong></p>
<p>将值传递给函数与给变量赋值的原理相似。向函数传递值可能会移动或者复制，就像赋值语句一样。</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"hello"</span>);  <span class="comment">// s 进入作用域</span></span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">takes_ownership</span>(s);             <span class="comment">// s 的值移动到函数里 ...</span></span><br><span class="line">                                    <span class="comment">// ... 所以到这里不再有效</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;                      <span class="comment">// x 进入作用域</span></span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">makes_copy</span>(x);                  <span class="comment">// x 应该移动函数里，</span></span><br><span class="line">                                    <span class="comment">// 但 i32 是 Copy 的，</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"{}"</span>, x);              <span class="comment">// 所以在后面可继续使用 x</span></span><br><span class="line"></span><br><span class="line">} <span class="comment">// 这里，x 先移出了作用域，然后是 s。但因为 s 的值已被移走，</span></span><br><span class="line">  <span class="comment">// 没有特殊之处</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">takes_ownership</span>(some_string: <span class="type">String</span>) { <span class="comment">// some_string 进入作用域</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"{some_string}"</span>);</span><br><span class="line">} <span class="comment">// 这里，some_string 移出作用域并调用 `drop` 方法。</span></span><br><span class="line">  <span class="comment">// 占用的内存被释放</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">makes_copy</span>(some_integer: <span class="type">i32</span>) { <span class="comment">// some_integer 进入作用域</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"{some_integer}"</span>);</span><br><span class="line">} <span class="comment">// 这里，some_integer 移出作用域。没有特殊之处</span></span><br></pre></td></tr></tbody></table></figure>
<p><strong>返回值与作用域</strong></p>
<p>返回值也可以转移所有权。</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = <span class="title function_ invoke__">gives_ownership</span>();        <span class="comment">// gives_ownership moves its return</span></span><br><span class="line">                                       <span class="comment">// value into s1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s2</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"hello"</span>);    <span class="comment">// s2 comes into scope</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s3</span> = <span class="title function_ invoke__">takes_and_gives_back</span>(s2); <span class="comment">// s2 is moved into</span></span><br><span class="line">                                       <span class="comment">// takes_and_gives_back, which also</span></span><br><span class="line">                                       <span class="comment">// moves its return value into s3</span></span><br><span class="line">} <span class="comment">// Here, s3 goes out of scope and is dropped. s2 was moved, so nothing</span></span><br><span class="line">  <span class="comment">// happens. s1 goes out of scope and is dropped.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">gives_ownership</span>() <span class="punctuation">-&gt;</span> <span class="type">String</span> {       <span class="comment">// gives_ownership will move its</span></span><br><span class="line">                                       <span class="comment">// return value into the function</span></span><br><span class="line">                                       <span class="comment">// that calls it</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">some_string</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"yours"</span>); <span class="comment">// some_string comes into scope</span></span><br><span class="line"></span><br><span class="line">    some_string                        <span class="comment">// some_string is returned and</span></span><br><span class="line">                                       <span class="comment">// moves out to the calling</span></span><br><span class="line">                                       <span class="comment">// function</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该函数将传入字符串并返回该值</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">takes_and_gives_back</span>(a_string: <span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> {</span><br><span class="line">    <span class="comment">// a_string comes into</span></span><br><span class="line">    <span class="comment">// scope</span></span><br><span class="line"></span><br><span class="line">    a_string  <span class="comment">// 返回 a_string 并移出给调用的函数</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>变量的所有权总是遵循相同的模式：将值赋给另一个变量时它会移动。当持有堆中数据值的变量离开作用域时，其值将通过 <code>drop</code> 被清理掉，除非数据被移动为另一个变量所有。</p>
<p>为了不转移所有权就使用变量，Rust 对此提供了一个不用获取所有权就可以使用值的功能，叫做 <strong>引用</strong>（<em>references</em>）。</p>
<h2 id="引用与借用"><a class="markdownIt-Anchor" href="#引用与借用"></a> 引用与借用</h2>
<p><strong>引用</strong>（<em>reference</em>）像一个指针，因为它是一个地址，我们可以由此访问储存于该地址的属于其他变量的数据。与指针不同，引用在其生命周期内保证指向某个特定类型的有效值。</p>
<p>引用：<code>&amp;</code></p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">calculate_length</span>(s: &amp;<span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="type">usize</span> { <span class="comment">// s 是 String 的引用</span></span><br><span class="line">    s.<span class="title function_ invoke__">len</span>()</span><br><span class="line">} <span class="comment">// 这里，s 离开了作用域。但因为它并不拥有引用值的所有权，</span></span><br><span class="line">  <span class="comment">// 所以什么也不会发生</span></span><br></pre></td></tr></tbody></table></figure>
<p>创建一个引用的行为称为 <strong>借用</strong>（<em>borrowing</em>）。</p>
<p>借用结束之后，必须还回去。因为我们并不拥有它的所有权。</p>
<p>同时，借用不允许修改。</p>
<p><strong>可变引用</strong></p>
<p>使用 <code>mut</code> 即可修改借用值，即可变引用。</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"hello"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">change</span>(&amp;<span class="keyword">mut</span> s);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">change</span>(some_string: &amp;<span class="keyword">mut</span> <span class="type">String</span>) {</span><br><span class="line">    some_string.<span class="title function_ invoke__">push_str</span>(<span class="string">", world"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>可变引用有一个很大的限制：如果你有一个对该变量的可变引用，你就不能再创建对该变量的引用。这些尝试创建两个 <code>s</code> 的可变引用的代码会失败。（kora，这不还是独占嘛）</p>
<p>防止同一时间对同一数据存在多个可变引用。</p>
<p>好处是 Rust 可以在编译时就避免数据竞争。<strong>数据竞争</strong>（<em>data race</em>）类似于竞态条件，它可由这三个行为造成：</p>
<ul>
<li>两个或更多指针同时访问同一数据。</li>
<li>至少有一个指针被用来写入数据。</li>
<li>没有同步数据访问的机制。</li>
</ul>
<p>注意一个引用的作用域从声明的地方开始一直持续到<strong>最后一次使用</strong>为止，而不是持续到作用域结束。</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"hello"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">r1</span> = &amp;s; <span class="comment">// 没问题</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">r2</span> = &amp;s; <span class="comment">// 没问题</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"{r1} and {r2}"</span>);</span><br><span class="line"><span class="comment">// 此位置之后 r1 和 r2 不再使用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">r3</span> = &amp;<span class="keyword">mut</span> s; <span class="comment">// 没问题</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"{r3}"</span>);</span><br></pre></td></tr></tbody></table></figure>
<p><strong>悬垂引用（Dangling References）</strong></p>
<p>在具有指针的语言中，很容易通过释放内存时保留指向它的指针而错误地生成一个<strong>悬垂指针</strong>（<em>dangling pointer</em>）—— 指向可能已被分配给其他用途的内存位置的指针。</p>
<p>相比之下，在 Rust 中编译器确保引用永远也不会变成悬垂引用：当你拥有一些数据的引用，编译器确保数据不会在其引用之前离开作用域。</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">reference_to_nothing</span> = <span class="title function_ invoke__">dangle</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">dangle</span>() <span class="punctuation">-&gt;</span> &amp;<span class="type">String</span> {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"hello"</span>);</span><br><span class="line"></span><br><span class="line">    &amp;s</span><br><span class="line">} <span class="comment">// 报错，显然，s 的生命周期结束了。</span></span><br></pre></td></tr></tbody></table></figure>
<p>正确的方法：</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">no_dangle</span>() <span class="punctuation">-&gt;</span> <span class="type">String</span> {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"hello"</span>);</span><br><span class="line"></span><br><span class="line">    s</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong>引用的规则</strong></p>
<p>让我们概括一下之前对引用的讨论：</p>
<ul>
<li>在任意给定时间，<strong>要么</strong>只能有一个可变引用，<strong>要么</strong>只能有多个不可变引用。</li>
<li>引用必须总是有效的。</li>
</ul>
<h2 id="slice-类型"><a class="markdownIt-Anchor" href="#slice-类型"></a> Slice 类型</h2>
<p>slice 是一种引用，不拥有所有权。</p>
<p>考虑题目：写一个函数，该函数接收一个用空格分隔单词的字符串，并返回在该字符串中找到的第一个单词。如果函数在该字符串中并未找到空格，则整个字符串就是一个单词，所以应该返回整个字符串。</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">first_word</span>(s: &amp;<span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="type">usize</span> {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">bytes</span> = s.<span class="title function_ invoke__">as_bytes</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i, &amp;item) <span class="keyword">in</span> bytes.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">enumerate</span>() {</span><br><span class="line">        <span class="keyword">if</span> item == <span class="string">b' '</span> {</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    s.<span class="title function_ invoke__">len</span>()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>这是一个返回单词结尾的索引的函数。</p>
<p>但这不太方便。于是有了切片：</p>
<p><code>[starting_index..ending_index]</code>指定范围，相当于 <code>[first, last]</code></p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"hello world"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">hello</span> = &amp;s[<span class="number">0</span>..<span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">world</span> = &amp;s[<span class="number">6</span>..<span class="number">11</span>]; </span><br></pre></td></tr></tbody></table></figure>
<p>对于 Rust 的 <code>..</code> range 语法，如果想要从索引 0 开始，可以不写两个点号之前的值。</p>
<p>如果 slice 包含最后一个，也可以舍弃尾部的数字。</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"hello"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">slice</span> = &amp;s[<span class="number">0</span>..<span class="number">2</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">slice</span> = &amp;s[..<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">len</span> = s.<span class="title function_ invoke__">len</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">slice</span> = &amp;s[<span class="number">0</span>..len];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">slice</span> = &amp;s[..];</span><br></pre></td></tr></tbody></table></figure>
<p><strong>注意：字符串 slice range 的索引必须位于有效的 UTF-8 字符边界内，如果尝试从一个多字节字符的中间位置创建字符串 slice，则程序将会因错误而退出。</strong></p>
<p><code>String</code>切片的类型为：<code>&amp;str</code></p>
<p><code>[Type;Length]</code>的切片类型为：<code>&amp;[Type]</code></p>
<p>在这种情况下，为了保证引用有效：</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"hello world"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">word</span> = <span class="title function_ invoke__">first_word</span>(&amp;s);</span><br><span class="line"></span><br><span class="line">    s.<span class="title function_ invoke__">clear</span>(); <span class="comment">// 错误！</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"the first word is: {word}"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>当拥有某值的不可变引用时，就不能再获取一个可变引用。</p>
<p>因为 <code>clear(&amp;mut self)</code> 需要清空 <code>String</code>，它尝试获取一个可变引用。</p>
<p>在调用 <code>clear</code> 之后的 <code>println!</code> 使用了 <code>word</code> 中的引用，所以这个不可变的引用在此时必须仍然有效。</p>
<p>Rust 不允许 <code>clear</code> 中的可变引用和 <code>word</code> 中的不可变引用同时存在，因此编译失败。</p>
<p>Rust 不仅使得我们的 API 简单易用，也在编译时就消除了一整类的错误！</p>
<p><strong>字符串字面值就是 slice</strong></p>
<p>这也是为什么字面量不可变的原因，因为她是不可变引用。</p>
<p><strong>字符串 slice 作为参数</strong></p>
<p>比起：<code>fn first_word(s: &amp;String) -&gt; &amp;str</code></p>
<p>用：<code>fn first_word(s: &amp;str) -&gt; &amp;str</code> 更好</p>
<p>如果有一个字符串 slice，可以直接传递它。如果有一个 <code>String</code>，则可以传递整个 <code>String</code> 的 slice 或对 <code>String</code> 的引用。</p>
<p><strong>其他类型的 slice</strong></p>
<p>字符串 slice，正如你想象的那样，是针对字符串的。不过也有更通用的 slice 类型。考虑一下这个数组：</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br></pre></td></tr></tbody></table></figure>
<p>就跟我们想要获取字符串的一部分那样，我们也会想要引用数组的一部分。我们可以这样做：</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">slice</span> = &amp;a[<span class="number">1</span>..<span class="number">3</span>];</span><br><span class="line"><span class="built_in">assert_eq!</span>(slice, &amp;[<span class="number">2</span>, <span class="number">3</span>]);</span><br></pre></td></tr></tbody></table></figure>
<p>这个 slice 的类型是 <code>&amp;[i32]</code>。它跟字符串 slice 的工作方式一样，通过存储第一个集合元素的引用和一个集合总长度。</p>
<h2 id="结构体"><a class="markdownIt-Anchor" href="#结构体"></a> 结构体</h2>
<p>结构体与声明使用：</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">User</span> {</span><br><span class="line">    active: <span class="type">bool</span>,</span><br><span class="line">    username: <span class="type">String</span>,</span><br><span class="line">    email: <span class="type">String</span>,</span><br><span class="line">    sign_in_count: <span class="type">u64</span>,</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">user1</span> = User {</span><br><span class="line">        active: <span class="literal">true</span>,</span><br><span class="line">        username: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"someusername123"</span>),</span><br><span class="line">        email: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"someone@example.com"</span>),</span><br><span class="line">        sign_in_count: <span class="number">1</span>,</span><br><span class="line">    };</span><br><span class="line">    user1.email = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"anotheremail@example.com"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>注意整个实例必须是可变的；Rust 并不允许只将某个字段标记为可变。</p>
<p>可以在函数体的最后一个表达式中构造一个结构体的新实例，来隐式地返回这个实例。</p>
<p>字段初始化简化：</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">build_user</span>(email: <span class="type">String</span>, username: <span class="type">String</span>) <span class="punctuation">-&gt;</span> User {</span><br><span class="line">    User {</span><br><span class="line">        active: <span class="literal">true</span>,</span><br><span class="line">        username: username,</span><br><span class="line">        email: email,</span><br><span class="line">        sign_in_count: <span class="number">1</span>,</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="punctuation">-&gt;</span></span><br><span class="line"><span class="comment">// 只有当当前作用域存在于 field 名字相同的变量才可以这样做，而且要求类型一致。</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">build_user</span>(email: <span class="type">String</span>, username: <span class="type">String</span>) <span class="punctuation">-&gt;</span> User {</span><br><span class="line">    User {</span><br><span class="line">        active: <span class="literal">true</span>,</span><br><span class="line">        username,</span><br><span class="line">        email,</span><br><span class="line">        sign_in_count: <span class="number">1</span>,</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong>从其他实例创建实例</strong></p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">user1</span> = User {</span><br><span class="line">        email: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"someone@example.com"</span>),</span><br><span class="line">        username: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"someusername123"</span>),</span><br><span class="line">        active: <span class="literal">true</span>,</span><br><span class="line">        sign_in_count: <span class="number">1</span>,</span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">user2</span> = User {</span><br><span class="line">        active: user1.active,</span><br><span class="line">        username: user1.username,</span><br><span class="line">        email: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"another@example.com"</span>),</span><br><span class="line">        sign_in_count: user1.sign_in_count,</span><br><span class="line">    };</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> <span class="variable">user2</span> = User {</span><br><span class="line">        email: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"another@example.com"</span>),</span><br><span class="line">        ..user1 <span class="comment">// 用..来省略余下，要求必须放在最后。</span></span><br><span class="line">    };</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>但是结构更新语法就像带有 <code>=</code> 的赋值，因为它移动了数据，至于克隆，则也是一样的。</p>
<p><strong>使用没有命名字段的元组结构体来创建不同的类型</strong></p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Color</span>(<span class="type">i32</span>, <span class="type">i32</span>, <span class="type">i32</span>);</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>(<span class="type">i32</span>, <span class="type">i32</span>, <span class="type">i32</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">black</span> = <span class="title function_ invoke__">Color</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">origin</span> = <span class="title function_ invoke__">Point</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">Color</span>(x,y,z) = black; <span class="comment">// 于元组不同，必须指明类型，才能解构。</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong>没有任何字段的类单元结构体</strong></p>
<p>称为 <strong>类单元结构体</strong>（<em>unit-like structs</em>）因为它们类似于 <code>()</code></p>
<p>常常在你想要在某个类型上实现 trait 但不需要在类型中存储数据的时候发挥作用。</p>
<p>如：</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">AlwaysEqual</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">subject</span> = AlwaysEqual;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>设想我们稍后将为这个类型实现某种行为，使得每个 <code>AlwaysEqual</code> 的实例始终等于任何其它类型的实例，也许是为了获得一个已知的结果以便进行测试。</p>
<p><strong>结构体数据的所有权</strong></p>
<p>可以使结构体存储被其他对象拥有的数据的引用，不过这么做的话需要用上 <strong>生命周期</strong>（<em>lifetimes</em>），这是一个第十章会讨论的 Rust 特性。生命周期确保结构体引用的数据有效性跟结构体本身保持一致。</p>
<h2 id="简单debug"><a class="markdownIt-Anchor" href="#简单debug"></a> 简单Debug</h2>
<p>结构体派生<code>trait</code></p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Rectangle</span> {</span><br><span class="line">    width: <span class="type">u32</span>,</span><br><span class="line">    height: <span class="type">u32</span>,</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rect1</span> = Rectangle {</span><br><span class="line">        width: <span class="number">30</span>,</span><br><span class="line">        height: <span class="number">50</span>,</span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"rect1 is {}"</span>, rect1);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>报错：</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">error[E0277]: `Rectangle` doesn<span class="symbol">'t</span> implement `std::fmt::Display`</span><br><span class="line">= help: the <span class="keyword">trait</span> `std::fmt::Display` is not implemented <span class="keyword">for</span> `Rectangle`</span><br><span class="line">= note: <span class="keyword">in</span> format strings you may be able to <span class="keyword">use</span> `{:?}` (or {:#?} <span class="keyword">for</span> <span class="title class_">pretty</span>-print) instead</span><br></pre></td></tr></tbody></table></figure>
<p><code>{}</code> 默认告诉 <code>println!</code> 使用被称为 <code>Display</code> 的格式，没有实现<code>Disyplay</code>的结构体，将不予输出。</p>
<p>但即使输出方式为：</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">println!</span>(<span class="string">"rect1 is {:?}"</span>, rect1);</span><br></pre></td></tr></tbody></table></figure>
<p>仍然报错：</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">error[E0277]: `Rectangle` doesn<span class="symbol">'t</span> implement `<span class="built_in">Debug</span>`</span><br><span class="line">= help: the <span class="keyword">trait</span> `<span class="built_in">Debug</span>` is not implemented <span class="keyword">for</span> `Rectangle`</span><br><span class="line">= note: add `<span class="meta">#[derive(Debug)]</span>` to `Rectangle` or manually `<span class="keyword">impl</span> <span class="title class_">Debug</span> <span class="keyword">for</span> <span class="title class_">Rectangle</span>`</span><br></pre></td></tr></tbody></table></figure>
<p>正确方式（使用<code>Debug</code> trait）：</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Rectangle</span> {</span><br><span class="line">    width: <span class="type">u32</span>,</span><br><span class="line">    height: <span class="type">u32</span>,</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rect1</span> = Rectangle {</span><br><span class="line">        width: <span class="number">30</span>,</span><br><span class="line">        height: <span class="number">50</span>,</span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"rect1 is {rect1:?}"</span>);</span><br><span class="line">    <span class="comment">// 或者</span></span><br><span class="line">    dbg!(&amp;rect1);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>或者使用<code>dbg!</code>宏。</p>
<p>区别在于<code>dbg!</code>打印到<code>stderr</code>，<code>println!</code>打印到<code>stderr</code></p>
<h1 id="方法"><a class="markdownIt-Anchor" href="#方法"></a> 方法</h1>
<p><strong>方法</strong>（method）与函数类似：它们使用 <code>fn</code> 关键字和名称声明，可以拥有参数和返回值，同时包含在某处调用该方法时会执行的代码。不过方法与函数是不同的，因为它们在结构体的上下文中被定义（或者是枚举或 trait 对象的上下文），并且它们第一个参数总是 <code>self</code>，它代表调用该方法的结构体实例。</p>
<p>如：</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Rectangle</span> {</span><br><span class="line">    width: <span class="type">u32</span>,</span><br><span class="line">    height: <span class="type">u32</span>,</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Rectangle</span> {</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">area</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span> {</span><br><span class="line">        <span class="keyword">self</span>.width * <span class="keyword">self</span>.height</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rect1</span> = Rectangle {</span><br><span class="line">        width: <span class="number">30</span>,</span><br><span class="line">        height: <span class="number">50</span>,</span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(</span><br><span class="line">        <span class="string">"The area of the rectangle is {} square pixels."</span>,</span><br><span class="line">        rect1.<span class="title function_ invoke__">area</span>()</span><br><span class="line">    );</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>为了使函数定义于 <code>Rectangle</code> 的上下文中，我们开始了一个 <code>impl</code> 块（<code>impl</code> 是 <em>implementation</em> 的缩写），这个 <code>impl</code> 块中的所有内容都将与 <code>Rectangle</code> 类型相关联。</p>
<p>方法的第一个参数必须有一个名为 <code>self</code> 的<code>Self</code> 类型的参数，否则不会把方法绑定到类型上，<strong>仅仅是作用域的一个函数而已。</strong></p>
<p>所以 Rust 让你在第一个参数位置上可以只用 <code>self</code> 这个名字来简化。</p>
<p>注意，我们仍然需要在 <code>self</code> 前面使用 <code>&amp;</code> 来表示这个方法借用了 <code>Self</code> 实例，就像我们在 <code>rectangle: &amp;Rectangle</code> 中做的那样。</p>
<p><strong>同时<code>Self</code>仅仅表示类型而已，如果把函数绑定成方法，唯一要做的只是第一个参数名字叫<code>self</code>而已，同时类型一致。在C++中类似于在每个类中 using Self = type;</strong></p>
<p>方法可以选择获得 <code>self</code> 的所有权，或者像我们这里一样不可变地借用 <code>self</code>，或者可变地借用 <code>self</code>，就跟其他参数一样。</p>
<p>方法也是函数，只是绑定到了类型上同时第一个参数为<code>self</code>而已，可以通过：</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Rectangle::<span class="title function_ invoke__">area</span>(&amp;rect1);</span><br></pre></td></tr></tbody></table></figure>
<p>来调用对应方法/函数。</p>
<p>Rust 并没有一个与 <code>-&gt;</code> 等效的运算符；相反，Rust 有一个叫 <strong>自动引用和解引用</strong>（<em>automatic referencing and dereferencing</em>）的功能。方法调用是 Rust 中少数几个拥有这种行为的地方。</p>
<p><strong>关联函数</strong></p>
<p>所有在 <code>impl</code> 块中定义的函数被称为 <strong>关联函数</strong>（<em>associated functions</em>），因为它们与 <code>impl</code> 后面命名的类型相关。我们可以定义不以 <code>self</code> 为第一参数的关联函数（因此不是方法），因为它们并不作用于一个结构体的实例。</p>
<p>不是方法的关联函数经常被用作返回一个结构体新实例的构造函数。这些函数的名称通常为 <code>new</code> ，但 <code>new</code> 并不是一个关键字。这样可以更轻松的创建对象。</p>
<p><strong>多个 impl 块</strong></p>
<p>每个结构体都允许有多个 <code>impl</code>块。</p>
<h2 id="枚举与模式匹配"><a class="markdownIt-Anchor" href="#枚举与模式匹配"></a> 枚举与模式匹配</h2>
<p><strong>定义</strong></p>
<p>如：</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">IpAddrKind</span> {</span><br><span class="line">    V4,</span><br><span class="line">    V6,</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong>枚举值</strong></p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">four</span> = IpAddrKind::V4;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">six</span>: IpAddrKind = IpAddrKind::V6;</span><br></pre></td></tr></tbody></table></figure>
<p>枚举变成了某个类型，而不是一个值。</p>
<p>可以使用一种更简洁的方式来表达相同的概念，仅仅使用枚举并将数据直接放进每一个枚举成员而不是将枚举作为结构体的一部分。<code>IpAddr</code> 枚举的新定义表明了 <code>V4</code> 和 <code>V6</code> 成员都关联了 <code>String</code> 值：</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">IpAddr</span> {</span><br><span class="line">    <span class="title function_ invoke__">V4</span>(<span class="type">String</span>),</span><br><span class="line">    <span class="title function_ invoke__">V6</span>(<span class="type">String</span>),</span><br><span class="line">}</span><br><span class="line"><span class="keyword">let</span> <span class="variable">home</span> = IpAddr::<span class="title function_ invoke__">V4</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"127.0.0.1"</span>));</span><br><span class="line"><span class="keyword">let</span> <span class="variable">loopback</span> = IpAddr::<span class="title function_ invoke__">V6</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"::1"</span>));</span><br></pre></td></tr></tbody></table></figure>
<p>用枚举替代结构体还有另一个优势：每个成员可以处理不同类型和数量的数据。</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">IpAddr</span> {</span><br><span class="line">    <span class="title function_ invoke__">V4</span>(<span class="type">u8</span>, <span class="type">u8</span>, <span class="type">u8</span>, <span class="type">u8</span>),</span><br><span class="line">    <span class="title function_ invoke__">V6</span>(<span class="type">String</span>),</span><br><span class="line">}</span><br><span class="line"><span class="keyword">let</span> <span class="variable">home</span> = IpAddr::<span class="title function_ invoke__">V4</span>(<span class="number">127</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">loopback</span> = IpAddr::<span class="title function_ invoke__">V6</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"::1"</span>));</span><br></pre></td></tr></tbody></table></figure>
<p>更像是存储了类型信息的<code>union</code>共用体。</p>
<p>一个枚举的例子：</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Ipv4Addr</span> {</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Ipv6Addr</span> {</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">IpAddr</span> {</span><br><span class="line">    <span class="title function_ invoke__">V4</span>(Ipv4Addr),</span><br><span class="line">    <span class="title function_ invoke__">V6</span>(Ipv6Addr),</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>使用枚举类型，可以定义一个能够处理这些不同类型的结构体的函数，因为枚举是单独一个类型。</p>
<p>结构体和枚举还有另一个相似点：就像可以使用 <code>impl</code> 来为结构体定义方法那样，也可以在枚举上定义方法。</p>
<p><strong>Option 枚举以及优势</strong></p>
<p>Rust 没有<strong>空值(null)</strong>。</p>
<p>我觉得空与不空是把，数据的状态和数据的值耦合在了一起。</p>
<p>但这种概念本身是没有错误的，错误的是具体实现。</p>
<p>Rust 用 Option 来解决这个问题。</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Option</span>&lt;T&gt; {</span><br><span class="line">    <span class="literal">None</span>,</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(T),</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>因为 <code>Option&lt;T&gt;</code> 和 <code>T</code>（这里 <code>T</code> 可以是任何类型）是不同的类型，编译器不允许像一个肯定有效的值那样使用 <code>Option&lt;T&gt;</code>。这是<code>Option</code>优于<code>null</code>的地方。</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span>: <span class="type">i8</span> = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">y</span>: <span class="type">Option</span>&lt;<span class="type">i8</span>&gt; = <span class="title function_ invoke__">Some</span>(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">sum</span> = x + y; <span class="comment">// 报错。</span></span><br></pre></td></tr></tbody></table></figure>
<p>换句话说，在对 <code>Option&lt;T&gt;</code> 进行运算之前必须将其转换为 <code>T</code>。</p>
<p>通常这能帮助我们捕获到空值最常见的问题之一：假设某值不为空但实际上为空的情况。</p>
<p>也就是说，<code>Option&lt;T&gt;</code>要求程序员必须考虑值是否为空。</p>
<h1 id="match-控制流"><a class="markdownIt-Anchor" href="#match-控制流"></a> match 控制流</h1>
<p>Rust 有一个叫做 <code>match</code> 的极为强大的控制流运算符，它允许我们将一个值与一系列的模式相比较，并根据相匹配的模式执行相应代码。</p>
<p>模式可由字面值、变量、通配符和许多其他内容构成；</p>
<p>值通过 <code>match</code> 的每一个模式，并且在遇到第一个 “符合” 的模式时，值会进入相关联的代码块并在执行中被使用。</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">State</span> {</span><br><span class="line">    A,</span><br><span class="line">    B,</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Coin</span> {</span><br><span class="line">    Penny,</span><br><span class="line">    Nickel,</span><br><span class="line">    Dime,</span><br><span class="line">    <span class="title function_ invoke__">Quarter</span>(State),</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">value_in_cents</span>(coin: Coin) <span class="punctuation">-&gt;</span> <span class="type">u8</span> {</span><br><span class="line">    <span class="keyword">match</span> coin {</span><br><span class="line">        Coin::Penny =&gt; <span class="number">1</span>,</span><br><span class="line">        Coin::Nickel =&gt; <span class="number">5</span>,</span><br><span class="line">        Coin::Dime =&gt; <span class="number">10</span>,</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>这看起来非常像 <code>if</code> 所使用的条件表达式，不过这里有一个非常大的区别：对于 <code>if</code>，表达式必须返回一个布尔值，而这里它可以是任何类型的。</p>
<p><code>match</code> 的分支:</p>
<p>一个分支有两个部分：一个模式和一些代码。</p>
<p>第一个分支的模式是值 <code>Coin::Penny</code> 而之后的 <code>=&gt;</code> 运算符将模式和将要运行的代码分开。这里的代码就仅仅是值 <code>1</code>。每一个分支之间使用逗号分隔。</p>
<p>当 <code>match</code> 表达式执行时，它将结果值按顺序与每一个分支的模式相比较。如果模式匹配了这个值，这个模式相关联的代码将被执行。</p>
<p>当然每个分支也可以是大括号。</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">value_in_cents</span>(coin: Coin) <span class="punctuation">-&gt;</span> <span class="type">u8</span> {</span><br><span class="line">    <span class="keyword">match</span> coin {</span><br><span class="line">        Coin::Penny =&gt; {</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"Lucky penny!"</span>);</span><br><span class="line">            <span class="number">1</span></span><br><span class="line">        }</span><br><span class="line">        Coin::Nickel =&gt; <span class="number">5</span>,</span><br><span class="line">        Coin::Dime =&gt; <span class="number">10</span>,</span><br><span class="line">        Coin::Quarter =&gt; <span class="number">25</span>,</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>也可以绑定对应的值。</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">value_in_cents</span>(coin: Coin) <span class="punctuation">-&gt;</span> <span class="type">u8</span> {</span><br><span class="line">    <span class="keyword">match</span> coin {</span><br><span class="line">        Coin::Penny =&gt; <span class="number">1</span>,</span><br><span class="line">        Coin::Nickel =&gt; <span class="number">5</span>,</span><br><span class="line">        Coin::Dime =&gt; <span class="number">10</span>,</span><br><span class="line">        Coin::<span class="title function_ invoke__">Quarter</span>(state) =&gt; {</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"State quarter from {state:?}!"</span>);</span><br><span class="line">            <span class="number">25</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong>匹配 Option</strong></p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">plus_one</span>(x: <span class="type">Option</span>&lt;<span class="type">i32</span>&gt;) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="type">i32</span>&gt; {</span><br><span class="line">    <span class="keyword">match</span> x {</span><br><span class="line">        <span class="literal">None</span> =&gt; <span class="literal">None</span>,</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(i) =&gt; <span class="title function_ invoke__">Some</span>(i + <span class="number">1</span>),</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">five</span> = <span class="title function_ invoke__">Some</span>(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">six</span> = <span class="title function_ invoke__">plus_one</span>(five);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">none</span> = <span class="title function_ invoke__">plus_one</span>(<span class="literal">None</span>);</span><br></pre></td></tr></tbody></table></figure>
<p><strong>match 匹配是穷尽的</strong></p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">plus_one</span>(x: <span class="type">Option</span>&lt;<span class="type">i32</span>&gt;) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="type">i32</span>&gt; {</span><br><span class="line">    <span class="keyword">match</span> x {</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(i) =&gt; <span class="title function_ invoke__">Some</span>(i + <span class="number">1</span>),</span><br><span class="line">    } <span class="comment">// 不可编译</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong>通用匹配和占位符</strong></p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">dice_roll</span> = <span class="number">9</span>;</span><br><span class="line"><span class="keyword">match</span> dice_roll {</span><br><span class="line">    <span class="number">3</span> =&gt; <span class="title function_ invoke__">add_fancy_hat</span>(),</span><br><span class="line">    <span class="number">7</span> =&gt; <span class="title function_ invoke__">remove_fancy_hat</span>(),</span><br><span class="line">    other =&gt; <span class="title function_ invoke__">move_player</span>(other), <span class="comment">// 这里获取了剩下的所有情况，同时可以使用other来处理</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">add_fancy_hat</span>() {}</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">remove_fancy_hat</span>() {}</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">move_player</span>(num_spaces: <span class="type">u8</span>) {}</span><br></pre></td></tr></tbody></table></figure>
<p>当我们不想使用通配模式获取的值时，请使用 <code>_</code> ，这是一个特殊的模式，可以匹配任意值而不绑定到该值。</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">dice_roll</span> = <span class="number">9</span>;</span><br><span class="line"><span class="keyword">match</span> dice_roll {</span><br><span class="line">    <span class="number">3</span> =&gt; <span class="title function_ invoke__">add_fancy_hat</span>(),</span><br><span class="line">    <span class="number">7</span> =&gt; <span class="title function_ invoke__">remove_fancy_hat</span>(),</span><br><span class="line">    _ =&gt; <span class="title function_ invoke__">reroll</span>(), <span class="comment">// 对于值不关心。</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">add_fancy_hat</span>() {}</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">remove_fancy_hat</span>() {}</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">reroll</span>() {}</span><br></pre></td></tr></tbody></table></figure>
<p><strong>if-let 控制流</strong></p>
<p><code>if let</code> 语法让我们以一种不那么冗长的方式结合 <code>if</code> 和 <code>let</code>，来处理只匹配一个模式的值而忽略其他模式的情况。</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">config_max</span> = <span class="title function_ invoke__">Some</span>(<span class="number">3u8</span>);</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(max) = config_max {</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"The maximum is configured to be {max}"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>这样可以不使用<code>match</code>而仅仅匹配一个情况，剩下的情况并不关心。</p>
<p>可以认为 <code>if let</code> 是 <code>match</code> 的一个语法糖，它当值匹配某一模式时执行代码而忽略所有其他值。</p>
<h1 id="rust-std-集合"><a class="markdownIt-Anchor" href="#rust-std-集合"></a> Rust std 集合</h1>
<h2 id="vectort"><a class="markdownIt-Anchor" href="#vectort"></a> Vector&lt;T&gt;</h2>
<p><strong>新建</strong></p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">v</span>: <span class="type">Vec</span>&lt;<span class="type">i32</span>&gt; = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br></pre></td></tr></tbody></table></figure>
<p>增加了一个类型注解。因为没有向这个 vector 中插入任何值，Rust 并不知道我们想要储存什么类型的元素。</p>
<p>或者：</p>
<p>使用<code>vec!</code>宏，可以推断给定值创建一个<code>vector</code></p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></tbody></table></figure>
<p><strong>更新</strong></p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>(); <span class="comment">// 错误Rust推断不出类型</span></span><br></pre></td></tr></tbody></table></figure>
<p>正确：</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>(); </span><br><span class="line">v.<span class="title function_ invoke__">push</span>(<span class="number">5</span>); <span class="comment">// 通过这句话，Rust推断出类型。</span></span><br></pre></td></tr></tbody></table></figure>
<p><strong>读取</strong></p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">third</span>: &amp;<span class="type">i32</span> = &amp;v[<span class="number">2</span>];</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"The third element is {third}"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">third</span>: <span class="type">Option</span>&lt;&amp;<span class="type">i32</span>&gt; = v.<span class="title function_ invoke__">get</span>(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">match</span> third {</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(third) =&gt; <span class="built_in">println!</span>(<span class="string">"The third element is {third}"</span>),</span><br><span class="line">    <span class="literal">None</span> =&gt; <span class="built_in">println!</span>(<span class="string">"There is no third element."</span>),</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>有两种方法引用 vector 中储存的值：通过索引或使用 <code>get</code> 方法。</p>
<p>Rust 提供了两种引用元素的方法的原因是当尝试使用现有元素范围之外的索引值时可以选择让程序如何运行。</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">does_not_exist</span> = &amp;v[<span class="number">100</span>]; <span class="comment">// panic</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">does_not_exist</span> = v.<span class="title function_ invoke__">get</span>(<span class="number">100</span>); <span class="comment">// None</span></span><br></pre></td></tr></tbody></table></figure>
<p>一旦程序获取了一个有效的引用，借用检查器将会执行所有权和借用规则来确保 vector 内容的这个引用和任何其他引用保持有效。</p>
<p>回忆一下不能在相同作用域中同时存在可变和不可变引用的规则。</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">first</span> = &amp;v[<span class="number">0</span>]; <span class="comment">// 获取一个借用</span></span><br><span class="line">v.<span class="title function_ invoke__">push</span>(<span class="number">6</span>); <span class="comment">// error. 获取一个引用。</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"The first element is: {first}"</span>); </span><br></pre></td></tr></tbody></table></figure>
<p><strong>遍历</strong></p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">100</span>, <span class="number">32</span>, <span class="number">57</span>];</span><br><span class="line"><span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> &amp;v {</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"{i}"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>也可以遍历可变 vector 的每一个元素的可变引用以便能改变它们。</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">100</span>, <span class="number">32</span>, <span class="number">57</span>];</span><br><span class="line">   <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> &amp;<span class="keyword">mut</span> v {</span><br><span class="line">       *i += <span class="number">50</span>;</span><br><span class="line">   }</span><br></pre></td></tr></tbody></table></figure>
<p>因为借用检查器的规则，无论可变还是不可变地遍历一个 vector 都是安全的。</p>
<p><strong>枚举存储多种类型</strong></p>
<p>vector 只能储存相同类型的值。这是很不方便的；绝对会有需要储存一系列不同类型的值的用例。</p>
<p>如：</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">enum</span> <span class="title class_">SpreadsheetCell</span> {</span><br><span class="line">        <span class="title function_ invoke__">Int</span>(<span class="type">i32</span>),</span><br><span class="line">        <span class="title function_ invoke__">Float</span>(<span class="type">f64</span>),</span><br><span class="line">        <span class="title function_ invoke__">Text</span>(<span class="type">String</span>),</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">row</span> = <span class="built_in">vec!</span>[</span><br><span class="line">        SpreadsheetCell::<span class="title function_ invoke__">Int</span>(<span class="number">3</span>),</span><br><span class="line">        SpreadsheetCell::<span class="title function_ invoke__">Text</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"blue"</span>)),</span><br><span class="line">        SpreadsheetCell::<span class="title function_ invoke__">Float</span>(<span class="number">10.12</span>),</span><br><span class="line">    ];</span><br><span class="line"><span class="comment">// 之后再遍历的时候可以使用 match 来枚举。</span></span><br></pre></td></tr></tbody></table></figure>
<p><strong>丢弃 vector 时也会丢弃其所有元素</strong></p>
<h2 id="string-与-utf-8"><a class="markdownIt-Anchor" href="#string-与-utf-8"></a> String 与 UTF-8</h2>
<p>Rust 的核心语言中只有一种字符串类型：字符串 slice <code>str</code>，它通常以被借用的形式出现，<code>&amp;str</code>。</p>
<p><strong>String</strong></p>
<p>字符串（<code>String</code>）类型由 Rust 标准库提供，而不是编入核心语言，它是一种可增长、可变、可拥有、UTF-8 编码的字符串类型。</p>
<p><strong>新建字符串</strong></p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">   <span class="keyword">let</span> <span class="variable">data</span> = <span class="string">"initial contents"</span>;</span><br><span class="line">   <span class="keyword">let</span> <span class="variable">s</span> = data.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line">   <span class="comment">// 该方法也可直接用于字符串字面值：</span></span><br><span class="line">   <span class="keyword">let</span> <span class="variable">s</span> = <span class="string">"initial contents"</span>.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line"><span class="comment">// 字面量创建 String。</span></span><br><span class="line">   <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"initial contents"</span>);</span><br></pre></td></tr></tbody></table></figure>
<p>字符串是 UTF-8 编码的。</p>
<p><strong>更新</strong></p>
<p><code>String</code> 的大小可以增加，其内容也可以改变，就像可以放入更多数据来改变 <code>Vec</code> 的内容一样。</p>
<p>另外，可以方便的使用 <code>+</code> 运算符或 <code>format!</code> 宏来拼接 <code>String</code> 值。</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// push_str 字面量</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"foo"</span>);</span><br><span class="line">    s.<span class="title function_ invoke__">push_str</span>(<span class="string">"bar"</span>);</span><br><span class="line"><span class="comment">// push 字符</span></span><br><span class="line">	s.<span class="title function_ invoke__">push</span>(<span class="string">'c'</span>);</span><br><span class="line"><span class="comment">// push_str String</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"foo"</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s2</span> = <span class="string">"bar"</span>;</span><br><span class="line">    s1.<span class="title function_ invoke__">push_str</span>(s2);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"s2 is {s2}"</span>);</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p><strong>+ 运算符和 format! 宏</strong></p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"Hello, "</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s2</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"world!"</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s3</span> = s1 + &amp;s2; <span class="comment">// 注意 s1 被移动了，不能继续使用</span></span><br></pre></td></tr></tbody></table></figure>
<p>因为<code>add</code>的签名： <code>add(self, s: &amp;str) -&gt; String</code></p>
<p>所以<code>self</code>被移动了，而且<code>&amp;String</code>可以被强制转化为<code>&amp;str</code></p>
<p><strong>强转</strong>（<em>coerced</em>） <strong>Deref 强制转换</strong>（<em>deref coercion</em>）</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"tic"</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s2</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"tac"</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s3</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"toe"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = s1 + <span class="string">"-"</span> + &amp;s2 + <span class="string">"-"</span> + &amp;s3;</span><br></pre></td></tr></tbody></table></figure>
<p>不过这样就显得非常麻烦了，更适合：</p>
<p><code>s = s + &amp;other_string</code>这样效率更好，同时语义易于理解。</p>
<p>或者使用<code>println!</code>宏</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"tic"</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s2</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"tac"</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s3</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"toe"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="built_in">format!</span>(<span class="string">"{s1}-{s2}-{s3}"</span>);</span><br></pre></td></tr></tbody></table></figure>
<p>这个地方全<code>copy</code>，<code>s1,s2,s3</code>是没有被移动的。</p>
<p><strong>索引字符串</strong></p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"hi"</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">h</span> = s1[<span class="number">0</span>]; <span class="comment">// 错误，Rust 的字符串不支持索引。</span></span><br></pre></td></tr></tbody></table></figure>
<p><strong>String 内部表示</strong></p>
<p><code>String</code> 是一个 <code>Vec&lt;u8&gt;</code> 的封装。</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">hello</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"Здравствуйте"</span>);</span><br></pre></td></tr></tbody></table></figure>
<p>当问及这个字符是多长的时候有人可能会说是 12。然而，Rust 的回答是 24。</p>
<p>这是使用 UTF-8 编码 “Здравствуйте” 所需要的字节数，这是因为每个 Unicode 标量值需要两个字节存储。</p>
<p>因此一个字符串字节值的索引并不总是对应一个有效的 Unicode 标量值。</p>
<p>如下无效的 Rust 代码：</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">hello</span> = <span class="string">"Здравствуйте"</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">answer</span> = &amp;hello[<span class="number">0</span>]; <span class="comment">// 拒绝索引。</span></span><br></pre></td></tr></tbody></table></figure>
<p><strong>字节、标量值和字形簇</strong></p>
<p>从 Rust 的角度来讲，事实上有三种相关方式可以理解字符串：字节、标量值和字形簇（最接近人们眼中 <strong>字母</strong> 的概念）。</p>
<p>最后一个 Rust 不允许使用索引获取 <code>String</code> 字符的原因是，索引操作预期总是需要常数时间（O(1)）。但是对于 <code>String</code> 不可能保证这样的性能，因为 Rust 必须从开头到索引位置遍历来确定有多少有效的字符。</p>
<p><strong>字符串 slice</strong></p>
<p>相比使用 <code>[]</code> 和单个值的索引，可以使用 <code>[]</code> 和一个 range 来创建含特定字节的字符串 slice：</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">hello</span> = <span class="string">"Здравствуйте"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = &amp;hello[<span class="number">0</span>..<span class="number">4</span>];</span><br></pre></td></tr></tbody></table></figure>
<p>但是如果：<code>&amp;hello[0..1]</code>，Rust会在运行时panic。</p>
<p>和无效索引一样。</p>
<p><strong>遍历字符串的方法</strong></p>
<p>操作字符串每一部分的最好的方法是明确表示需要字符还是字节。</p>
<p>对于单独的 Unicode 标量值使用 <code>chars</code> 方法。</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="variable">c</span> <span class="keyword">in</span> <span class="string">"Зд"</span>.<span class="title function_ invoke__">chars</span>() {</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"{c}"</span>);</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// З</span></span><br><span class="line"><span class="comment">// д</span></span><br></pre></td></tr></tbody></table></figure>
<p>对于获取原始字节，使用<code>bytes</code>方法</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="variable">b</span> <span class="keyword">in</span> <span class="string">"Зд"</span>.<span class="title function_ invoke__">bytes</span>() {</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"{b}"</span>);</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 208</span></span><br><span class="line"><span class="comment">// 151</span></span><br><span class="line"><span class="comment">// 208</span></span><br><span class="line"><span class="comment">// 180</span></span><br></pre></td></tr></tbody></table></figure>
<p>有效的 Unicode 标量值可能会由不止一个字节组成。</p>
<p>不同的语言选择了不同的向程序员展示其复杂性的方式。Rust 选择了以准确的方式处理 <code>String</code> 数据作为所有 Rust 程序的默认行为，这意味着程序员们必须更多的思考如何预先处理 UTF-8 数据。</p>
<h2 id="hash-map"><a class="markdownIt-Anchor" href="#hash-map"></a> Hash Map</h2>
<p><code>HashMap&lt;K, V&gt;</code> 类型储存了一个键类型 <code>K</code> 对应一个值类型 <code>V</code> 的映射。</p>
<p>它通过一个 <strong>哈希函数</strong>（<em>hashing function</em>）来实现映射，决定如何将键和值放入内存中。</p>
<p><strong>新建</strong></p>
<p>可以使用 <code>new</code> 创建一个空的 <code>HashMap</code>，并使用 <code>insert</code> 增加元素。</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">scores</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line">scores.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"Blue"</span>), <span class="number">10</span>);</span><br><span class="line">scores.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"Yellow"</span>), <span class="number">50</span>);</span><br></pre></td></tr></tbody></table></figure>
<p><strong>访问</strong></p>
<p>通过 <code>get</code> 方法并提供对应的键来从哈希 map 中获取值</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">scores</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">scores.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"Blue"</span>), <span class="number">10</span>);</span><br><span class="line">scores.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"Yellow"</span>), <span class="number">50</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">team_name</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"Blue"</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">score</span> = scores.<span class="title function_ invoke__">get</span>(&amp;team_name).<span class="title function_ invoke__">copied</span>().<span class="title function_ invoke__">unwrap_or</span>(<span class="number">0</span>);</span><br></pre></td></tr></tbody></table></figure>
<p><code>get</code> 方法返回 <code>Option&lt;&amp;V&gt;</code>，如果某个键在哈希 map 中没有对应的值，<code>get</code> 会返回 <code>None</code>。程序中通过调用 <code>copied</code> 方法来获取一个 <code>Option&lt;i32&gt;</code> 而不是 <code>Option&lt;&amp;i32&gt;</code>，接着调用 <code>unwrap_or</code> 在 <code>scores</code> 中没有该键所对应的项时将其设置为零。</p>
<p><strong>遍历</strong></p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">scores</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">scores.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"Blue"</span>), <span class="number">10</span>);</span><br><span class="line">scores.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"Yellow"</span>), <span class="number">50</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (key, value) <span class="keyword">in</span> &amp;scores {</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"{key}: {value}"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>会以任意顺序打印出每一个键值对。</p>
<p>顺序可能会每次都不同。</p>
<p><strong>哈希 map 与所有权</strong></p>
<p>对于像 <code>i32</code> 这样的实现了 <code>Copy</code> trait 的类型，其值可以拷贝进哈希 map。</p>
<p>对于像 <code>String</code> 这样拥有所有权的值，其值将被移动而哈希 map 会成为这些值的所有者。</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">field_name</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"Favorite color"</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">field_value</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"Blue"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">map</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line">map.<span class="title function_ invoke__">insert</span>(field_name, field_value);</span><br><span class="line"><span class="comment">// 这里 field_name 和 field_value 不再有效，</span></span><br><span class="line"><span class="comment">// 尝试使用它们看看会出现什么编译错误！</span></span><br></pre></td></tr></tbody></table></figure>
<p>如果将值的引用插入哈希 map，这些值本身将不会被移动进哈希 map。</p>
<p>但是这些引用指向的值必须至少在哈希 map 有效时也是有效的。</p>
<p><strong>更新</strong></p>
<p>当我们想要改变哈希 map 中的数据时，必须决定如何处理一个键已经有值了的情况。</p>
<p>可以选择完全无视旧值并用新值代替旧值。</p>
<p>可以选择保留旧值而忽略新值，并只在键 <strong>没有</strong> 对应值时增加新值。</p>
<p>可以结合新旧两值。</p>
<p>覆盖：insert</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scores.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"Blue"</span>), <span class="number">10</span>);</span><br><span class="line">scores.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"Blue"</span>), <span class="number">25</span>); <span class="comment">// 结果为 25</span></span><br></pre></td></tr></tbody></table></figure>
<p>用 insert 插入会覆盖。</p>
<p>忽略新值：entry().or_insert()</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scores.<span class="title function_ invoke__">entry</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"Yellow"</span>)).<span class="title function_ invoke__">or_insert</span>(<span class="number">50</span>);</span><br><span class="line">scores.<span class="title function_ invoke__">entry</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"Blue"</span>)).<span class="title function_ invoke__">or_insert</span>(<span class="number">50</span>);</span><br></pre></td></tr></tbody></table></figure>
<p><code>Entry</code> 的 <code>or_insert</code> 方法在键对应的值存在时就返回这个值的可变引用，如果不存在则将参数作为新值插入并返回新值的可变引用。</p>
<p>这比编写自己的逻辑要简明的多，另外也与借用检查器结合得更好。</p>
<p>根据旧值更新：</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面代码用来统计 text 中的单词 ：</span></span><br><span class="line">	<span class="keyword">let</span> <span class="variable">text</span> = <span class="string">"hello world wonderful world"</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">map</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// split_whitespace() 表示按照空格分隔 text 字符串并获取 slice。</span></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">word</span> <span class="keyword">in</span> text.<span class="title function_ invoke__">split_whitespace</span>() {</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">count</span> = map.<span class="title function_ invoke__">entry</span>(word).<span class="title function_ invoke__">or_insert</span>(<span class="number">0</span>);</span><br><span class="line">        *count += <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"{map:?}"</span>);</span><br></pre></td></tr></tbody></table></figure>
<p><strong>哈希函数</strong></p>
<p><code>HashMap</code> 默认使用一种叫做 <code>SipHash</code> 的哈希函数，它可以抵御涉及哈希表的拒绝服务（Denial of Service, DoS）攻击。然而这并不是可用的最快的算法，不过为了更高的安全性值得付出一些性能的代价。</p>
<h1 id="包"><a class="markdownIt-Anchor" href="#包"></a> 包</h1>
<h2 id="基本概念"><a class="markdownIt-Anchor" href="#基本概念"></a> 基本概念</h2>
<ul>
<li><strong>包</strong>（<em>Packages</em>）：Cargo 的一个功能，它允许你构建、测试和分享 crate。</li>
<li><strong>Crates</strong> ：一个模块的树形结构，它形成了库或可执行文件项目。</li>
<li><strong>模块</strong>（<em>Modules</em>）和 <strong>use</strong>：允许你控制作用域和路径的私有性。</li>
<li><strong>路径</strong>（<em>path</em>）：一个为例如结构体、函数或模块等项命名的方式。</li>
</ul>
<p>crate 是 Rust 在编译时最小的代码单位。即使你用 <code>rustc</code> 而不是 <code>cargo</code> 来编译一个单独的源代码文件，编译器还是会将那个文件视为一个 crate。</p>
<p>crate 可以包含模块，模块可以定义在其他文件，然后和 crate 一起编译。</p>
<p>crate 有两种形式：二进制 crate 和库 crate。</p>
<p><strong>二进制 crate</strong>（<em>Binary crates</em>）可以被编译为可执行程序，比如命令行程序或者服务端。它们必须有一个名为 <code>main</code> 函数来定义当程序被执行的时候所需要做的事情。</p>
<p><strong>库 crate</strong>（<em>Library crates</em>）并没有 <code>main</code> 函数，它们也不会编译为可执行程序。相反它们定义了可供多个项目复用的功能模块。与其他语言的库 library 概念一致。</p>
<p><em>crate root</em> 是一个源文件，Rust 编译器以它为起始点，并构成 crate 的根模块。</p>
<p><em>包</em>（<em>package</em>）是提供一系列功能的一个或者多个 crate的捆绑。一个包会包含一个 <em>Cargo.toml</em> 文件，阐述如何去构建这些 crate。</p>
<p>Cargo 实际上就是一个包，它包含了用于构建你代码的命令行工具的二进制 crate。</p>
<p>其他项目也依赖 Cargo 库来实现与 Cargo 命令行程序一样的逻辑。</p>
<p>包中可以包含至多一个库 crate(library crate)。</p>
<p>包中可以包含任意多个二进制 crate(binary crate)，但是必须至少包含一个 crate（无论是库的还是二进制的）。</p>
<h2 id="定义模块"><a class="markdownIt-Anchor" href="#定义模块"></a> 定义模块</h2>
<p>模块、路径、<code>use</code>关键词和<code>pub</code>关键词如何在编译器中工作，以及大部分开发者如何组织他们的代码。</p>
<ul>
<li><strong>从 crate 根节点开始</strong>: 当编译一个 crate, 编译器首先在 crate 根文件（通常，对于一个库 crate 而言是 <em>src/lib.rs</em>，对于一个二进制 crate 而言是 <em>src/main.rs</em>）中寻找需要被编译的代码。</li>
<li><strong>声明模块</strong>: 在 crate 根文件中，你可以声明一个新模块；比如，用 <code>mod garden;</code> 声明了一个叫做 <code>garden</code> 的模块。编译器会在下列路径中寻找模块代码：
<ul>
<li>内联，用大括号替换 <code>mod garden</code> 后跟的分号</li>
<li>在文件 <em>src/garden.rs</em></li>
<li>在文件 <em>src/garden/mod.rs</em></li>
</ul>
</li>
<li><strong>声明子模块</strong>: 在除了 crate 根节点以外的任何文件中，你可以定义子模块。比如，你可能在 <em>src/garden.rs</em> 中声明 <code>mod vegetables;</code>。编译器会在以父模块命名的目录中寻找子模块代码：
<ul>
<li>内联，直接在 <code>mod vegetables</code> 后方不是一个分号而是一个大括号</li>
<li>在文件 <em>src/garden/vegetables.rs</em></li>
<li>在文件 <em>src/garden/vegetables/mod.rs</em></li>
</ul>
</li>
</ul>
<ul>
<li><strong>模块中的代码路径</strong>: 一旦一个模块是你 crate 的一部分，你可以在隐私规则允许的前提下，从同一个 crate 内的任意地方，通过代码路径引用该模块的代码。举例而言，一个 garden vegetables 模块下的 <code>Asparagus</code> 类型可以通过 <code>crate::garden::vegetables::Asparagus</code> 访问。</li>
<li><strong>私有 vs 公用</strong>: 一个模块里的代码默认对其父模块私有。为了使一个模块公用，应当在声明时使用 <code>pub mod</code> 替代 <code>mod</code>。为了使一个公用模块内部的成员公用，应当在声明前使用<code>pub</code>。</li>
<li><strong><code>use</code> 关键字</strong>: 在一个作用域内，<code>use</code>关键字创建了一个项的快捷方式，用来减少长路径的重复。在任何可以引用 <code>crate::garden::vegetables::Asparagus</code> 的作用域，你可以通过 <code>use crate::garden::vegetables::Asparagus;</code> 创建一个快捷方式，然后你就可以在作用域中只写 <code>Asparagus</code> 来使用该类型。</li>
</ul>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">backyard</span><br><span class="line">├── Cargo.lock</span><br><span class="line">├── Cargo.toml</span><br><span class="line">└── src</span><br><span class="line">    ├── garden</span><br><span class="line">    │&nbsp;&nbsp; └── vegetables.rs</span><br><span class="line">    ├── garden.rs</span><br><span class="line">    └── main.rs</span><br></pre></td></tr></tbody></table></figure>
<h2 id="模块中对代码分组"><a class="markdownIt-Anchor" href="#模块中对代码分组"></a> 模块中对代码分组</h2>
<p><em>模块</em> 让我们可以将一个 crate 中的代码进行分组，以提高可读性与重用性。</p>
<p>因为一个模块中的代码默认是私有的，所以还可以利用模块控制项的 <em>私有性</em>。</p>
<p>私有项是不可为外部使用的内在详细实现。我们也可以将模块和它其中的项标记为公开的，这样，外部代码就可以使用并依赖于它们。</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> front_of_house {</span><br><span class="line">    <span class="keyword">mod</span> hosting {</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">add_to_waitlist</span>() {}</span><br><span class="line"></span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">seat_at_table</span>() {}</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">mod</span> serving {</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">take_order</span>() {}</span><br><span class="line"></span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">serve_order</span>() {}</span><br><span class="line"></span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">take_payment</span>() {}</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>我们定义一个模块，是以 <code>mod</code> 关键字为起始，然后指定模块的名字（本例中叫做 <code>front_of_house</code>），并且用花括号包围模块的主体。</p>
<p>在模块内，我们还可以定义其他的模块，就像本例中的 <code>hosting</code> 和 <code>serving</code> 模块。</p>
<p>模块还可以保存一些定义的其他项，比如结构体、枚举、常量、特性、或者函数。</p>
<p><code>src/main.rs</code> 和 <code>src/lib.rs</code> 叫做 crate 根。之所以这样叫它们是因为这两个文件的内容都分别在 crate 模块结构的根组成了一个名为 <code>crate</code> 的模块，该结构被称为 <em>模块树</em>（<em>module tree</em>）。</p>
<p>如：</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">crate</span></span><br><span class="line"> └── front_of_house</span><br><span class="line">     ├── hosting</span><br><span class="line">     │   ├── add_to_waitlist</span><br><span class="line">     │   └── seat_at_table</span><br><span class="line">     └── serving</span><br><span class="line">         ├── take_order</span><br><span class="line">         ├── serve_order</span><br><span class="line">         └── take_payment</span><br></pre></td></tr></tbody></table></figure>
<h2 id="引用模块的路径"><a class="markdownIt-Anchor" href="#引用模块的路径"></a> 引用模块的路径</h2>
<p>为了调用一个函数，我们需要知道它的路径。</p>
<p>路径有两种形式：</p>
<ul>
<li><strong>绝对路径</strong>（<em>absolute path</em>）是以 crate 根（root）开头的全路径；对于外部 crate 的代码，是以 crate 名开头的绝对路径，对于当前 crate 的代码，则以字面值 <code>crate</code> 开头。</li>
<li><strong>相对路径</strong>（<em>relative path</em>）从当前模块开始，以 <code>self</code>、<code>super</code> 或定义在当前模块中的标识符开头。</li>
</ul>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> front_of_house {</span><br><span class="line">    <span class="keyword">mod</span> hosting {</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">add_to_waitlist</span>() {}</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">eat_at_restaurant</span>() {</span><br><span class="line">    <span class="comment">// 绝对路径</span></span><br><span class="line">    crate::front_of_house::hosting::<span class="title function_ invoke__">add_to_waitlist</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 相对路径</span></span><br><span class="line">    front_of_house::hosting::<span class="title function_ invoke__">add_to_waitlist</span>();</span><br><span class="line">} <span class="comment">// 不可编译！！！！因为hosting模块不是 pub 的。</span></span><br></pre></td></tr></tbody></table></figure>
<p>父模块中的项不能使用子模块中的私有项，但是子模块中的项可以使用它们父模块中的项。</p>
<p>这是因为子模块封装并隐藏了它们的实现详情，但是子模块可以看到它们定义的上下文。</p>
<p>因为<code>eat_at_restaurant</code>和<code>front_of_house</code>定义在同一个模块下，所以可以访问<code>front_of_house</code></p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> front_of_house {</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">mod</span> hosting {</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">add_to_waitlist</span>() {}</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">eat_at_restaurant</span>() {</span><br><span class="line">    <span class="comment">// 绝对路径</span></span><br><span class="line">    crate::front_of_house::hosting::<span class="title function_ invoke__">add_to_waitlist</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 相对路径</span></span><br><span class="line">    front_of_house::hosting::<span class="title function_ invoke__">add_to_waitlist</span>();</span><br><span class="line">} <span class="comment">// 不可编译！！！add_to_waitlist()不是pub的</span></span><br></pre></td></tr></tbody></table></figure>
<p>在 <code>mod hosting</code> 前添加了 <code>pub</code> 关键字，使其变成公有的。伴随着这种变化，如果我们可以访问 <code>front_of_house</code>，那我们也可以访问 <code>hosting</code>。</p>
<p>但是 <code>hosting</code> 的 <em>内容</em>（<em>contents</em>）仍然是私有的；这表明使模块公有并不使其内容也是公有的。模块上的 <code>pub</code> 关键字只允许其父模块引用它，而不允许访问内部代码。</p>
<p>因为模块是一个容器，只是将模块变为公有能做的其实并不太多；同时需要更深入地选择将一个或多个项变为公有。</p>
<p>私有性规则不但应用于模块，还应用于结构体、枚举、函数和方法。</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> front_of_house {</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">mod</span> hosting {</span><br><span class="line">        <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">add_to_waitlist</span>() {}</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">eat_at_restaurant</span>() {</span><br><span class="line">    <span class="comment">// 绝对路径</span></span><br><span class="line">    crate::front_of_house::hosting::<span class="title function_ invoke__">add_to_waitlist</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 相对路径</span></span><br><span class="line">    front_of_house::hosting::<span class="title function_ invoke__">add_to_waitlist</span>();</span><br><span class="line">} <span class="comment">// 正确！！。</span></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">二进制和库 <span class="keyword">crate</span> 包的最佳实践：</span><br><span class="line">我们提到过包（package）可以同时包含一个 src/main.rs 二进制 <span class="keyword">crate</span> 根和一个 src/lib.rs 库 <span class="keyword">crate</span> 根，并且这两个 <span class="keyword">crate</span> 默认以包名来命名。通常，这种包含二进制 <span class="keyword">crate</span> 和库 <span class="keyword">crate</span> 的模式的包，在二进制 <span class="keyword">crate</span> 中只保留足以生成一个可执行文件的代码，并由可执行文件调用库 <span class="keyword">crate</span> 的代码。又因为库 <span class="keyword">crate</span> 可以共享，这使得其它项目从包提供的大部分功能中受益。</span><br><span class="line"></span><br><span class="line">模块树应该定义在 src/lib.rs 中。这样通过以包名开头的路径，公有项就可以在二进制 <span class="keyword">crate</span> 中使用。二进制 <span class="keyword">crate</span> 就变得同其它在该 <span class="keyword">crate</span> 之外的、使用库 <span class="keyword">crate</span> 的用户一样：二者都只能使用公有 API。</span><br></pre></td></tr></tbody></table></figure>
<h2 id="super-开始的相对路径"><a class="markdownIt-Anchor" href="#super-开始的相对路径"></a> super 开始的相对路径</h2>
<p>通过在路径的开头使用 <code>super</code> ，从父模块开始构建相对路径，而不是从当前模块或者 crate 根开始。这类似以 <code>..</code> 语法开始一个文件系统路径。</p>
<p>使用 <code>super</code> 允许我们引用父模块中的已知项，这使得重新组织模块树变得更容易 —— 当模块与父模块关联的很紧密，但某天父模块可能要移动到模块树的其它位置。</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">deliver_order</span>() {}</span><br><span class="line"></span><br><span class="line"><span class="keyword">mod</span> back_of_house {</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fix_incorrect_order</span>() {</span><br><span class="line">        <span class="title function_ invoke__">cook_order</span>();</span><br><span class="line">        super::<span class="title function_ invoke__">deliver_order</span>(); <span class="comment">// 从上一级开始搜索。</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">cook_order</span>() {}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="创建公用结构体与枚举类型"><a class="markdownIt-Anchor" href="#创建公用结构体与枚举类型"></a> 创建公用结构体与枚举类型</h2>
<p>如果我们在一个结构体定义的前面使用了 <code>pub</code> ，这个结构体会变成公有的，但是这个结构体的字段仍然是私有的。</p>
<p>我们可以根据情况决定每个字段是否公有。</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> back_of_house {</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Breakfast</span> {</span><br><span class="line">        <span class="keyword">pub</span> toast: <span class="type">String</span>,      <span class="comment">// 字段可见。</span></span><br><span class="line">        seasonal_fruit: <span class="type">String</span>, <span class="comment">// 字段不可见。</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">impl</span> <span class="title class_">Breakfast</span> {</span><br><span class="line">        <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">summer</span>(toast: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> Breakfast {</span><br><span class="line">            Breakfast {</span><br><span class="line">                toast: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(toast),</span><br><span class="line">                seasonal_fruit: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"peaches"</span>),</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">eat_at_restaurant</span>() {</span><br><span class="line">    <span class="comment">// 在夏天订购一个黑麦土司作为早餐</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">meal</span> = back_of_house::Breakfast::<span class="title function_ invoke__">summer</span>(<span class="string">"Rye"</span>);</span><br><span class="line">    <span class="comment">// 改变主意更换想要面包的类型</span></span><br><span class="line">    meal.toast = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"Wheat"</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"I'd like {} toast please"</span>, meal.toast);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果取消下一行的注释代码不能编译；</span></span><br><span class="line">    <span class="comment">// 不允许查看或修改早餐附带的季节水果</span></span><br><span class="line">    meal.seasonal_fruit = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"blueberries"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>相反，如果我们将枚举设为公有，则它的所有成员都将变为公有。</p>
<p>只需要在 <code>enum</code> 关键字前面加上 <code>pub</code></p>
<p>如果枚举成员不是公有的，那么枚举会显得用处不大；</p>
<p>给枚举的所有成员挨个添加 <code>pub</code> 是很令人恼火的，因此枚举成员默认就是公有的。</p>
<h2 id="use-引入作用域"><a class="markdownIt-Anchor" href="#use-引入作用域"></a> use 引入作用域</h2>
<p>在作用域中增加 <code>use</code> 和路径类似于在文件系统中创建软连接（符号连接，symbolic link）。</p>
<p>通过在 crate 根增加 <code>use crate::front_of_house::hosting</code>，现在 <code>hosting</code> 在作用域中就是有效的名称了，如同 <code>hosting</code> 模块被定义于 crate 根一样。</p>
<p>通过 <code>use</code> 引入作用域的路径也会检查私有性，同其它路径一样。</p>
<p>注意 <code>use</code> 只能创建 <code>use</code> 所在的特定作用域内的短路径。</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> front_of_house {</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">mod</span> hosting {</span><br><span class="line">        <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">add_to_waitlist</span>() {}</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> crate::front_of_house::hosting;</span><br><span class="line"></span><br><span class="line"><span class="keyword">mod</span> customer {</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">eat_at_restaurant</span>() {</span><br><span class="line">        hosting::<span class="title function_ invoke__">add_to_waitlist</span>();</span><br><span class="line">    }</span><br><span class="line">} <span class="comment">// 不能编译，因为eat_at_restaurant()所在模块customer没有使用use。</span></span><br><span class="line"><span class="comment">// 需要把mod curtomer {} 删除。</span></span><br></pre></td></tr></tbody></table></figure>
<p>##　创建惯用的 use 路径</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> front_of_house {</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">mod</span> hosting {</span><br><span class="line">        <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">add_to_waitlist</span>() {}</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> crate::front_of_house::hosting::add_to_waitlist;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">eat_at_restaurant</span>() {</span><br><span class="line">    <span class="title function_ invoke__">add_to_waitlist</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>这样也正确，但是不符合习惯。因为没有清晰的指出函数是从哪里调用来的。</p>
<p>另一方面，使用 <code>use</code> 引入结构体、枚举和其他项时，习惯是指定它们的完整路径。</p>
<h2 id="使用-as-提供新的名字"><a class="markdownIt-Anchor" href="#使用-as-提供新的名字"></a> 使用 as 提供新的名字</h2>
<p>用 as 重命名防止两个相同名字的类型引入同一个作用域，</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt::<span class="type">Result</span>;</span><br><span class="line"><span class="keyword">use</span> std::io::<span class="type">Result</span> <span class="keyword">as</span> IoResult;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">function1</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span> {</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">function2</span>() <span class="punctuation">-&gt;</span> IoResult&lt;()&gt; {</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="用pub-use重导出名称"><a class="markdownIt-Anchor" href="#用pub-use重导出名称"></a> 用pub use重导出名称</h2>
<p>使用 <code>use</code> 关键字，将某个名称导入当前作用域后，这个名称在此作用域中就可以使用了，但它对此作用域之外还是私有的。</p>
<p>如果想让其他人调用我们的代码时，也能够正常使用这个名称，就好像它本来就在当前作用域一样，那我们可以将 <code>pub</code> 和 <code>use</code> 合起来使用。</p>
<p>这种技术被称为 “<em>重导出</em>（<em>re-exporting</em>）”：我们不仅将一个名称导入了当前作用域，还允许别人把它导入他们自己的作用域。</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> front_of_house {</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">mod</span> hosting {</span><br><span class="line">        <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">add_to_waitlist</span>() {}</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">use</span> crate::front_of_house::hosting;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">eat_at_restaurant</span>() {</span><br><span class="line">    hosting::<span class="title function_ invoke__">add_to_waitlist</span>();</span><br><span class="line">} </span><br></pre></td></tr></tbody></table></figure>
<p>现在这个 <code>pub use</code> 从根模块重导出了 <code>hosting</code> 模块，外部代码现在可以使用路径 <code>restaurant::hosting::add_to_waitlist</code>。</p>
<h2 id="使用外部包"><a class="markdownIt-Anchor" href="#使用外部包"></a> 使用外部包</h2>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Cargo.toml</span></span><br><span class="line">[dependencies]</span><br><span class="line">rand = <span class="string">"0.8.5"</span></span><br></pre></td></tr></tbody></table></figure>
<p>在 <em>Cargo.toml</em> 中加入 <code>rand</code> 依赖告诉了 Cargo 要从 <a target="_blank" rel="noopener" href="https://crates.io/">crates.io</a> 下载 <code>rand</code> 和其依赖，并使其可在项目代码中使用。</p>
<p>比如：</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> rand::Rng;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">secret_number</span> = rand::<span class="title function_ invoke__">thread_rng</span>().<span class="title function_ invoke__">gen_range</span>(<span class="number">1</span>..=<span class="number">100</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="嵌套路径消除-use"><a class="markdownIt-Anchor" href="#嵌套路径消除-use"></a> 嵌套路径消除 use</h2>
<p>当需要引入很多定义于相同包或相同模块的项时，为每一项单独列出一行会占用源码很大的空间。</p>
<p>可以使用嵌套路径将相同的项在一行中引入作用域。这么做需要指定路径的相同部分，接着是两个冒号，接着是大括号中的各自不同的路径部分。</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::cmp::Ordering;</span><br><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"><span class="comment">// 优化之后：</span></span><br><span class="line"><span class="keyword">use</span> std::{cmp::Ordering, io};</span><br></pre></td></tr></tbody></table></figure>
<p>比如：</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"><span class="keyword">use</span> std::io::Write;</span><br><span class="line"><span class="comment">// =&gt;</span></span><br><span class="line"><span class="keyword">use</span> std::io::{<span class="keyword">self</span>, Write};</span><br><span class="line"><span class="comment">// 这一行便将 std::io 和 std::io::Write 同时引入作用域。</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="用-glob-将所有共有定义引入作用域"><a class="markdownIt-Anchor" href="#用-glob-将所有共有定义引入作用域"></a> 用 glob 将所有共有定义引入作用域。</h2>
<p>如果希望将一个路径下 <strong>所有</strong> 公有项引入作用域，可以指定路径后跟 <code>*</code>，glob 运算符：</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::*;</span><br></pre></td></tr></tbody></table></figure>
<p>用 glob 运算符时请多加小心！Glob 会使得我们难以推导作用域中有什么名称和它们是在何处定义的。</p>
<p>glob 运算符经常用于测试模块 <code>tests</code> 中，这时会将所有内容引入作用域；</p>
<h1 id="错误处理"><a class="markdownIt-Anchor" href="#错误处理"></a> 错误处理</h1>
<p>Rust 将错误分为两大类：<strong>可恢复的</strong>（<em>recoverable</em>）和 <strong>不可恢复的</strong>（<em>unrecoverable</em>）错误。</p>
<p>对于一个可恢复的错误，比如文件未找到的错误，我们很可能只想向用户报告问题并重试操作。</p>
<p>不可恢复的错误总是 bug 出现的征兆，比如试图访问一个超过数组末端的位置，因此我们要立即停止程序。</p>
<p>Rust 没有异常。相反，它有 <code>Result&lt;T, E&gt;</code> 类型，用于处理可恢复的错误，还有 <code>panic!</code> 宏，在程序遇到不可恢复的错误时停止执行。</p>
<h2 id="panic-处理不可恢复错误"><a class="markdownIt-Anchor" href="#panic-处理不可恢复错误"></a> panic! 处理不可恢复错误</h2>
<p>Rust 有 <code>panic!</code>宏。在实践中有两种方法造成 panic：执行会造成代码 panic 的操作（比如访问超过数组结尾的内容）或者显式调用 <code>panic!</code> 宏。</p>
<p>这两种情况都会使程序 panic。</p>
<p>通常情况下这些 panic 会打印出一个错误信息，展开并清理栈数据，然后退出。</p>
<p>通过一个环境变量，你也可以让 Rust 在 panic 发生时打印调用堆栈（call stack）以便于定位 panic 的原因。</p>
<p><strong><a target="_blank" rel="noopener" href="https://kaisery.github.io/trpl-zh-cn/ch09-01-unrecoverable-errors-with-panic.html#%E5%AF%B9%E5%BA%94-panic-%E6%97%B6%E7%9A%84%E6%A0%88%E5%B1%95%E5%BC%80%E6%88%96%E7%BB%88%E6%AD%A2">对应 panic 时的栈展开或终止</a></strong></p>
<p>当出现 panic 时，程序默认会开始 <strong>展开</strong>（<em>unwinding</em>），这意味着 Rust 会回溯栈并清理它遇到的每一个函数的数据，不过这个回溯并清理的过程有很多工作。另一种选择是直接 <strong>终止</strong>（<em>abort</em>），这会不清理数据就退出程序。</p>
<p>那么程序所使用的内存需要由操作系统来清理。如果你需要项目的最终二进制文件越小越好，panic 时通过在 <em>Cargo.toml</em> 的 <code>[profile]</code> 部分增加 <code>panic = 'abort'</code>，可以由展开切换为终止。</p>
<p>例如，如果你想要在 release 模式中 panic 时直接终止：</p>
<figure class="highlight toml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[profile.release]</span></span><br><span class="line"><span class="attr">panic</span> = <span class="string">'abort'</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="使用-panic-的-backtrace"><a class="markdownIt-Anchor" href="#使用-panic-的-backtrace"></a> 使用 panic! 的 backtrace</h2>
<p>比如，当索引超出数组范围时。会出现panic。</p>
<p>可以在运行时：<code>RUST_BACKTRACE=1 cargo run</code>来获取panic时的堆栈情况。</p>
<p>为了获取带有这些信息的 backtrace，必须启用 debug 标识。</p>
<p>Rust 的 backtrace 跟其他语言中的一样：阅读 backtrace 的关键是从头开始读直到发现你编写的文件。</p>
<p>##　Result 处理可恢复错误</p>
<p><code>Result</code> 枚举，它定义有如下两个成员，<code>Ok</code> 和 <code>Err</code>：</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Result</span>&lt;T, E&gt; {</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(T),</span><br><span class="line">    <span class="title function_ invoke__">Err</span>(E),</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><code>T</code> 和 <code>E</code> 是泛型类型参数；</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">greeting_file_result</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">"hello.txt"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><code>File::open</code> 的返回值是 <code>Result&lt;T, E&gt;</code>。</p>
<p>泛型参数 <code>T</code> 会被 <code>File::open</code> 的实现放入成功返回值的类型 <code>std::fs::File</code>，这是一个文件句柄。</p>
<p>错误返回值使用的 <code>E</code> 的类型是 <code>std::io::Error</code>。</p>
<p>这些返回类型意味着 <code>File::open</code> 调用可能成功并返回一个可以读写的文件句柄。这个函数调用也可能会失败：例如，也许文件不存在，或者可能没有权限访问这个文件。</p>
<p><code>File::open</code> 函数需要一个方法在告诉我们成功与否的同时返回文件句柄或者错误信息。这些信息正好是 <code>Result</code> 枚举所代表的。</p>
<p>当 <code>File::open</code> 成功时，<code>greeting_file_result</code> 变量将会是一个包含文件句柄的 <code>Ok</code> 实例。</p>
<p>当失败时，<code>greeting_file_result</code> 变量将会是一个包含了更多关于发生了何种错误的信息的 <code>Err</code> 实例。</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">greeting_file_result</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">"hello.txt"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">greeting_file</span> = <span class="keyword">match</span> greeting_file_result {</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(file) =&gt; file,</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(error) =&gt; <span class="built_in">panic!</span>(<span class="string">"Problem opening the file: {error:?}"</span>),</span><br><span class="line">    }; <span class="comment">// 处理枚举</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong>匹配不同的错误</strong></p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">use</span> std::io::ErrorKind;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">greeting_file_result</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">"hello.txt"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">greeting_file</span> = <span class="keyword">match</span> greeting_file_result {</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(file) =&gt; file,</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(error) =&gt; <span class="keyword">match</span> error.<span class="title function_ invoke__">kind</span>() {</span><br><span class="line">            ErrorKind::NotFound =&gt; <span class="keyword">match</span> File::<span class="title function_ invoke__">create</span>(<span class="string">"hello.txt"</span>) {</span><br><span class="line">                <span class="title function_ invoke__">Ok</span>(fc) =&gt; fc,</span><br><span class="line">                <span class="title function_ invoke__">Err</span>(e) =&gt; <span class="built_in">panic!</span>(<span class="string">"Problem creating the file: {e:?}"</span>),</span><br><span class="line">            },</span><br><span class="line">            _ =&gt; {</span><br><span class="line">                <span class="built_in">panic!</span>(<span class="string">"Problem opening the file: {error:?}"</span>);</span><br><span class="line">            }</span><br><span class="line">        },</span><br><span class="line">    };</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong>失败时 panic 的简写：unwrap 和 expect</strong></p>
<p><code>esult&lt;T, E&gt;</code> 类型定义了很多辅助方法来处理各种情况。</p>
<p>其中之一叫做 <code>unwrap</code>，它的实现就类似于 <code>match</code> 语句。</p>
<p>如果 <code>Result</code> 值是成员 <code>Ok</code>，<code>unwrap</code> 会返回 <code>Ok</code> 中的值。</p>
<p>如果 <code>Result</code> 是成员 <code>Err</code>，<code>unwrap</code> 会为我们调用 <code>panic!</code>。</p>
<p>例子：</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">greeting_file</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">"hello.txt"</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>还有另一个类似于 <code>unwrap</code> 的方法它还允许我们选择 <code>panic!</code> 的错误信息：<code>expect</code>。</p>
<p>使用 <code>expect</code> 而不是 <code>unwrap</code> 并提供一个好的错误信息可以表明你的意图并更易于追踪 panic 的根源。</p>
<p><code>expect</code> 的语法看起来像这样：</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">greeting_file</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">"hello.txt"</span>)</span><br><span class="line">        .<span class="title function_ invoke__">expect</span>(<span class="string">"hello.txt should be included in this project"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong>传播错误</strong></p>
<p>当编写一个其实先会调用一些可能会失败的操作的函数时，除了在这个函数中处理错误外，还可以选择让调用者知道这个错误并决定该如何处理。</p>
<p>这被称为 <strong>传播</strong>（<em>propagating</em>）错误，这样能更好的控制代码调用，因为比起你代码所拥有的上下文，调用者可能拥有更多信息或逻辑来决定应该如何处理错误。</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">use</span> std::io::{<span class="keyword">self</span>, Read};</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">read_username_from_file</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">String</span>, io::Error&gt; {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">username_file_result</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">"hello.txt"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">username_file</span> = <span class="keyword">match</span> username_file_result {</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(file) =&gt; file,</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(e) =&gt; <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(e),</span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">username</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> username_file.<span class="title function_ invoke__">read_to_string</span>(&amp;<span class="keyword">mut</span> username) {</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(_) =&gt; <span class="title function_ invoke__">Ok</span>(username),</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(e) =&gt; <span class="title function_ invoke__">Err</span>(e),</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>这种传播错误的模式在 Rust 是如此的常见，以至于 Rust 提供了 <code>?</code> 问号运算符来使其更易于处理。</p>
<h2 id="传播错误简写运算符"><a class="markdownIt-Anchor" href="#传播错误简写运算符"></a> 传播错误简写：？运算符</h2>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">use</span> std::io::{<span class="keyword">self</span>, Read};</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">read_username_from_file</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">String</span>, io::Error&gt; {</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">username_file</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">"hello.txt"</span>)?;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">username</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    username_file.<span class="title function_ invoke__">read_to_string</span>(&amp;<span class="keyword">mut</span> username)?;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(username)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><code>Result</code> 值之后的 <code>?</code> 被定义为与示例 9-6 中定义的处理 <code>Result</code> 值的 <code>match</code> 表达式有着完全相同的工作方式。</p>
<p>如果 <code>Result</code> 的值是 <code>Ok</code>，这个表达式将会返回 <code>Ok</code> 中的值而程序将继续执行。</p>
<p>如果值是 <code>Err</code>，<code>Err</code> 将作为整个函数的返回值，就好像使用了 <code>return</code> 关键字一样，这样错误值就被传播给了调用者。</p>
<p>甚至可以在 <code>?</code> 之后直接使用链式方法调用来进一步缩短代码：</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">use</span> std::io::{<span class="keyword">self</span>, Read};</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">read_username_from_file</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">String</span>, io::Error&gt; {</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">username</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">    File::<span class="title function_ invoke__">open</span>(<span class="string">"hello.txt"</span>)?.<span class="title function_ invoke__">read_to_string</span>(&amp;<span class="keyword">mut</span> username)?;</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(username)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong>哪里可以使用 ？运算符</strong></p>
<p><code>?</code> 运算符只能被用于返回值与 <code>?</code> 作用的值相兼容的函数。因为 <code>?</code> 运算符被定义为从函数中提早返回一个值，这与 <code>match</code> 表达式有着完全相同的工作方式。</p>
<p><code>match</code> 作用于一个 <code>Result</code> 值，提早返回的分支返回了一个 <code>Err(e)</code> 值。函数的返回值必须是 <code>Result</code> 才能与这个 <code>return</code> 相兼容。</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">greeting_file</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">"hello.txt"</span>)?;</span><br><span class="line">} <span class="comment">// 错误，只能返回 Result</span></span><br></pre></td></tr></tbody></table></figure>
<p><code>?</code> 也可用于 <code>Option&lt;T&gt;</code> 值。如同对 <code>Result</code> 使用 <code>?</code> 一样，只能在返回 <code>Option</code> 的函数中对 <code>Option</code> 使用 <code>?</code>。</p>
<p>在 <code>Option&lt;T&gt;</code> 上调用 <code>?</code> 运算符的行为与 <code>Result&lt;T, E&gt;</code> 类似：如果值是 <code>None</code>，此时 <code>None</code> 会从函数中提前返回。</p>
<p>如果值是 <code>Some</code>，<code>Some</code> 中的值作为表达式的返回值同时函数继续。</p>
<p><code>main</code> 函数也可以返回 <code>Result&lt;(), E&gt;</code>。</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::error::Error;</span><br><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), <span class="type">Box</span>&lt;<span class="keyword">dyn</span> Error&gt;&gt; {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">greeting_file</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">"hello.txt"</span>)?;</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><code>main</code> 函数也可以返回任何实现了 <a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/process/trait.Termination.html"><code>std::process::Termination</code> trait</a> 的类型，它包含了一个返回 <code>ExitCode</code> 的 <code>report</code> 函数。</p>
<h2 id="要不要panic"><a class="markdownIt-Anchor" href="#要不要panic"></a> 要不要panic</h2>
<p><strong>示例、代码原型和测试都非常适合 panic</strong></p>
<p>测试失败的时候，直接panic以结束程序。</p>
<p><strong>当我们比编译器知道更多的情况</strong></p>
<p>当你有一些其他的逻辑来确保 <code>Result</code> 会是 <code>Ok</code> 值时，调用 <code>unwrap</code> 或者 <code>expect</code> 也是合适的，虽然编译器无法理解这种逻辑。你仍然需要处理一个 <code>Result</code> 值：即使在你的特定情况下逻辑上是不可能的，你所调用的任何操作仍然有可能失败。</p>
<p><strong>错误处理指导原则</strong></p>
<p>在当有可能会导致有害状态的情况下建议使用 <code>panic!</code></p>
<p>然而当错误预期会出现时，返回 <code>Result</code> 仍要比调用 <code>panic!</code> 更为合适。</p>
<p><strong>创建自定义类型进行有效性验证</strong></p>
<p>在每个函数中正确性的检查将是非常冗余的（并可能潜在的影响性能）。</p>
<p>相反我们可以创建一个新类型来将验证放入创建其实例的函数中，而不是到处重复这些检查。这样就可以安全地在函数签名中使用新类型并相信它们接收到的值。</p>
<p>比如：</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Guess</span> {</span><br><span class="line">    value: <span class="type">i32</span>,</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Guess</span> {</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(value: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> Guess {</span><br><span class="line">        <span class="keyword">if</span> value &lt; <span class="number">1</span> || value &gt; <span class="number">100</span> {</span><br><span class="line">            <span class="built_in">panic!</span>(<span class="string">"Guess value must be between 1 and 100, got {value}."</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        Guess { value }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">value</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> {</span><br><span class="line">        <span class="keyword">self</span>.value</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h1 id="泛型-trait-和生命周期"><a class="markdownIt-Anchor" href="#泛型-trait-和生命周期"></a> 泛型、Trait 和生命周期</h1>
<p>泛型允许我们使用一个可以代表多种类型的占位符来替换特定类型，以此来减少代码冗余。让算法与类型分离。</p>
<h2 id="泛型"><a class="markdownIt-Anchor" href="#泛型"></a> 泛型</h2>
<p><strong>泛型函数</strong></p>
<p>使用泛型为像函数签名或结构体这样的项创建定义，这样它们就可以用于多种不同的具体数据类型。</p>
<p>为了参数化这个新函数中的这些类型，我们需要为类型参数命名。</p>
<p>Rust 类型名的命名规范是首字母大写驼峰式命名法（UpperCamelCase）。</p>
<p>为了定义泛型函数，类型参数声明位于函数名称与参数列表中间的尖括号 <code>&lt;&gt;</code> 中，像这样：<code>fn largest&lt;T&gt;(list: &amp;[T]) -&gt; &amp;T </code></p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">largest</span>&lt;T&gt;(list: &amp;[T]) <span class="punctuation">-&gt;</span> &amp;T {</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">largest</span> = &amp;list[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">item</span> <span class="keyword">in</span> list {</span><br><span class="line">        <span class="keyword">if</span> item &gt; largest {</span><br><span class="line">            largest = item;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    largest</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">number_list</span> = <span class="built_in">vec!</span>[<span class="number">34</span>, <span class="number">50</span>, <span class="number">25</span>, <span class="number">100</span>, <span class="number">65</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">largest</span>(&amp;number_list);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"The largest number is {result}"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">char_list</span> = <span class="built_in">vec!</span>[<span class="string">'y'</span>, <span class="string">'m'</span>, <span class="string">'a'</span>, <span class="string">'q'</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">largest</span>(&amp;char_list);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"The largest char is {result}"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>上面代码无法编译。</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">error[E0369]: binary operation `&gt;` cannot be applied to <span class="keyword">type</span> `&amp;T`</span><br><span class="line"> -<span class="punctuation">-&gt;</span> src/main.rs:<span class="number">5</span>:<span class="number">17</span></span><br><span class="line">  |</span><br><span class="line"><span class="number">5</span> |         <span class="keyword">if</span> item &gt; largest {</span><br><span class="line">  |            ---- ^ ------- &amp;T</span><br><span class="line">  |            |</span><br><span class="line">  |            &amp;T</span><br><span class="line">  |</span><br><span class="line">help: consider restricting <span class="keyword">type</span> <span class="title class_">parameter</span> `T` with <span class="keyword">trait</span> `<span class="built_in">PartialOrd</span>`</span><br><span class="line">  |</span><br><span class="line"><span class="number">1</span> | <span class="keyword">fn</span> <span class="title function_">largest</span>&lt;T: std::cmp::<span class="built_in">PartialOrd</span>&gt;(list: &amp;[T]) <span class="punctuation">-&gt;</span> &amp;T {</span><br><span class="line">  |             ++++++++++++++++++++++</span><br><span class="line"></span><br><span class="line">For more information about this error, <span class="keyword">try</span> `rustc --explain E0369`.</span><br><span class="line">error: could not compile `chapter10` (bin <span class="string">"chapter10"</span>) due to <span class="number">1</span> previous error</span><br></pre></td></tr></tbody></table></figure>
<p>这个错误表明 <code>largest</code> 的函数体不能适用于 <code>T</code> 的所有可能的类型。因为在函数体需要比较 <code>T</code> 类型的值，不过它只能用于我们知道如何排序的类型。</p>
<p><strong>泛型结构体</strong></p>
<p>同样也可以用 <code>&lt;&gt;</code> 语法来定义结构体，它包含一个或多个泛型参数类型字段。</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>&lt;T&gt; {</span><br><span class="line">    x: T,</span><br><span class="line">    y: T,</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">integer</span> = Point { x: <span class="number">5</span>, y: <span class="number">10</span> };</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">float</span> = Point { x: <span class="number">1.0</span>, y: <span class="number">4.0</span> };</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong>泛型枚举</strong></p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Result</span>&lt;T, E&gt; {</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(T),</span><br><span class="line">    <span class="title function_ invoke__">Err</span>(E),</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong>泛型方法</strong></p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>&lt;T&gt; {</span><br><span class="line">    x: T,</span><br><span class="line">    y: T,</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Point&lt;T&gt; {</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">x</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;T {</span><br><span class="line">        &amp;<span class="keyword">self</span>.x</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p</span> = Point { x: <span class="number">5</span>, y: <span class="number">10</span> };</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"p.x = {}"</span>, p.<span class="title function_ invoke__">x</span>());</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>必须在 <code>impl</code> 后面声明 <code>T</code>，这样就可以在 <code>Point&lt;T&gt;</code> 上实现的方法中使用 <code>T</code> 了。</p>
<p>通过在 <code>impl</code> 之后声明泛型 <code>T</code>，Rust 就知道 <code>Point</code> 的尖括号中的类型是泛型而不是具体类型。</p>
<p>定义方法时也可以为泛型指定限制（constraint）。</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Point</span>&lt;<span class="type">f32</span>&gt; {</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">distance_from_origin</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">f32</span> {</span><br><span class="line">        (<span class="keyword">self</span>.x.<span class="title function_ invoke__">powi</span>(<span class="number">2</span>) + <span class="keyword">self</span>.y.<span class="title function_ invoke__">powi</span>(<span class="number">2</span>)).<span class="title function_ invoke__">sqrt</span>()</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>结构体定义中的泛型类型参数并不总是与结构体方法签名中使用的泛型是同一类型。</p>
<p>比如：</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>&lt;X1, Y1&gt; {</span><br><span class="line">    x: X1,</span><br><span class="line">    y: Y1,</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;X1, Y1&gt; Point&lt;X1, Y1&gt; {</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">mixup</span>&lt;X2, Y2&gt;(<span class="keyword">self</span>, other: Point&lt;X2, Y2&gt;) <span class="punctuation">-&gt;</span> Point&lt;X1, Y2&gt; {</span><br><span class="line">        Point {</span><br><span class="line">            x: <span class="keyword">self</span>.x,</span><br><span class="line">            y: other.y,</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p1</span> = Point { x: <span class="number">5</span>, y: <span class="number">10.4</span> };</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p2</span> = Point { x: <span class="string">"Hello"</span>, y: <span class="string">'c'</span> };</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p3</span> = p1.<span class="title function_ invoke__">mixup</span>(p2);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"p3.x = {}, p3.y = {}"</span>, p3.x, p3.y);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>类型的混合。</p>
<p><strong>泛型的性能</strong></p>
<p>Rust 通过在编译时进行泛型代码的<strong>单态化</strong>（<em>monomorphization</em>）来保证效率。</p>
<p>单态化是一个通过填充编译时使用的具体类型，将通用代码转换为特定代码的过程。</p>
<p>泛型并不会使程序比具体类型运行得慢。</p>
<p>泛型 被编译器替换为了具体的定义。</p>
<p>因为 Rust 会将每种情况下的泛型代码编译为具体类型，使用泛型没有运行时开销。</p>
<p>当代码运行时，它的执行效率就跟好像手写每个具体定义的重复代码一样。</p>
<p>这个单态化过程正是 Rust 泛型在运行时极其高效的原因。</p>
<h2 id="trait定义共同行为"><a class="markdownIt-Anchor" href="#trait定义共同行为"></a> Trait：定义共同行为</h2>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="https://Dog-Du.github.io">DogDu</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="https://dog-du.github.io/posts/38177.html">https://dog-du.github.io/posts/38177.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Rust/">Rust</a><a class="post-meta__tags" href="/tags/%E5%AD%A6%E4%B9%A0/">学习</a><a class="post-meta__tags" href="/tags/%E6%9C%AA%E5%AE%8C%E6%88%90/">未完成</a></div><div class="post-share"><div class="social-share" data-image="/img/top_img.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related full-width" href="/posts/8921.html" title="读论文-Learning to Optimize Join Queries With Deep Reinforcement Learning"><img class="cover" src="/img/top_img.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">Previous</div><div class="info-item-2">读论文-Learning to Optimize Join Queries With Deep Reinforcement Learning</div></div><div class="info-2"><div class="info-item-1">读论文-Learning to Optimize Join Queries With Deep Reinforcement Learning</div></div></div></a></nav><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> Comments</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/head.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">DogDu</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">19</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">17</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">2</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Dog-Du"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is DogDu's Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%BC%96%E7%A8%8B%E6%A6%82%E5%BF%B5"><span class="toc-text"> 常见编程概念</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%98%E9%87%8F"><span class="toc-text"> 变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text"> 数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E9%87%8F"><span class="toc-text"> 标量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E5%90%88%E7%B1%BB%E5%9E%8B"><span class="toc-text"> 复合类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%AD%E5%8F%A5%E4%B8%8E%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text"> 语句与表达式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E9%87%8A"><span class="toc-text"> 注释</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E6%B5%81"><span class="toc-text"> 控制流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#if-else-if-else"><span class="toc-text"> if - else if - else</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#loop-while-for"><span class="toc-text"> loop、while、for</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%89%80%E6%9C%89%E6%9D%83"><span class="toc-text"> 所有权</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%88stack%E4%B8%8E%E5%A0%86heap"><span class="toc-text"> 栈（Stack）与堆（Heap）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E4%B8%8E%E5%80%9F%E7%94%A8"><span class="toc-text"> 引用与借用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#slice-%E7%B1%BB%E5%9E%8B"><span class="toc-text"> Slice 类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-text"> 结构体</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E5%8D%95debug"><span class="toc-text"> 简单Debug</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%96%B9%E6%B3%95"><span class="toc-text"> 方法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE%E4%B8%8E%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D"><span class="toc-text"> 枚举与模式匹配</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#match-%E6%8E%A7%E5%88%B6%E6%B5%81"><span class="toc-text"> match 控制流</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#rust-std-%E9%9B%86%E5%90%88"><span class="toc-text"> Rust std 集合</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#vectort"><span class="toc-text"> Vector&lt;T&gt;</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#string-%E4%B8%8E-utf-8"><span class="toc-text"> String 与 UTF-8</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#hash-map"><span class="toc-text"> Hash Map</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8C%85"><span class="toc-text"> 包</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-text"> 基本概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E6%A8%A1%E5%9D%97"><span class="toc-text"> 定义模块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97%E4%B8%AD%E5%AF%B9%E4%BB%A3%E7%A0%81%E5%88%86%E7%BB%84"><span class="toc-text"> 模块中对代码分组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E6%A8%A1%E5%9D%97%E7%9A%84%E8%B7%AF%E5%BE%84"><span class="toc-text"> 引用模块的路径</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#super-%E5%BC%80%E5%A7%8B%E7%9A%84%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%BE%84"><span class="toc-text"> super 开始的相对路径</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%85%AC%E7%94%A8%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B"><span class="toc-text"> 创建公用结构体与枚举类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#use-%E5%BC%95%E5%85%A5%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-text"> use 引入作用域</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-as-%E6%8F%90%E4%BE%9B%E6%96%B0%E7%9A%84%E5%90%8D%E5%AD%97"><span class="toc-text"> 使用 as 提供新的名字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8pub-use%E9%87%8D%E5%AF%BC%E5%87%BA%E5%90%8D%E7%A7%B0"><span class="toc-text"> 用pub use重导出名称</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%A4%96%E9%83%A8%E5%8C%85"><span class="toc-text"> 使用外部包</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B5%8C%E5%A5%97%E8%B7%AF%E5%BE%84%E6%B6%88%E9%99%A4-use"><span class="toc-text"> 嵌套路径消除 use</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8-glob-%E5%B0%86%E6%89%80%E6%9C%89%E5%85%B1%E6%9C%89%E5%AE%9A%E4%B9%89%E5%BC%95%E5%85%A5%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-text"> 用 glob 将所有共有定义引入作用域。</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86"><span class="toc-text"> 错误处理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#panic-%E5%A4%84%E7%90%86%E4%B8%8D%E5%8F%AF%E6%81%A2%E5%A4%8D%E9%94%99%E8%AF%AF"><span class="toc-text"> panic! 处理不可恢复错误</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-panic-%E7%9A%84-backtrace"><span class="toc-text"> 使用 panic! 的 backtrace</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%A0%E6%92%AD%E9%94%99%E8%AF%AF%E7%AE%80%E5%86%99%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text"> 传播错误简写：？运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A6%81%E4%B8%8D%E8%A6%81panic"><span class="toc-text"> 要不要panic</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B-trait-%E5%92%8C%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-text"> 泛型、Trait 和生命周期</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B"><span class="toc-text"> 泛型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#trait%E5%AE%9A%E4%B9%89%E5%85%B1%E5%90%8C%E8%A1%8C%E4%B8%BA"><span class="toc-text"> Trait：定义共同行为</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Posts</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/38177.html" title="Rust学习">Rust学习</a><time datetime="2025-05-18T10:44:22.000Z" title="Created 2025-05-18 18:44:22">2025-05-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/8921.html" title="读论文-Learning to Optimize Join Queries With Deep Reinforcement Learning">读论文-Learning to Optimize Join Queries With Deep Reinforcement Learning</a><time datetime="2025-05-16T02:17:35.000Z" title="Created 2025-05-16 10:17:35">2025-05-16</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/27248.html" title="Go学习">Go学习</a><time datetime="2025-05-11T03:36:44.000Z" title="Created 2025-05-11 11:36:44">2025-05-11</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By DogDu</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.3</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="Scroll to Comments"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null

  const commentCount = n => {
    const isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
    if (isCommentCount) {
      isCommentCount.textContent= n
    }
  }

  const initGitalk = (el, path) => {
    if (isShuoshuo) {
      window.shuoshuoComment.destroyGitalk = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }

    const gitalk = new Gitalk({
      clientID: 'Ov23lip70wbjDSj3yXVa',
      clientSecret: '229af146a5a288cca20082b54bcaf2ea896347af',
      repo: 'Dog-Du.github.io',
      owner: 'Dog-Du',
      admin: ['Dog-Du'],
      updateCountCallback: commentCount,
      ...option,
      id: (decodeURIComponent(location.pathname)).substring(0, 48),
      distractionFreeMode: false
    })

    gitalk.render('gitalk-container')
  }

  const loadGitalk = async(el, path) => {
    if (typeof Gitalk === 'function') initGitalk(el, path)
    else {
      await btf.getCSS('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css')
      await btf.getScript('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js')
      initGitalk(el, path)
    }
  }

  if (isShuoshuo) {
    'Gitalk' === 'Gitalk'
      ? window.shuoshuoComment = { loadComment: loadGitalk }
      : window.loadOtherComment = loadGitalk
    return
  }

  if ('Gitalk' === 'Gitalk' || !false) {
    if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
    else loadGitalk()
  } else {
    window.loadOtherComment = loadGitalk
  }
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>