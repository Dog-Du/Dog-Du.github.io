<!DOCTYPE html><html lang="cn-ZH" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>读论文-Architecture of a Database System | DogDu's blog</title><meta name="author" content="DogDu"><meta name="copyright" content="DogDu"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="英语很差，看论文很费解，但是看了一下作者居然有 Stonebraker，这下耐着性子慢慢读这 119 页了。整体上是一个笔记。">
<meta property="og:type" content="article">
<meta property="og:title" content="读论文-Architecture of a Database System">
<meta property="og:url" content="https://dog-du.github.io/posts/8453.html">
<meta property="og:site_name" content="DogDu&#39;s blog">
<meta property="og:description" content="英语很差，看论文很费解，但是看了一下作者居然有 Stonebraker，这下耐着性子慢慢读这 119 页了。整体上是一个笔记。">
<meta property="og:locale" content="cn_ZH">
<meta property="og:image" content="https://dog-du.github.io/img/top_img.jpg">
<meta property="article:published_time" content="2025-03-27T08:37:49.000Z">
<meta property="article:modified_time" content="2025-04-05T14:01:12.042Z">
<meta property="article:author" content="DogDu">
<meta property="article:tag" content="数据库">
<meta property="article:tag" content="论文">
<meta property="article:tag" content="未完成">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://dog-du.github.io/img/top_img.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "读论文-Architecture of a Database System",
  "url": "https://dog-du.github.io/posts/8453.html",
  "image": "https://dog-du.github.io/img/top_img.jpg",
  "datePublished": "2025-03-27T08:37:49.000Z",
  "dateModified": "2025-04-05T14:01:12.042Z",
  "author": [
    {
      "@type": "Person",
      "name": "DogDu",
      "url": "https://dog-du.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/head.jpg"><link rel="canonical" href="https://dog-du.github.io/posts/8453.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":300,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '读论文-Architecture of a Database System',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="alternate" href="/atom.xml" title="DogDu's blog" type="application/atom+xml">
</head><body><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/top_img.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="/img/head.jpg" alt="Logo"><span class="site-name">DogDu's blog</span></a><a class="nav-page-title" href="/"><span class="site-name">读论文-Architecture of a Database System</span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">读论文-Architecture of a Database System</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2025-03-27T08:37:49.000Z" title="Created 2025-03-27 16:37:49">2025-03-27</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2025-04-05T14:01:12.042Z" title="Updated 2025-04-05 22:01:12">2025-04-05</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%AD%A6%E4%B9%A0%E7%B1%BB/">学习类</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="architecture-of-a-database-system"><a class="markdownIt-Anchor" href="#architecture-of-a-database-system"></a> Architecture of a Database System</h1>
<p>原文：https://dsf.berkeley.edu/papers/fntdb07-architecture.pdf</p>
<p>论文出于 2007 年，作者是 Joseph M. Hellerstein, Michael Stonebraker, James Hamilton。</p>
<p>年代较早并且更重视于体系结构，很多新技术没有提及，如：SSI，NoSQL等</p>
<p>本文总体上是对论文的翻译、阅读。有一些不确定单词语句之处，会给出原文，附加我的翻译。一些地方可能会给上注。</p>
<h1 id="abstract"><a class="markdownIt-Anchor" href="#abstract"></a> Abstract</h1>
<p>介绍了 DBMS 的重要性和先进性。由于一些原因，介绍 DBMS 系统设计问题的文献较少。论文介绍了 DBMS 的设计原则的框架讨论。包括进程模型、并行框架、存储系统设计、事务系统实现、查询处理器和优化器架构，以及经典的组件和程序。</p>
<p><s>嘻，全是我想看的，是不是说明我啥也不会啊（</s></p>
<h1 id="1-introduction"><a class="markdownIt-Anchor" href="#1-introduction"></a> 1 Introduction</h1>
<p>再次强调了 DBMS 的复杂性，重要性。提到早期的 DBMSs 在计算机科学领域是具有重要影响力的软件，其思想和实现在各处都被借鉴使用。</p>
<p>对于 DBMS 的课程没有得到应用的重视。分析了两个原因：</p>
<ul>
<li>应用领域的 DBMS 圈子很小。市场只允许少数高端巨头存在。数据库设计圈子很小：许多人处于同一个学校，研究相同的项目，从事于相同的商业产品</li>
<li>数据库的学术领域常忽略体系结构问题。数据库的教科书专注于算法和理论方面，而很少讨论整个实现时的体系结构。</li>
</ul>
<p>总而言之，关于如何构建数据库系统的许多传统智慧是可用的，但很少有人写下来或广泛交流。</p>
<p>论文试图抓住现代数据库系统的体系结构观念，同时讨论一些先进的话题。有一些问题出于文献，有一些问题处于产品手册或者惯例。</p>
<p>论文的目标是关注整体系统设计和强调教科书中通常没有讨论的问题，为更广为人知的算法和概念提供有用的上下文。</p>
<p>论文假定读者熟悉数据库系统教材并且熟悉现代操作系统基本功能。</p>
<h2 id="11-relational-systems-the-life-of-a-query"><a class="markdownIt-Anchor" href="#11-relational-systems-the-life-of-a-query"></a> 1.1 Relational Systems: The Life of a Query</h2>
<p><strong>论文强调了关系型数据库在基础领域和先进领域的重要性与地位，表示本文会关注于关系型数据库。</strong></p>
<p><img src="/img/Architecture%20Of%20a%20Database%20System/image-20250327212057990.png" alt="image-20250327212057990"></p>
<p>
    </p><center>一个传统的关系型数据库有五个部件，如图1.1</center>
<p></p>
<p>作为对这些部分的简单介绍以及论文后些部分的总结，可以关注一句 SQL 的生命周期。</p>
<p>考虑机场中一个简单但典型的数据库交互，其中登机口代理单击表单以请求航班的乘客列表。</p>
<p>当按下查询按钮之后一个单查询事务工作如下：</p>
<ol>
<li>个人电脑与服务器建立网络连接、直接与数据库建立网络连接、或者与一个在客户端和数据库之间的中间层建立连接。由于这些不同的选择，一个传统 DBMS 需要适合不同协议。但他们的职责基本相同，为调用者建立并记住连接状态，响应 SQL 命令，需要时返回数据与其他信息。在这个示例中，客户端与中间层建立连接，并将请求转发给 DBMS 中。</li>
<li>一旦收到 SQL， DBMS 为 SQL 命令分配一个计算线程，这个线程与客户端进行通信与输出，这是 DBMS 中 Process Manager (如图1.1) 的任务。这个阶段，数据库最重要的决定是 admission control （准入控制），系统是应该立即开始处理查询，还是延迟执行，直到有足够的系统资源可以用于此查询。这部分将在第二节讨论。</li>
<li>准入并分配线程控制后，查询开始进行。这是 Relational Query Processor （关系查询处理器，如图1.1）的任务。这组模块检查用户是否被授权运行查询，并将用户的SQL查询文本编译到内部查询计划中。编译后，执行计划交予计划执行器。计划执行器由一组“operators（算子）”（关系算法实现）组成，用于执行任何查询。算子包括连接、选择、投影、聚合、排序等，同时向该系统的较低层级请求数据记录（也就是在语法树上向孩子请求元组）。在示例中，是一个简单子集。这部分将在第四节讨论。</li>
<li>在查询计划的基础上，有多个算子向数据库请求数据。这些算子通过调用 DBMS 中管理数据读写操作的 Transctional Storage Manager （事务存储管理器，如图1.1）获得数据。存储系统包括一系列算法和数据结构来组织、管理和读写磁盘上的数据，像基础的结构表和索引等。还包括一个缓冲区管理模块，用来决定何时以及将什么数据从磁盘传输到内存缓冲中。回到示例，在访问数据中，查询必须调用事务管理模块以保证事物的 ACID 属性。（将在 5.1 节有更详细的讨论）。在获取数据之前，必须从锁管理器中先上锁，以确保并发时的正确执行。如果查询包含数据库的更新，他会与日志管理器进行交互，确保事务提交之后的持久性，和中止之后的完全 undo。在 5 节中，会更细节讨论存储和缓冲管理；在 6 节中，会介绍事务性一致性体系结构。</li>
<li>这时示例中的 SQL 已经开始访问数据记录，并准备用他们为客户端计算结果。调用方法，将控制返回查询执行器的算子，算子从数据库数据中编排元组的计算结果；结果元组生成之后，被放置在客户端通信管理器缓冲区中，并将交过返回给调用者。对于大型结果集，客户机通常会进行额外的调用，以便从查询中增量地获取更多数据，从而导致通过通信管理器、查询执行器和存储管理器进行多次迭代。在我们的简单示例中，在查询结束时，事务完成，连接关闭；这导致事务管理器清理事务的状态，流程管理器为查询释放任何控制结构，通信管理器清理连接的通信状态。</li>
</ol>
<p>这个示例，虽然触及 RDBMS 中许多关键部分，但并非全部。图1.1右边部分的共享部分对一个完全功能的 DBMS 非常重要。catalog （目录）目录和内存管理器在任何事务期间（包括我们的示例查询）都作为实用程序调用。查询处理器在身份验证、解析和查询优化期间使用 catalog （目录）。内存管理器贯穿于整个 DBMS ，每当需要动态分配或释放内存时。图1.1最右边框中列出的其余模块是独立于任何特定查询运行的实用程序，使数据库作为一个整体保持良好和可靠。我们将在第7节中讨论这些共享组件和实用程序。</p>
<h2 id="12-scope-and-overview"><a class="markdownIt-Anchor" href="#12-scope-and-overview"></a> 1.2 Scope and  Overview</h2>
<p>在论文的大部分内容中，重点是支持核心数据库功能的架构基础。论文不会对文献中广泛记载的数据库算法进行全面的回顾。论文会对现代dbms中出现的许多扩展进行了最少的讨论，其中大多数扩展提供了核心数据管理之外的功能，但不会显著改变系统架构。然而，在论文的各个部分中，论文会记录超出论文范围得有趣的主题，并提供额外阅读的指导。</p>
<p>论文首先对数据库系统的总体体系结构进行研究。任何服务器系统架构的第一个主题都是它的整体进程结构，论文在这方面探索了各种可行的替代方案，首先是针对单处理器机器，然后是针对当今可用的各种并行架构。对核心服务器系统体系结构的讨论适用于各种系统，但在很大程度上是DBMS设计的先驱。在此之后，讨论 DBMS 中更特定的组件。从系统的单个查询的视角开始，重点关注关系查询处理器。接下来，我们进入存储体系结构和事务性存储管理设计。最后，我们介绍了大多数 DBMSs 中存在的一些共享组件和实用程序，这些组件和实用程序在教科书中很少讨论。</p>
<h1 id="2-process-models"><a class="markdownIt-Anchor" href="#2-process-models"></a> 2 Process Models</h1>
<p>在设计任何多用户服务器时，需要对并发用户请求的执行以及如何将这些请求映射到操作系统进程或线程做出早期决策。这些决策对系统的软件架构、性能、可伸缩性和跨操作系统的可移植性都有深远的影响。在本节中，我们将研究 DBMS 进程模型的许多选择，这些模型可作为许多其他高并发服务器系统的模板。我们从一个简化的框架开始，假设对线程有良好的操作系统支持，我们最初的目标只是一个单处理器系统。然后，我们对这个简化的讨论进行扩展，以处理现代 DBMSs 如何实现其流程模型的现实问题。在第 3 节中，我们将讨论尽可能利用计算机集群以及多处理器和多核系统的技术。</p>
<p>​    下面的讨论依赖于这些定义：</p>
<ul>
<li>
<p>一个 <em><strong>Operating System Process (操作系统进程)</strong></em> 由操作系统（OS）和一个带有私有地址空间进程的程序执行单元（一个控制线程）组成。为进程维护的状态包括操作系统资源句柄和安全上下文。这个程序执行单元由操作系统内核调度，每个进程都有自己唯一的地址空间。</p>
</li>
<li>
<p>一个 <em><strong>Operating System Thread (操作系统线程)</strong></em> 是一个操作系统程序执行单元，没有额外的私有操作系统上下文，也没有私有地址空间。每个操作系统线程都可以完全访问在同一个多线程操作系统进程中执行的其他线程的内存。线程执行由操作系统内核调度器调度，这些线程通常称为“内核线程”或k-线程。</p>
</li>
<li>
<p>一个 <em><strong>Lightweight Thread Package (轻量级线程包)</strong></em> 是一个应用程序级别的结构，它支持单个操作系统进程中有多个线程。与由操作系统调度的操作系统线程不同，轻量级线程由应用程序级别的线程调度程序调度。轻量级线程和内核线程的区别在于，轻量级线程是在用户空间中调度的，不需要内核调度器的参与或了解。用户空间调度器及其所有轻量级线程的组合在单个操作系统进程中运行，并且对操作系统调度器显示为单个执行线程。</p>
<p>​    与操作系统线程相比，轻量级线程具有更快的线程切换的优点，因为不需要进行操作系统内核模式切换来调度下一个线程。然而，轻量级线程的缺点是，任何阻塞操作（例如任何线程的同步I/O）都会阻塞进程中的所有线程。这会阻止其他线程在一个线程被阻塞等待操作系统资源时执行。轻量级线程包通过只发出异步（非阻塞）I/O请求和不调用任何可能阻塞的操作系统操作来避免这种情况。通常，轻量级线程提供了比基于OS进程或OS线程编写软件更困难的编程模型。（注：论文语境中的轻量级线程，可见2.2.1 DBMS Threads。我原本以为其实指的就是协程或者纤程，但实则有一定区别。但总之，它们无法使用多核，见3.5）</p>
</li>
<li>
<p>一些 DBMSs 实现了自己的轻量级线程（LWT）包。当DBMS、一般LWT和操作系统线程之间的区别对讨论不重要时，我们将这些线程称为 DBMS 线程和简单的线程。</p>
</li>
<li>
<p>***DBMS client (DBMS 客户端)***是一个软件组件，它实现了应用程序用来与DBMS通信的API。一些示例数据库访问api有JDBC、ODBC和OLE/DB。此外，还有各种各样的专有数据库访问API集。有些程序是使用嵌入式SQL编写的，这是一种将编程语言语句与数据库访问语句混合在一起的技术。它首先在IBM COBOL和PL/I中发布，后来在SQL/J中发布，SQL/J为Java实现了嵌入式SQL。嵌入式SQL由预处理器处理，预处理器将嵌入式SQL语句转换为对数据访问api的直接调用。无论客户机程序中使用什么语法，最终结果都是对DBMS数据访问api的一系列调用。对这些api的调用由DBMS客户端组件编组，并通过某种通信协议发送给DBMS。这些协议通常是专有的，通常没有文档记录。在过去，已经有一些标准化客户机到数据库通信协议的努力，其中Open Group DRDA可能是最著名的，但没有一个获得广泛采用。</p>
</li>
<li>
<p>一个***DBMS Worker (工作线程)***是DBMS中代表DBMS客户端工作的执行线程。在DBMS Worker 和DBMS客户端之间存在1:1的映射：这个DBMS Worker 处理来自单个DBMS客户机的所有SQL请求。worker 执行每个请求并将结果返回给客户端。在接下来的内容中，我们将研究商业DBMS将DBMS Worker映射到操作系统线程或进程的不同方法。这些差别是明显的，我们将它们称为 worker threads (工作线程) 或 worker process (工作进程)。否则，我们将它们简单地称为工作器或DBMS worker。</p>
</li>
</ul>
<h2 id="21-uniprocessors-and-lightweight-threads"><a class="markdownIt-Anchor" href="#21-uniprocessors-and-lightweight-threads"></a> 2.1 Uniprocessors and Lightweight Threads</h2>
<p>在本小节中，我们将概述一个简化的DBMS过程模型分类法。很少有领先的 DBMSs 的架构与本节中描述的完全一样，但是这些材料构成了我们将更详细地讨论当前一代生产系统的基础。当今的每一个领先的数据库系统，其核心都是本文所介绍的至少一个模型的扩展或增强。</p>
<p>​    我们首先做两个简化的假设（我们将在随后的章节中放宽）：</p>
<ol>
<li><em><strong>OS thread support (操作系统线程支持)</strong></em>：我们假设操作系统为我们提供了对内核线程的有效支持，并且一个进程可以有非常多的线程。我们还假设每个线程的内存开销很小，上下文切换开销也很小。这在今天的许多现代操作系统上都是正确的，但在大多数 DBMS 最初设计时却不一定不是正确的。由于那时的操作系统线程要么不可用，要么在某些平台上伸缩性差，因此许多 DBMSs 在实现时没有使用底层操作系统线程支持。</li>
<li><em><strong>Uniprocessor hardware （单处理器硬件）</strong></em>：我们将假设我们正在为具有单个CPU的单个机器进行设计。考虑到多核系统的普遍性，这是一个不现实的假设，即使在低端也是如此。然而，这个假设将简化我们最初的讨论。</li>
</ol>
<p>在这个简化的上下文中，DBMS有三个自然的过程模型选项。从最简单的到最复杂的，它们是：(1)the process per DBMS worker，(2)the thread per DBMS worker，(3)process pool。虽然这些模型都是简化的，但这三种模型都在今天的商业DBMS系统中使用。</p>
<h3 id="211-process-per-dbms-worker"><a class="markdownIt-Anchor" href="#211-process-per-dbms-worker"></a> 2.1.1 Process per DBMS Worker</h3>
<p><img src="/img/Architecture%20Of%20a%20Database%20System/image-20250329170130698.png" alt="image-20250329170130698"></p>
<p>一个 DBMS worker 一个进程（图2.1）被早期的DBMS实现并使用，并且今天仍被许多商业系统所使用。这个模型相对容易实现，因为DBMS工作器直接映射到操作系统进程。操作系统调度器管理DBMS工作人员的分时，而DBMS程序员可以依靠操作系统的保护设施来隔离内存溢出等标准错误。此外，各种编程工具（如调试器和内存检查器）都非常适合此进程模型。使这个模型复杂化的是跨DBMS连接共享的内存数据结构，包括锁表和缓冲池（分别在第6.3节和第5.3节中详细讨论）。这些共享数据结构必须显式地分配在操作系统支持的共享内存中，这些内存可以跨所有DBMS进程访问。这需要操作系统支持（这是广泛可用的）和一些特殊的DBMS编码。在实践中，这个模型中需要大量使用共享内存，这降低了地址空间分离的一些优势，因为有很大一部分“interesting（有趣的）”内存是跨进程共享的。</p>
<p>​    在扩展到非常大量的并发连接方面，*process per DBMS worker （一个 DBMS worker一个进程）*不是最有吸引力的进程模型。伸缩问题的出现是因为进程比线程拥有更多的状态，因此会消耗更多的内存。进程切换需要切换安全上下文、内存管理器状态、文件和网络句柄表以及其他进程上下文。而这对于一个线程的切换来说，是不需要的。尽管如此，一个 DBMS worker一个进程的模型仍然很流行，并在IBM DB2、PostgreSQL和Oracle得到支持。</p>
<h3 id="212-thread-per-dbms-worker"><a class="markdownIt-Anchor" href="#212-thread-per-dbms-worker"></a> 2.1.2 Thread per DBMS worker</h3>
<p><img src="/img/Architecture%20Of%20a%20Database%20System/image-20250329171129970.png" alt="image-20250329171129970"></p>
<p>在每个DBMS工作线程模型（图2.2）中，单个多线程进程承载所有DBMS工作线程活动。一个调度线程 （或一小部分这样的线程）监听新的 DBMS 客户端连接。每个连接分配一个新线程。当每个客户端提交SQL请求时，请求完全由运行DBMS worker的相应线程执行。该线程在DBMS进程中运行，完成后，结果返回给客户端，线程在连接上等待来自同一客户端的下一个请求。</p>
<p>​    在这种体系结构中出现了常见的多线程编程挑战：操作系统不保护线程免受彼此的内存溢出和偏离指针的影响；调试是棘手的，特别是在竞争条件下；由于线程接口和多线程扩展的差异，软件很难跨操作系统移植。由于共享内存的广泛使用，the thread per DBMS worker的许多多编程挑战也存在于每个the process per DBMS worker中。</p>
<p>​    尽管近年来不同操作系统之间的线程API差异已经最小化，但平台之间的细微差异仍然会给调试和调优带来麻烦。忽略这些实现困难，每个DBMS工作线程模型可以很好地扩展到大量并发连接，并在一些当前一代的生产DBMS系统中使用，包括IBM DB2、Microsoft SQL Server、MySQL、Informix和Sybase。</p>
<h3 id="213-process-pool"><a class="markdownIt-Anchor" href="#213-process-pool"></a> 2.1.3 Process Pool</h3>
<p><img src="/img/Architecture%20Of%20a%20Database%20System/image-20250329182824292.png" alt="image-20250329182824292"></p>
<p>这个模型是 the process per DBMS worker 的一个变体。回想一下，其优点是实现简单，但是每个连接需要一个完整进程的内存开销是一个明显的缺点。使用进程池（图2.3），而不是为每个DBMS工作人员分配一个完整的进程，它们由进程池托管。中央进程保存所有DBMS客户端连接，并且当每个SQL请求来自客户端时，该请求被传递给进程池中的一个进程。SQL语句执行到完成，结果返回给数据库客户端，进程返回到池中，以分配给下一个请求。进程池的大小是有限的，而且通常是固定的。如果一个请求到达而所有进程都在处理其他请求，那么新请求必须等待一个进程空闲。</p>
<p>​    进程池具有每个DBMS工作进程的所有优点，但由于所需的进程数量要少得多，因此内存效率要高得多。进程池通常使用动态调整大小的进程池来实现，当大量并发请求到达时，进程池可能会隐式增长到某个最大数量。当请求负载较轻时，可以将进程池减少到更少的等待进程。与the thread per DBMS worker一样，目前使用的几个当前一代DBMS也支持进程池模型。</p>
<h3 id="214-shared-data-and-process-boundaries"><a class="markdownIt-Anchor" href="#214-shared-data-and-process-boundaries"></a> 2.1.4 Shared Data and Process Boundaries</h3>
<p>上面描述的所有模型都旨在尽可能独立地执行并发客户机请求。然而，完全的DBMS工作者独立性和隔离性是不可能的，因为它们操作相同的数据库。在 the thread per DBMS worker 模型中，所有线程在相同的地址空间中运行，数据共享很容易。在其他模型中，共享内存用于共享数据结构和状态。在所有这三种模型中，数据必须从DBMS移动到客户端。这意味着所有SQL请求都需要移到服务器进程中，返回到客户机的所有结果都需要移动至客户端。这是如何做到的呢？简短的回答是使用了各种缓冲区。我们在这里描述这些缓冲区，并简要讨论管理它们的策略。</p>
<p><em>Disk I/O buffers (磁盘I/O缓冲区)</em>：最常见的跨工作数据依赖关系是对共享数据存储的读取和写入。因此，DBMS worker之间的I/O交互是常见的。有两个单独的磁盘I/O场景需要考虑：(1)数据库请求和(2)日志请求。</p>
<ul>
<li>
<p><em>Database I/O Requests: The Buffer Pool (数据库I/O请求：缓冲池)</em>：所有持久化数据库数据都通过DBMS缓冲池进行暂存（第5.3节）。在另外两种模型中，缓冲池分配在所有进程可用的共享内存中。这三种DBMS模型的最终结果都是缓冲池是对所有线程/进程可用的巨大的共享数据结构。当一个线程需要从数据库中读入一个页面时，它会生成一个指定磁盘地址的I/O请求，并生成一个句柄，指向缓冲池中可以放置结果的空闲内存位置（帧）。缓冲池将在4.3节中详细讨论。</p>
</li>
<li>
<p><em>Log I/O Requests: The Log Tail. (日志 I/O 请求：日志追踪）</em>：数据库日志（章节6.4）是存储在一个或多个磁盘上的条目数组。日志条目在事务处理时产生，他们被存储在一个内存队列中，按照 FIFO 的顺序定期刷入日志磁盘中。这个队列通常称为日志追踪。在许多系统中，一个单独的进程或线程负责定期将日志尾刷新到磁盘。</p>
<p>​    对于the thread per DBMS worker，日志尾只是一个堆驻留数据结构。在另外两个模型中，两种不同的设计选择是常见的。在一种方法中，一个单独的进程管理日志。日志记录通过共享内存或任何其他有效的进程间通信协议传递给日志管理器。在另一种方法中，在共享内存中分配日志尾，其方式与上面处理缓冲池的方式大致相同。关键的一点是，执行数据库客户机请求的所有线程和/或进程都需要能够请求写入日志记录并刷新日志尾。</p>
<p>​    日志刷新的一种重要类型是提交事务刷新。在提交日志记录刷新到日志设备之前，事务不能报告为成功提交。这意味着客户端代码要等待，直到提交日志记录被刷新，而DBMS服务器代码也必须保持所有资源（例如锁），直到那个时间。日志刷新请求可以延迟一段时间，以允许在单个I/O请求中批量提交记录（“组提交”）。</p>
</li>
</ul>
<p><em>Client communication buffers （客户端通信缓冲区）</em>：SQL通常用于“拉”模型：客户端通过重复发出SQL FETCH请求从查询游标中消费结果元组，每个请求检索一个或多个元组。大多数dbms尝试在FETCH请求流之前工作，以便在客户端请求之前对结果进行排队。</p>
<p>​    为了支持这种预取行为，DBMS worker可以使用客户端通信套接字作为它生成的元组的队列。更复杂的方式是实现客户端侧的游标缓存并使用DBMS 客户端存储很可能在之后不久会被拉取的结果，而不是依赖 OS 的通信缓存。</p>
<p><em>Lock table（锁表）</em>：锁表由所有DBMS worker共享，并由锁管理器（章节6.3）使用来实现数据库锁定语义。共享锁表的技术与缓冲池的技术相同，这些相同的技术可用于支持DBMS实现所需的任何其他共享数据结构。</p>
<h2 id="22-dbms-threads"><a class="markdownIt-Anchor" href="#22-dbms-threads"></a> 2.2 DBMS Threads</h2>
<p>前一节提供了对DBMS过程模型的简化描述。我们假设了高性能操作系统线程的可用性，并且DBMS只针对单处理器系统。在本节的其余部分中，我们将放宽第一个假设，并描述对DBMS实现的影响。下一节将讨论多处理和并行性。</p>
<h3 id="221-dbms-threads"><a class="markdownIt-Anchor" href="#221-dbms-threads"></a> 2.2.1 DBMS Threads</h3>
<p>今天的大多数 DBMSs 都起源于20世纪70年代的研究系统和20世纪80年代的商业化努力。在构建原始数据库系统时，我们今天认为理所当然的标准操作系统特性通常对当时的DBMS开发人员是不可用的。高效、大规模的操作系统线程支持可能是其中最重要的。直到20世纪90年代，操作系统线程才被广泛实现，即使存在，实现也有很大差异。即使在今天，一些操作系统线程实现也不能很好地扩展到支持所有DBMS工作负载。</p>
<p>​    因此，出于历史原因、移植性和可伸缩性的原因，许多广泛使用的DBMS在其实现中不依赖于操作系统线程。（注：这句话对于2025年的今天可能并不适用了。）有些则完全避免使用线程，并使用the process per DBMS worker或进程池模型。对于那些没有很好的内核线程实现的操作系统，需要一个解决方案来实现剩余的进程模型选择，即the process per DBMS worker。几个领先的DBMSs采用了一种解决此问题的方法是实现它们自己专用的，轻量级的线程包。这些轻量级线程或DBMS线程取代了前一节中描述的操作系统线程的角色。每个DBMS线程都被编程来管理自己的状态，通过非阻塞的异步接口执行所有潜在的阻塞操作（例如，I/O），并经常将控制权交给调度例程，调度例程在这些任务之间进行调度。</p>
<p>​    轻量级线程是中以回顾的方式讨论的一个老概念，并且广泛用于用户界面的事件循环编程。在最近的OS文献中，这个概念经常被重新审视。这种架构提供了快速的任务切换和易于移植，但代价是在DBMS中复制大量的操作系统逻辑（任务切换、线程状态管理、调度等）。</p>
<h2 id="23-standard-practice"><a class="markdownIt-Anchor" href="#23-standard-practice"></a> 2.3 Standard Practice</h2>
<p>在当今领先的 DBMSs 中，我们可以找到2.1节中介绍的所有三种体系结构的代表，以及它们的一些有趣的变化。在这个维度中，IBM DB2可能是最有趣的例子，因为它支持四种不同的处理模型。在具有良好线程支持的OSs上，DB2默认使用 the thread per DBMS worker 并且可选支持在线程池上多路复用DBMS worker线程。在没有可伸缩支持的OSs上，DB2默认使用 the process per DBMS worker 并且可选支持在一个进程池上多路复用 DBMS worker。</p>
<p>​    总结IBM DB2、MySQL、Oracle、PostgreSQL和Microsoft SQL Server支持的进程模型：</p>
<p><em>Process per DBMS worker</em>：</p>
<p>这是最直接的流程模型，至今仍被大量使用。在不支持高质量、可扩展的操作系统线程的操作系统上，DB2默认the process per DBMS worker，而在支持高质量、可扩展的操作系统线程的操作系统上，DB2默认the thread per DBMS worker。这也是 Oracle 默认的处理模型。Oracle还支持下面描述的进程池作为可选模型。只有PostgreSQL在所有支持的操作系统上都只运行the process per DBMS worker。</p>
<p>Thread per DBMS worker：</p>
<p>​    这是一个有效的模型，目前有两个主要的变体。</p>
<ol>
<li>OS thread per DBMS worker：在具有良好的操作系统线程支持的系统上运行时，IBM DB2默认使用此模型，MySQL也使用此模型。</li>
<li>DBMS thread per DBMS worker：在这个模型中，DBMS工作程序由操作系统进程或操作系统线程上的轻量级线程调度器调度。该模型避免了任何潜在的操作系统调度器伸缩或性能问题，但代价是高昂的实现成本、较差的开发工具支持以及DBMS供应商的大量长期软件维护成本。这个模型有两个主要的子类别：
<ol>
<li>在操作系统进程上调度的DBMS线程：轻量级线程调度程序由一个或多个操作系统进程托管。Sybase和Informix都支持这个模型。当前所有使用此模型的系统都实现了一个DBMS线程调度器，该调度器在多个操作系统进程上调度DBMS工作程序，以利用多个处理器。然而，并非所有使用此模型的DBMS都实现了线程迁移：将现有DBMS线程重新分配给不同的操作系统进程的能力（例如，为了负载平衡）。</li>
<li>在OS线程上调度的DBMS线程：Microsoft SQL Server将此模型作为非默认选项支持（默认是DBMS工作线程在下面描述的线程池上多路复用）。这个SQL Server选项，称为Fibers（纤程），在一些高规模的事务处理基准测试中使用，但除此之外，很少使用。</li>
</ol>
</li>
</ol>
<p><em>Process/thread pool</em>：</p>
<p>​    在这个模型中，DBMS工作器在一个进程池中进行多路复用。随着操作系统线程支持的改进，这个模型的第二个变体基于线程池而不是进程池出现了。在后一种模型中，DBMS工作线程在操作系统线程池中复用：</p>
<ol>
<li><em>DBMS workers multiplexed over a process pool（DBMS workers在一个进程池上多路复用）</em>：这个模型比每个DBMS工作进程的内存效率高得多，很容易移植到没有良好的操作系统线程支持的操作系统上，并且可以很好地扩展到大量用户。这是Oracle支持的可选模型，也是他们为具有大量并发连接用户的系统推荐的模型。Oracle默认的模型是 the process per DBMS worker。Oracle支持的两个选项都很容易在它们所针对的大量不同的操作系统上得到支持（Oracle一度支持超过80个目标操作系统）。</li>
<li><em>DBMS workers multiplexed over a thread pool（DBMS workers 在线程池上多路复用）</em>：Microsoft SQL Server默认采用这种模式，并且超过99%的SQL Server安装都以这种方式运行。如上所述，为了有效地支持成千上万并发连接的用户，SQL Server可选择支持在操作系统线程上调度的DBMS线程。</li>
</ol>
<p>正如我们在下一节中讨论的那样，当前一代的大多数商业 DBMSs 都支持查询内并行性：在多个处理器上并行执行单个查询的全部或部分的能力。就本节讨论的目的而言，查询内并行是多个DBMS worker临时赋给对单个SQL。除了单个客户端连接可能有多个DBMS工作器代表其执行之外，底层处理模型不会受到此特性的任何影响。</p>
<h2 id="24-admission-control"><a class="markdownIt-Anchor" href="#24-admission-control"></a> 2.4 Admission Control</h2>
<p>我们以一个与支持多个并发请求相关的剩余问题结束本节。随着任何多用户系统中工作负载的增加，吞吐量将增加到某个最大值。超过这个点，当系统开始颠簸时，它（应该指性能）将开始急剧减少。与操作系统一样，抖动通常是内存压力的结果：DBMS 不能将数据库页面的“工作集”保存在缓冲池中，并且花费大量时间来替换页面。在 DBMSs 中，对于排序和散列连接等查询处理技术来说，这尤其是个问题，因为它们往往会消耗大量的主内存。在某些情况下，DBMS抖动也可能由于锁的争用而发生：事务不断地彼此死锁，需要回滚并重新启动。因此，任何好的多用户系统都有一个准入控制策略，除非有足够的DBMS资源可用，否则不接受新的工作。有了一个好的准入控制器，系统在过载情况下将显示出优雅的降级：事务延迟将与到达率成比例地增加，但吞吐量将保持在峰值。</p>
<p>​    DBMS的准入控制可以分为两层。首先，可以在调度程序进程中设置一个简单的准入控制策略，以确保客户端连接数保持在阈值以下。这有助于防止过度消耗基本资源，如网络连接。在一些 DBMSs 中，不提供这种控制，假设它是由多层系统的另一层处理的，例如，应用程序服务器、事务处理监视器或web服务器。</p>
<p>​    第二层准入控制必须直接在核心DBMS关系查询处理器中实现。此执行许可控制器在查询被解析和优化后运行，并确定查询是延迟执行、在资源较少的情况下开始执行，还是在没有额外约束的情况下开始执行。来自查询优化器的信息可以帮助执行许可控制器，这些信息可以估计查询所需的资源和当前系统资源的可用性。特别是,优化器的查询计划可以指明(1)查询将访问的磁盘设备的随机顺序I/O操作,(2)基于查询计划中的算子和处理元组的数量估计CPU负载，最重要的是(3)估计的内存占用查询数据结构,包括空间排序和散列大型期间输入连接和查询执行其他任务。如上所述，最后一个指标通常是准入控制器的关键，因为内存压力通常是导致抖动的主要原因。因此许多DBMS使用内存占用和活动DBMS工作器的数量作为准入控制的主要标准。</p>
<h2 id="25-discussion-and-additional-material"><a class="markdownIt-Anchor" href="#25-discussion-and-additional-material"></a> 2.5 Discussion and Additional Material</h2>
<p>处理模型的选择对DBMS的扩展和可移植性有很大的影响。因此，三个更广泛使用的商业系统在其产品线中都支持一个以上的处理模型。从工程的角度来看，在所有操作系统和所有扩展级别上使用单一流程模型显然要简单得多。但是，由于使用模式的巨大多样性和目标操作系统的不一致性，这三个dbms都选择支持多个模型。</p>
<p>​    展望未来，近年来，由于硬件瓶颈的变化以及Internet上工作负载的规模和可变性，人们对服务器系统的新流程模型产生了浓厚的兴趣。这些设计中出现的一个主题是将服务器系统分解为一组独立调度的“引擎”，并在这些引擎之间异步地批量传递消息。这类似于上面的“进程池”模型，其中工作单元跨多个请求重用。最近这项研究的主要新颖之处在于，它以一种比以前更狭窄的任务特定方式打破了工作的功能颗粒。这导致了worker和SQL请求之间的多对多关系——单个查询通过多个worker中的活动进行处理，每个worker为许多SQL请求执行自己的专用任务。这种架构支持更灵活的调度选择——例如，它允许在允许单个工作者完成许多查询任务（可能提高整体系统吞吐量）或允许查询在多个工作者之间进行进展（以改善该查询的延迟）之间进行动态权衡。在某些情况下，这已被证明在处理器缓存局部性方面具有优势，并且能够在硬件缓存丢失期间保持CPU繁忙而不是空闲。StagedDB研究项目代表了在DBMS上下文中对这一思想的进一步研究，这是进行额外阅读的一个很好的起点。</p>
<h1 id="3-parallel-architectureprocess-and-memory-coordination"><a class="markdownIt-Anchor" href="#3-parallel-architectureprocess-and-memory-coordination"></a> 3 Parallel Architecture：Process and Memory Coordination</h1>
<p>并行硬件在现代服务器中是一个事实，并且有各种各样的配置。在本节中，我们总结了标准DBMS术语，并讨论了每个术语中的进程模型和内存协调问题。</p>
<h2 id="31-shared-memory"><a class="markdownIt-Anchor" href="#31-shared-memory"></a> 3.1 Shared Memory</h2>
<p><img src="/img/Architecture%20Of%20a%20Database%20System/image-20250330145456416.png" alt="image-20250330145456416"></p>
<p>在共享内存并行系统（图3.1）中，所有处理器都可以以大致相同的性能访问相同的RAM和磁盘。这种架构在今天是相当标准的——大多数服务器硬件都有 2 到 8 个处理器。（注：现在的服务器CPU能有几十甚至上百个核，而且根据架构不同，核与核之间的性能不一定完全相同。）高端机器可以配备数十个处理器，但相对于所提供的处理资源，它们的售价往往高出很多。高度并行的共享内存机器是硬件行业中仅存的“摇钱树”之一，在高端在线事务处理应用程序中被大量使用。与管理系统的成本相比，服务器硬件的成本通常显得微不足道，所以购买少量的大型、昂贵的系统的代价（以降低管理成本），有时是可接受的折中。</p>
<p>​    多核处理器支持单个芯片上的多个处理核心，并共享一些基础设施，如缓存和内存总线。这使得它们在编程模型方面与共享内存架构非常相似。如今，几乎所有严肃的数据库部署都涉及多个处理器，每个处理器都有多个CPU。DBMS体系结构需要能够充分利用这种潜在的并行性。幸运的是，第2节中描述的所有三种DBMS体系结构都可以在现代共享内存硬件体系结构上运行良好。</p>
<p>​    共享内存机器的进程模型非常自然地遵循单处理器方法。事实上，大多数数据库系统都是从最初的单处理器实现发展到共享内存实现的。在共享内存机器上，操作系统通常支持跨处理器透明地分配工作（进程或线程），并且所有人都可以访问共享数据结构。所有三种模型都能在这些系统上运行良好，并支持并行执行多个独立的SQL请求。主要的挑战是修改查询执行层，以利用跨多个cpu并行处理单个查询的能力；我们将此推迟到第5节。</p>
<h2 id="32-shared-nothing"><a class="markdownIt-Anchor" href="#32-shared-nothing"></a> 3.2 Shared-Nothing</h2>
<p><img src="/img/Architecture%20Of%20a%20Database%20System/image-20250330151140548.png" alt="image-20250330151140548"></p>
<p>无共享并行系统（图3.2）由一组独立的机器组成，这些机器通过高速网络互连进行通信，或者更频繁地通过商业网络组件进行通信。给定的系统无法直接访问另一个系统的内存或磁盘。</p>
<p>​    无共享系统不提供硬件共享抽象，将各种机器的协调完全交给DBMS处理。DBMSs 用来支持这些集群的最常用技术是在集群中的每台机器或节点上运行它们的标准处理模型。每个节点都能够接受客户端SQL请求、访问必要的元数据、编译SQL请求和执行数据访问，就像在上面描述的单个共享内存系统上一样。主要区别在于集群中的每个系统只存储一部分数据。请求被发送到集群的其他成员，而不是仅针对本地数据运行它们接收到的查询，所有涉及的机器都对它们存储的数据并行执行查询。这些表分布在集群中的多个系统上，使用水平数据分区允许每个处理器独立于其他处理器执行。</p>
<p>​    数据库中的每个元组都被分配给单独的机器，因此每个表都被“水平”切片并分布在机器上。典型的数据分区方案包括基于元组属性的哈希分区、基于元组属性的范围分区、轮循（round-robin）和混合（基于范围和基于哈希的组合）。每台单独的机器负责访问、锁定和记录本地磁盘上的数据。在查询执行期间，查询优化器选择如何跨机器水平地重新划分表和中间结果以满足查询，并为每台机器分配工作的逻辑分区。不同机器上的查询执行器相互传送数据请求和元组，但不需要传输任何线程状态或其他低级信息。由于数据库元组的这种基于值的分区，在这些系统中只需要很少的协调。但是，为了获得良好的性能，需要对数据进行良好的分区。这给数据库管理员（DBA）和查询处理器带来了很大的负担，他们需要智能地布局表，以便更好地对工作负载进行分区。</p>
<p>​    此外，部分失效（partial failure）是必须在shared-nothing系统中进行管理。在一个shared-memory 系统中，一个处理器的故障通过会导致整个机器的故障，进而导致整个 DBMS 故障。在无共享系统中，单个节点的故障不一定会影响集群中的其他节点。但是它肯定会影响DBMS的整体行为，因为故障节点承载了数据库中的一部分数据。在这种情况下，至少有三种可能的方法。第一种方法是在任何节点发生故障时关闭所有节点；这实际上模拟了共享内存系统中可能发生的情况。第二种方法被IBM Informix称为“数据跳过”，它允许在任何正常运行的节点上执行查询，“跳过”故障节点上的数据。这在数据可用性比结果完整性更重要的场景中很有用。但是，“尽力而为”的结果没有定义良好的语义，并且对于许多工作负载来说，这不是一个有用的选择—特别是因为DBMS经常被用作多层系统中的“记录存储库”，并且可用性与一致性的权衡往往在更高的层中完成（通常在应用程序服务器中）。第三种方法是采用冗余方案，从完全数据库故障转移（需要双倍数量的机器和软件许可证）到细粒度冗余，如链式集群。在后一种技术中，元组副本分布在集群中的多个节点上。链式集群相对于更简单的方案的优势在于（a）与原始方案相比，它需要更少的机器来保证可用性（b）当一个节点发生故障时，系统负载会相当均匀地分布在剩余的节点上：剩下的n−1个节点每个都完成了原始工作的n/(n−1)，并且随着节点故障，这种形式的性能线性下降会继续下去。在实践中，大多数当前一代的商业系统都处于中间位置，既不像完全数据库（full database）冗余那样粗粒度，也不像链式集群那样细粒度。</p>
<p>​    shared-nothing架构在今天相当普遍，并且具有无与伦比的可伸缩性和成本特征。它主要用于极端高端，通常用于决策支持应用程序和数据仓库。在一个有趣的硬件体系结构组合中，无共享集群通常由许多节点组成，每个节点都是一个共享内存多处理器。</p>
<h2 id="33-shared-disk"><a class="markdownIt-Anchor" href="#33-shared-disk"></a> 3.3 Shared-Disk</h2>
<p><img src="/img/Architecture%20Of%20a%20Database%20System/image-20250330154735207.png" alt="image-20250330154735207"></p>
<p>在shared-disk并行系统（图3.3）中，所有处理器都可以以相同的性能访问磁盘，但不能访问彼此的RAM。这种体系结构非常常见，有两个突出的例子是Oracle RAC和DB2 for zSeries SYSPLEX。近年来，随着存储区域网络（SAN）的日益普及，shared-disk变得越来越普遍。SAN允许一个或多个主机系统挂载一个或多个逻辑磁盘，从而易于创建共享磁盘配置。</p>
<p>​    与shared-nothing系统相比，shared-disk的一个潜在优势是其更低的管理成本。共享磁盘系统的 DBAs 不必为了实现并行性而考虑跨机器分区表。但是非常大的数据库通常仍然需要分区，因此，在这种规模下，差异变得不那么明显。共享磁盘体系结构的另一个引人注目的特性是，单个DBMS处理节点的故障不会影响其他节点访问整个数据库的能力。这与作为一个整体发生故障的共享内存系统和在节点发生故障时至少失去对某些数据的访问的无共享系统形成对比（除非使用了其他数据冗余方案）。然而，即使有这些优点，共享磁盘系统仍然容易受到一些单点故障的影响。如果数据在到达存储子系统之前由于硬件或软件故障而损坏或损坏，那么系统中的所有节点将只能访问这个损坏的页面。如果存储子系统使用RAID或其他数据冗余技术，损坏的页面将被冗余存储，但在所有副本中仍然损坏。</p>
<p>​    由于在共享磁盘系统中不需要对数据进行分区，因此可以将数据复制到RAM中并在多台机器上进行修改。与共享内存系统不同，没有自然的内存位置来协调这种数据共享—每台机器都有自己的本地内存用于锁和缓冲池页面。因此，需要在机器之间明确地协调数据共享。共享磁盘系统依赖于分布式锁管理器功能和缓存一致性协议来管理分布式缓冲池。这些都是复杂的软件组件，对于有大量争用的工作负载来说可能是瓶颈。有些系统（如IBM zSeries SYSPLEX）在硬件子系统中实现锁管理器。</p>
<h2 id="34-numa"><a class="markdownIt-Anchor" href="#34-numa"></a> 3.4 NUMA</h2>
<p>Non-Uniform Memory Access (NUMA) 非一致内存访问系统在具有独立内存的系统集群上提供共享内存编程模型。集群中的每个系统都可以快速访问自己的本地内存，而跨高速集群互连的远程内存访问有些延迟。架构的名称来自于内存访问时间的不一致性。</p>
<p>​    NUMA硬件架构是介于shared-nothing和shared-memory系统之间的一个有趣的中间地带。它们比shared-nothing的集群更容易编程，并且通过避免共享争用点（如共享内存总线），可以扩展到比共享内存系统更多的处理器。</p>
<p>​    NUMA集群在商业上还没有取得广泛的成功，但NUMA设计概念已被采用的一个领域是共享内存多处理器（第3.1节）。随着共享内存多处理器扩展到更大的处理器数量，它们在内存体系结构中显示出越来越多的不一致性。通常，大型共享内存多处理器的内存被分成几个部分，每个部分与系统中处理器的一个小子集相关联。内存和cpu的每个组合子集通常称为pod。每个处理器访问本地pod内存的速度比远程pod内存略快。这种NUMA设计模式的使用允许共享内存系统扩展到非常多的处理器。因此，NUMA共享内存多处理器现在非常普遍，而NUMA集群从未获得任何重要的市场份额。</p>
<p>​    DBMSs 可以在NUMA共享内存系统上运行的一种方法是忽略内存访问的非一致性。如果不均匀性很小，这种方法是可以接受的。当近内存访问时间与远内存访问时间之比超过1.5:1到2:1的范围时，DBMS需要进行优化以避免严重的内存访问瓶颈。这些优化有多种形式，但都遵循相同的基本方法：（a）当分配内存供处理器使用时，使用该处理器的本地内存（避免使用远内存）。（b）如果可能的话，确保给定的DBMS工作器总是被调度在它之前所在的同一硬件处理器上。这种组合允许DBMS工作负载在具有内存访问时间不均匀性的高规模共享内存系统上良好运行。</p>
<p>​     尽管NUMA集群几乎消失了，但是编程模型和优化技术对当前一代DBMS系统仍然很重要，因为许多大规模共享内存系统在内存访问性能上存在显著的不均匀性。</p>
<h2 id="35-dbms-threads-and-multi-processors"><a class="markdownIt-Anchor" href="#35-dbms-threads-and-multi-processors"></a> 3.5 DBMS Threads and Multi-processors</h2>
<p>当我们从2.1节中删除最后一个简化假设（单处理器硬件）时，使用DBMS线程实现的the thread per DBMS worker产生的一个潜在问题立即变得明显起来。2.2.1节中描述的轻量级DBMS线程包的自然实现是所有线程在单个操作系统进程中运行。不幸的是，单个进程一次只能在一个处理器上执行。因此，在多处理器系统上，DBMS一次只使用一个处理器，而将系统的其余部分闲置。早期的Sybase SQL Server架构遭受了这种限制。随着共享内存多处理器在90年代早期变得越来越流行，Sybase迅速对体系结构进行了修改，以利用多个操作系统进程。</p>
<p>​    当在多个进程中运行DBMS线程时，有时一个进程有大量的工作，而其他进程（因此处理器）是空闲的。要使该模型在这些情况下正常工作，DBMSs必须在进程之间实现线程迁移。IBM Informix从6.0版本开始在这方面做得非常出色。</p>
<p>​     当将DBMS线程映射到多个操作系统进程时，需要决定使用多少操作系统进程，如何将DBMS线程分配给操作系统线程，以及如何跨多个操作系统进程进行分布。一个好的经验法则是每个物理处理器有一个进程。这最大化了硬件中固有的物理并行性，同时最小化了每个进程的内存开销。</p>
<h2 id="36-standard-practice"><a class="markdownIt-Anchor" href="#36-standard-practice"></a> 3.6 Standard Practice</h2>
<p>关于对并行性的支持，趋势与上一节类似：大多数主要的 DBMSs 都支持多个并行性模型。由于共享内存系统（SMPs、多核系统以及两者的组合）在商业上的流行，所有主要的DBMS供应商都很好地支持共享内存并行。在多节点集群并行中，我们开始看到支持上的分歧，其中广泛的设计选择是shared-nothing和shared-disk。</p>
<ul>
<li>shared-memory：所有主要的商业DBMS提供商都支持共享内存并行性，包括：IBM DB2、Oracle和Microsoft SQL Server。</li>
<li>shared-nothing：此模型由IBM DB2、Informix、Tandem和NCR Teradata等支持；Green-plum提供了一个自定义版本的PostgreSQL，它支持shared-nothing并行。</li>
<li>shared-disk：该模型由Oracle RAC、RDB（由Oracle从Digital Equipment Corp.收购）和IBM DB2 for zSeries等支持。</li>
</ul>
<p>IBM销售多种不同的DBMS产品，并选择在一些产品中实现shared-disk支持，而在另一些产品中shared-nothing。到目前为止，没有一个领先的商业系统在一个代码库中同时支持shared-nothing和shared-disk；Microsoft SQL Server都没有实现。</p>
<h2 id="37-discussion-and-additional-material"><a class="markdownIt-Anchor" href="#37-discussion-and-additional-material"></a> 3.7 Discussion and Additional Material</h2>
<p>上面的设计代表了在各种服务器系统中使用的硬件/软件体系结构模型的选择。虽然它们主要是在dbms中首创的，但这些想法在其他数据密集型领域也越来越流行，包括低层可编程数据处理后端，如Map-Reduce，它正在增加各种自定义数据分析任务的用户。然而，即使这些想法正在更广泛地影响计算，在数据库系统的并行性设计中也出现了新的问题。</p>
<p>​    在接下来的十年中，并行软件架构面临的一个关键挑战来自于开发新一代“多核”架构的愿望，这些架构来自处理器供应商。这些设备将引入一个新的硬件设计点，在单个芯片上有数十、数百甚至数千个处理单元，通过高速片上网络进行通信，但在访问片外存储器和磁盘方面保留了许多现有的瓶颈。这将导致磁盘和处理器之间的内存路径出现新的不平衡和瓶颈，这几乎肯定需要重新检查DBMS体系结构，以满足硬件的性能潜力。</p>
<p>​     在面向服务的计算领域，在更“macro(宏观)”的范围内，某种程度上相关的架构转变正在被预见。这里的想法是，拥有数万台计算机的大型数据中心将为用户托管处理（硬件和软件）。在这种规模下，只有高度自动化的应用程序和服务器管理才能负担得起。没有任何管理任务可以随着服务器数量的增加而扩展。而且，由于通常使用不太可靠的商用服务器，并且故障更常见，因此需要完全自动化地从常见故障中恢复。在大规模的服务中，每天都会出现磁盘故障，每周会出现几个服务器故障。在这种环境中，管理数据库备份通常由存储在不同磁盘上的不同服务器上维护的整个数据库的冗余在线副本取代。根据数据的值（value，或者翻译成价值？），冗余副本甚至可以存储在不同的数据中心中。自动脱机备份仍可用于从应用程序、管理或用户错误中恢复。但是，从大多数常见错误和故障中恢复是快速故障转移到冗余在线副本。冗余可以通过多种方式实现：（a）数据存储级的复制（存储区域网络）；（b）数据库存储引擎级别的数据复制（如7.4节所述）；（c）查询处理器对查询的冗余执行（第6节）；（d）冗余的数据库请求在客户端软件级别自动生成（例如，由web服务器或应用服务器）。</p>
<p>​    在更解耦的级别上，在实践中，将具有DBMS功能的多个服务器分层部署是非常常见的，目的是尽量减少对“DBMS of record”的I/O请求率。这些模式包括用于SQL查询的各种形式的中间层数据库缓存，包括专用的主存数据库，如Oracle TimesTen，以及配置用于此目的的更传统的数据库。在部署堆栈的上层，可以配置许多面向对象的应用程序服务器体系结构，支持诸如Enterprise Java Beans之类的编程模型，以便与DBMS一起对应用程序对象进行事务性缓存。然而，这些不同方案的选择、设置和管理仍然是非标准的和复杂的，而优雅的普遍认可的模型仍然是难以捉摸的。</p>
<h1 id="4-relational-query-processor"><a class="markdownIt-Anchor" href="#4-relational-query-processor"></a> 4 Relational Query Processor</h1>
<p>前几节强调了DBMS中的宏观体系结构设计问题。现在我们开始以更精细的方式讨论设计，依次处理每个主要的DBMS组件。根据我们在1.1节中的讨论，我们将从系统的顶部开始，从查询处理器开始，然后在随后的部分中向下讨论存储管理、事务和实用程序。</p>
<p>​    关系查询处理器接受声明性SQL语句，对其进行验证，将其优化为过程性数据流执行计划，然后（在admission control准入控制下）代表客户机程序执行该数据流程序。然后，客户端程序获取（“提取”）结果元组，通常是一次一个或小批量地获取。关系查询处理器的主要组件如图1.1所示。在本节中，我们将关注查询处理器和存储管理器访问方法的一些非事务性方面。一般来说，关系查询处理可以看作是单用户、单线程的任务。并发控制由系统的较低层透明地管理，如第5节所述。这条规则的唯一例外是，当DBMS在操作缓冲池页面时，必须显式地“固定”和“解固定”缓冲池页面，以便它们在短暂的关键操作期间留在内存中，我们将在4.4.5节中讨论。</p>
<p>​     在本节中，我们将重点讨论常见的SQL命令：数据操作语言（DML）语句，包括SELECT、INSERT、UPDATE和DELETE。数据定义语言（DDL）语句，如CREATE TABLE和CREATE INDEX，通常不由查询优化器处理。这些语句通常在静态DBMS逻辑中通过显式调用存储引擎和目录管理器（见6.1节）实现。一些产品也开始优化DDL语句的一小部分，我们预计这一趋势将继续下去。</p>
<h2 id="41-query-parsing-and-authorization"><a class="markdownIt-Anchor" href="#41-query-parsing-and-authorization"></a> 4.1 Query Parsing and Authorization</h2>
<p>给定一个SQL语句，SQL Parser的主要任务是：(1)检查查询是否被正确指定，(2)解析名称和引用，(3)将查询转换为优化器使用的内部格式，以及(4)验证用户是否被授权执行查询。有些 DBMSs 将部分或全部安全检查推迟到执行时进行，但是，即使在这些系统中，解析器仍然负责收集执行时安全检查所需的数据。</p>
<p>​     给定一个SQL查询，解析器首先考虑FROM子句中的每个表引用。它将表名规范化为server.database.schema.table格式的完全限定名。这也被称为四部分命名。不支持跨多个服务器查询的系统只需要规范化到database.schema。对于只支持一个数据库的DBMS系统可以规范化为schema.table。这种规范化是必需的，因为用户具有上下文相关的默认值。有些系统支持一个表的多个名称，称为表别名，这些名称也必须用完全限定的表名称替换。</p>
<p>​	规范化表名之后，查询处理器调用 catalog manager (目录管理器)来检查表是否已在系统编目中注册。在此步骤中，它还可以在内部查询数据结构中缓存关于表的元数据。然后，根据表的信息，它使用编目来确保属性引用是正确的。属性的数据类型用于驱动重载函数表达式、比较运算符和常量表达式的消歧逻辑。例如，考虑表达式(EMP.salary * 1.15) &lt; 75000。乘法函数和比较运算符的代码以及假定的数据类型和字符串“1.15”和“75000”的内部格式将取决于empp .salary属性的数据类型。该数据类型可以是整数、浮点数或“货币”值。还应用了其他标准SQL语法检查，包括元组变量的一致性使用、通过集合操作符（UNION/INTERSECT/EXCEPT）组合的表的兼容性、聚合查询的SELECT列表中属性的使用、子查询的嵌套等等。</p>
<p>​     如果查询解析成功，下一个阶段是授权检查，以确保用户对查询中引用的表、用户定义函数或其他对象具有适当的权限（SELECT/DELETE/INSERT/UPDATE）。有些系统在语句解析阶段执行完整的授权检查。然而，这并不总是可能的。例如，支持行级安全性的系统在执行之前不能进行完整的安全性检查，因为安全性检查可能依赖于数据值。即使理论上可以在编译时静态验证授权，但将某些工作推迟到查询计划执行时也有好处。将安全检查推迟到执行时间的查询计划可以在用户之间共享，并且在安全性更改时不需要重新编译。因此，安全验证的某些部分通常延迟到查询计划执行。</p>
<p>​	在编译期间也可以对常量表达式进行约束检查。例如，UPDATE命令可能有一个形式为SET EMP.salary = -1的子句。如果完整性约束为薪金指定了正值，则甚至不需要执行查询。然而，将这项工作推迟到执行时间是很常见的。</p>
<p>​    如果查询解析并通过验证，则将查询的内部格式传递给查询重写模块以进行进一步处理。</p>
<h2 id="42-query-rewrite"><a class="markdownIt-Anchor" href="#42-query-rewrite"></a> 4.2 Query Rewrite</h2>
<p>查询重写模块（或rewriter）负责在不更改其语义的情况下简化和规范化查询。它只能依赖于查询和目录中的元数据，而不能访问表中的数据。虽然我们说“重写”查询，但大多数重写器实际上是在查询的内部表示上操作，而不是在原始SQL语句文本上操作。（注：这是显然的，因为DBMS其实无法理解SQL字符串，直接在内部表达中进行修改）查询重写模块通常以其在输入时接受的相同内部格式输出查询的内部表示形式。</p>
<p>许多商业系统中的重写器是一个逻辑组件，其实际实现要么在查询解析的后期阶段，要么在查询优化的早期阶段。例如，在DB2中，重写器是一个独立的组件，而在SQL Server中，查询重写是作为query Optimizer的早期阶段完成的。尽管如此，单独考虑重写器是有用的，即使显式架构边界并不存在于所有系统中。</p>
<p>​    重写器的主要责任是：</p>
<ul>
<li>
<p>View expansion（视图扩张）：处理视图是重写器的主要传统角色。对于出现在FROM子句中的每个视图引用，重写器从编目管理器检索视图定义。然后将查询重写为（1）将该视图替换为该视图和引用的表和谓词（2）将对该视图的任何引用替换为对视图中表的列引用。此过程递归地应用，直到查询仅在表上表示且不包含视图。这种视图扩展技术最初是在INGRES中为基于集合的QUEL语言提出的，它需要在SQL中小心地正确处理重复消除、嵌套查询、null和其他棘手的细节。</p>
</li>
<li>
<p>Constant arithmetic evaluation（常量算数求值）：查询重写可以简化常量算术表达式：例如，R.x &lt; 10 + 2 + R.y 被重写为R.x &lt; 12 + R.y。</p>
</li>
<li>
<p>Logical rewriting of predicates（谓词的逻辑重写）：基于WHERE子句中的谓词和常量应用逻辑重写。简单的布尔逻辑通常用于改进表达式之间的匹配和基于索引的访问方法的功能。例如，NOT EMP.Salary &gt; 1000000这样的谓词可以重写为EMP.Salary &lt;= 1000000。通过简单的可满足性测试，这些逻辑重写甚至可以缩短查询执行时间。例如，表达式EMP.Salary &lt; 75000 AND EMP.Salary &gt; 1000000可以替换为FALSE。这可能允许系统在不访问数据库的情况下返回空查询结果。无法满足的查询可能看起来难以置信，但请记住，谓词可能“隐藏”在视图定义中，外部查询的编写者不知道。例如，上面的查询可能是在一个名为“Executives”的视图上查询工资过低的员工的结果。在Microsoft SQL Server的并行安装中，不可满足的谓词也构成了“分区消除”的基础：当一个关系通过范围谓词在磁盘卷上进行水平范围分区时，如果它的范围分区谓词与查询谓词一起不能满足，则不需要在卷上运行查询。</p>
<p>​    另一个重要的逻辑重写使用谓词的传递性来引出新的谓词R.x &lt; 10 AND R.x = S.y，例如，建议添加额外的谓词“AND S.y &lt; 10”。添加这些传递谓词可以提高优化器选择在执行早期过滤数据的计划的能力，特别是通过使用基于索引的访问方法。</p>
</li>
<li>
<p>Semantic optimization（语义优化）：在许多情况下，模式上的完整性约束存储在编目中，可以用来帮助重写一些查询。这种优化的一个重要例子是消除冗余连接（redundant join elimination）。当外键约束将一个表（例如，Emp.deptno）的列绑定到另一个表（Dept）时，就会出现这种情况。给定这样的外键约束，我们知道每个Emp都有一个Dept，并且如果没有相应的Dept元组（父元组），Emp元组就不可能存在。</p>
<p>考虑一个连接两个表但不使用Dept列的查询：</p>
</li>
</ul>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Emp.name, Emp.salary</span><br><span class="line">	<span class="keyword">FROM</span> Emp, Dept</span><br><span class="line">	<span class="keyword">WHERE</span> Emp.deptno <span class="operator">=</span> Dept.dno</span><br></pre></td></tr></tbody></table></figure>
<p>​      这样的查询可以重写以删除Dept表（假设Emp.deptno被约束为非空），从而删除连接。同样，这些看似不可信的场景往往是通过观点自然产生的。例如，用户可以在连接这两个表的视图EMPDEPT上提交关于雇员属性的查询。像Siebel这样的数据库应用程序使用非常宽的表，当底层数据库不支持足够宽的表时，它们使用多个表，并在这些表上显示视图。如果没有冗余连接消除，这个基于视图的可扩展实现的性能将非常差。</p>
<p>​       当表上的约束与查询谓词不兼容时，语义优化还可以完全规避查询执行。</p>
<ul>
<li>Subquery flattening and other heuristic rewrites（子查询扁平化和其他启发式重写）：查询优化器是当前一代商业dbms中最复杂的组件之一。为了限制复杂性，大多数优化器对单独的SELECTFROM-WHERE查询块进行隔离操作，并且不会跨块进行优化。因此，许多系统将查询重写为更适合优化器的形式，而不是使查询优化器进一步复杂化。这种转换有时称为查询规范化。规范化的一个示例类是将语义等价的查询重写为规范形式，以确保语义等价的查询将被优化以生成相同的查询计划。另一个重要的启发式方法是尽可能平坦嵌套查询，以最大限度地暴露查询优化器的单块优化机会。在SQL的某些情况下，由于重复语义、子查询、空值和相关性等问题，这变得非常棘手。在早期，子查询扁平化是一种纯粹的启发式重写，但现在一些产品基于基于成本的分析来重写决策。其他改写也可以跨查询块进行。例如，谓词传递性允许跨子查询复制谓词。扁平化相关子查询对于在并行体系结构中实现良好的性能尤其重要：相关子查询导致跨查询块的“嵌套循环”风格比较，这将子查询的执行序列化，而不管并行资源是否可用。</li>
</ul>
<h2 id="43-query-optimizer"><a class="markdownIt-Anchor" href="#43-query-optimizer"></a> 4.3 Query Optimizer</h2>
<p><img src="/img/Architecture%20Of%20a%20Database%20System/image-20250405112751012.png" alt="image-20250405112751012"></p>
<p>查询优化器的工作是将内部查询表示转换为执行查询的有效查询计划（图4.1）。可以将查询计划看作是一个数据流图，它通过查询操作符的图来输送表数据。在许多系统中，查询首先被分解为SELECT-FROM-WHERE查询块。然后使用与Selinger等人在System R优化器的著名论文中描述的技术类似的技术来优化每个单独的查询块。完成后，通常在每个查询块的顶部添加一些操作符，作为后处理来计算GROUP BY、ORDER BY、HAVING和DISTINCT子句（如果它们存在）。然后将不同的块以直接的方式拼接在一起。</p>
<p>​    生成的查询计划可以用多种方式表示。最初的System R原型将查询计划编译成机器码，而早期的INGRES原型生成可解释的查询计划。查询解释被INGRES的作者在20世纪80年代早期的回顾性论文中列为“错误”，但摩尔定律和软件工程在某种程度上证明了INGRES的决定是正确的。具有讽刺意味的是，编译成机器码被System R项目的一些研究人员列为错误。当System R代码库被制作成商业DBMS系统（SQL/DS）时，开发团队的第一个变化是用解释器取代机器码执行器。</p>
<p>​    为了实现跨平台的可移植性，现在每个主要的DBMS都将查询编译成某种可解释的数据结构。它们之间唯一的区别是中间形式的抽象程度。某些系统中的查询计划是一个非常轻量级的对象，与关系代数表达式没有什么不同，它用访问方法、连接算法等名称进行了注释。其他系统使用较低级别的“操作码”语言，在本质上更接近Java字节码，而不是关系代数表达式。为了简化我们的讨论，我们将在本文的其余部分集中讨论类似代数的查询表示。</p>
<p>​    虽然Selinger的论文被广泛认为是查询优化的“圣经”，但它是初步的研究。所有的系统都在许多方面显著地扩展了这项工作。主要扩展包括：</p>
<ul>
<li>
<p>Plan space（规划空间）：System R优化器通过只关注“左深”查询计划（其中连接的右侧输入必须是基表）和“延迟笛卡尔积”（确保笛卡尔积仅在数据流中的所有连接之后出现）来限制其计划空间。在今天的商业系统中，众所周知，“浓密”树（嵌套的右侧输入）和早期使用笛卡尔积在某些情况下是有用的。因此，在某些情况下，大多数系统都会考虑这两种选择。</p>
</li>
<li>
<p>Selectivity stimation（选择性估计）：Selinger论文中的选择性估计技术基于简单的表和索引基数，并且根据当前生成系统的标准是不可靠的。今天的大多数系统通过直方图和其他汇总统计来分析和总结属性中值的分布。由于这涉及到访问每列中的每个值，因此可能会相对昂贵。因此，一些系统使用抽样技术来获得分布的估计，而不需要穷举扫描。</p>
<p>​    基表连接的选择性估计可以通过“连接”连接列上的直方图来实现。为了超越单列直方图，最近提出了更复杂的方案来合并列之间的依赖关系等问题。这些创新已经开始出现在商业产品中，但仍需取得相当大的进展。这些模式采用缓慢的一个原因是许多行业基准中存在一个长期存在的缺陷：像TPC-D和TPC-H这样的基准中的数据生成器在列中生成统计独立的值，因此不鼓励采用处理“真实”数据分布的技术。这个基准测试缺陷已经在TPC-DS基准测试中得到了解决。尽管采用率较低，但改进的选择性估计的好处已得到广泛认可。Ioannidis和Christodoulakis注意到，在优化早期的选择性错误会成倍地传播到计划树中，并导致糟糕的后续估计。</p>
</li>
<li>
<p>Search Algorithms（搜索算法）：一些商业系统，特别是微软和Tandem的系统，放弃了Selinger的动态规划优化方法，转而采用基于Cascades中使用的技术的目标导向的“自上而下”搜索方案。在某些情况下，自顶向下搜索可以减少优化器考虑的计划数量，但也会产生增加优化器内存消耗的负面影响。如果实际的成功是质量的标志，那么在自顶向下搜索和动态规划之间的选择是无关紧要的。在最先进的优化器中，这两种方法都可以很好地工作，但不幸的是，这两种方法都有运行时和内存需求，这些需求在查询中的表数量上呈指数级增长。</p>
<p>​    有些系统依靠启发式搜索方案来处理“太多”表的查询。尽管随机查询优化启发式的研究文献很有趣，但商业系统中使用的启发式往往是专有的，显然不像随机查询优化文献。一个具有教育意义的练习是检查开源MySQL引擎的查询“优化器”，最后检查完全是启发式的，主要依赖于利用索引和键/外键约束。这让人想起Oracle的早期（和臭名昭著的）版本。在某些系统中，只有当用户明确指示优化器如何选择计划（通过SQL中嵌入的所谓优化器“提示”）时，才能执行FROM子句中包含太多表的查询。</p>
</li>
<li>
<p>Parallelism（并行）：目前，每个主要的商业DBMS都对并行处理提供了一些支持。大多数还支持“查询内”并行：通过使用多个处理器加速单个查询的能力。查询优化器需要参与确定如何跨多个cpu调度操作符（和并行化操作符），以及（在无共享或共享磁盘的情况下）跨多个单独的计算机调度操作符。Hong和Stonebraker选择避免并行优化的复杂性问题，并使用两个阶段：首先调用传统的单系统优化器来选择最佳的单系统计划，然后跨多个处理器或机器调度该计划。（注：这里的意思应该是不让查询优化器考虑如何处理多核调度，而是把这个责任转交给了查询执行器。）关于第二个优化阶段的研究已经发表，但尚不清楚这些结果在多大程度上影响了当前的实践。</p>
<p>​    一些商业系统实现了上面描述的两阶段方法。其他人则尝试对集群网络拓扑和跨集群的数据分布进行建模，以便在单个阶段生成最佳计划。虽然在某些情况下，单阶段方法可以产生更好的计划，但是尚不清楚使用单阶段方法可能获得的额外查询计划质量是否值得额外的优化器复杂性。因此，许多当前的实现仍然支持两阶段方法。目前这个领域似乎更像是艺术而不是科学。Oracle OPS（现在称为RAC）共享磁盘集群使用两阶段优化器。IBM DB2 Parallel Edition（现在称为DB2 Database Partitioning Feature）最初是使用两阶段优化器实现的，但后来逐渐向单阶段实现发展。</p>
</li>
<li>
<p>Auto-Tuning（自动调谐）：各种正在进行的工业研究努力试图提高DBMS自动做出调优决策的能力。其中一些技术基于收集查询工作负载，然后使用优化器通过各种“假设”分析来查找计划成本。例如，如果存在其他索引或数据以不同的方式布局，情况会怎样？正如Chaudhuri和Narasayya所描述的那样，优化器需要进行一些调整以有效地支持此活动。Markl等人的学习优化器（LEO）工作也是这样。</p>
<h3 id="431-a-note-on-query-compilation-and-recompilation"><a class="markdownIt-Anchor" href="#431-a-note-on-query-compilation-and-recompilation"></a> 4.3.1 A Note on Query Compilation and Recompilation</h3>
</li>
</ul>
<p>SQL支持“准备”查询的能力：通过解析器、重写器和优化器传递查询，存储结果查询执行计划，并在随后的“执行”语句中使用它。这甚至可以用于动态查询（例如，从web表单），其中有程序变量在查询常量的位置。唯一的问题是，在选择性估计期间，优化器假定表单提供的变量为“典型”值。当选择非代表性的“典型”值时，可能会导致非常糟糕的查询执行计划。查询准备对于基于相当可预测的数据的表单驱动的预制查询（canned queries）特别有用：在编写应用程序时准备查询，当应用程序运行时，用户不会经历解析、重写和优化的开销。</p>
<p>​    尽管在编写应用程序时准备查询可以提高性能，但这是一个非常严格的应用程序模型。许多应用程序程序员以及Ruby on Rails等工具包在程序执行期间动态构建SQL语句，因此预编译不是一个选项。因为这很常见，DBMS将这些动态查询执行计划存储在查询计划缓存中。如果随后提交相同（或非常相似）的语句，则使用缓存版本。这种技术近似于没有应用程序模型限制的预编译静态SQL的性能，并且被大量使用。</p>
<p>​    当数据库随时间变化时，通常需要重新优化准备好的计划。至少，当删除索引时，必须从存储的计划缓存中删除任何使用该索引的计划，以便在下次调用时选择新计划。</p>
<p>​    其他关于重新优化计划的决策更加微妙，暴露了供应商之间的哲学差异。一些供应商（例如，IBM）非常努力地提供跨调用的可预测性能，而牺牲了每个调用的最佳性能。（注：也就是尽可能减少编译次数，为此牺牲了每次执行的速度。）因此，除非计划不再执行，否则他们不会重新优化计划，就像删除索引的情况一样。其他供应商（例如Microsoft）非常努力地使他们的系统自我调整，并将更积极地重新优化计划。例如，如果表的基数发生重大变化，SQL服务器将触发重新编译，因为此更改可能会影响索引和连接顺序的最佳使用。自调整系统可以说不太可预测，但在动态环境中更有效。</p>
<p>​    这种哲学上的区别源于这些产品历史客户群的差异。IBM传统上专注于拥有熟练DBA和应用程序程序员的高端客户。在这些高预算的信息技术商店中，数据库的可预测性能至关重要。在花了几个月的时间调整数据库设计和设置后，数据库管理员不希望优化器不可预测地改变它。相比之下，微软战略性地进入低端数据库市场。因此，他们的客户往往拥有较低的信息技术预算和专业知识，并希望数据库管理系统尽可能地“自我调整”。</p>
<p>​    随着时间的推移，这些公司的业务战略和客户群已经融合，因此它们直接竞争，它们的方法也在一起发展。微软有希望完全控制和查询计划稳定性的大型企业客户。IBM有一些客户没有数据库管理员资源，需要完全自动管理。</p>
<h2 id="44-query-executor"><a class="markdownIt-Anchor" href="#44-query-executor"></a> 4.4 Query  Executor</h2>
<p><img src="/img/Architecture%20Of%20a%20Database%20System/image-20250405155953569.png" alt="image-20250405155953569"></p>
<p>查询执行器在完全指定的查询计划上运行。这通常是一个有向数据流图，它连接封装基表访问和各种查询执行算法的运算符。在某些系统中，这个数据流图已经被优化器编译成低级操作码。在这种情况下，查询执行器基本上是一个运行时解释器。在其他系统中，查询执行器接收数据流图的表示，并基于图布局递归地为运算符调用过程。我们关注后一种情况，因为操作码方法本质上是将我们在这里描述的逻辑编译成程序。</p>
<p>​    大多数现代查询执行器使用最早的关系系统中使用的迭代器模型。迭代器最简单地以面向对象的方式描述。图4.2显示了迭代器的简化定义。每个迭代器指定其定义数据流图中边的输入。查询计划中的所有运算符-数据流图中的节点-都实现为迭代器类的子类。一个典型系统中的子类集可能包括filescan、indexcan、sor、nested-loops connect、mery-connect、hashconnect、duplicate-elimination和grouped-aggregation。迭代器模型的一个重要特征是迭代器的任何子类都可以用作任何其他子类的输入。因此，每个迭代器的逻辑独立于图中的子级和父级，并且不需要迭代器特定组合的特殊情况代码。</p>
<p>​    Graefe在他的查询执行调查中提供了有关迭代器的更多详细信息。还鼓励感兴趣的读者检查开源PostgreSQL代码库。PostgreSQL对大多数标准查询执行算法使用了适度复杂的迭代器实现。</p>
<h3 id="441-iterator-discussion"><a class="markdownIt-Anchor" href="#441-iterator-discussion"></a> 4.4.1 Iterator Discussion</h3>
<p>迭代器的一个重要特性是它们将数据流与控制流耦合。get _next() 调用是一个标准过程调用，它通过调用堆栈返回对调用者的元组引用。因此，当返回控制时，元组将准确地返回给图中的父级。这意味着只需要一个DBMS线程来执行整个查询图，并且不需要队列或迭代器之间的速率匹配。这使得关系查询执行器易于实现和调试，并且与其他环境中的数据流架构形成对比。例如，网络依赖于各种协议在并发生产者和消费者之间进行排队和反馈。</p>
<p>​    单线程迭代器架构对于单系统（非集群）查询执行也非常有效。在大多数数据库应用程序中，性能指标是查询完成的时间，但其他优化目标也是可能的。例如，最大化DBMS吞吐量是另一个合理的目标。交互式应用程序中流行的另一个目标是第一行的时间。在单处理器环境中，当资源得到充分利用时，给定查询计划的完成时间就实现了。在迭代器模型中，由于其中一个迭代器始终处于活动状态，因此资源利用率最大化。</p>
<p>​    正如我们之前提到的，大多数现代DBMS都支持并行查询执行。幸运的是，这种支持基本上无需更改迭代器模型或查询执行架构即可提供。并行性和网络通信可以封装在特殊的交换迭代器中，如Graefe所述；这些还以DBMS迭代器不可见的方式实现网络风格的数据“推送”，这些迭代器保留了“拉”风格的get_next() API。一些系统也在其查询执行模型中明确了推送逻辑。</p>
<h3 id="442-wheres-the-data"><a class="markdownIt-Anchor" href="#442-wheres-the-data"></a> 4.4.2 Where’s the Data?</h3>
<p>我们对迭代器的讨论方便地回避了任何关于动态数据的内存分配问题。我们既没有指定元组如何存储在内存中，也没有指定它们如何在迭代器之间传递。在实践中，每个迭代器都预先分配了固定数量的元组描述符，一个用于每个输入，一个用于输出。元组描述符通常是列引用的数组，其中每个列引用由对内存中其他地方的元组的引用和该元组中的列偏移量组成。（注：元组描述符不是元组本体，相当于一个指针。）基本迭代器超类逻辑从不动态分配内存。这就提出了被引用的实际元组存储在内存中的位置的问题。</p>
<p>​    这个问题有两个可能的答案。第一个是元组驻留在缓冲池的页面中。我们称之为BP元组。如果迭代器构造了一个引用BP元组的元组描述符，它必须增加元组页面的pin计数——对该页面上元组的活动引用数量的计数。当元组描述符被清除时，它会减少引脚计数。第二种可能性是迭代器实现可以为内存堆上的元组分配空间。我们称之为M元组。迭代器可以通过从缓冲池中复制列（由引脚增量/减量对括起来的副本）和/或通过评估特定查询中的表达式（例如，算术表达式，如“EM. sal * 0.1”）来构造M元组。</p>
<p>​    一种通用方法是始终将数据立即从缓冲池中复制到M元组中。这种设计使用M元组作为唯一的机上元组结构并简化了执行器代码。该设计还避免了由于缓冲池pin和unpin调用被长时间执行（以及许多行代码）分开而导致的错误。这种类型的一个常见bug是忘记完全取消页面的别针（“缓冲区泄漏”）。不幸的是，如第4.2节所述，独占使用M元组可能是一个主要的性能问题，因为内存副本通常是高性能系统中的严重瓶颈。（注：？第4.2节好像没讲这个啊）</p>
<p>​    另一方面，在某些情况下构造M元组是有意义的。只要BP元组被迭代器直接引用，BP元组所在的页面就必须保持固定在缓冲池中。这会消耗相当于一页的缓冲池内存，并束缚缓冲区替换策略的手脚。如果元组将在很长一段时间内继续被引用，则从缓冲池中复制元组可能会很有用。</p>
<p>​    这个讨论的结果是，最有效的方法是支持可以同时引用BP元组和M元组的元组描述符。</p>
<h3 id="443-data-modification-statements"><a class="markdownIt-Anchor" href="#443-data-modification-statements"></a> 4.4.3 Data Modification Statements</h3>
<p><img src="/img/Architecture%20Of%20a%20Database%20System/image-20250405165141202.png" alt="image-20250405165141202"></p>
<p>到目前为止，我们只讨论了查询，即只读SQL语句。存在另一类修改数据的DML语句：INSERT、DELETE和UPDATE语句。这些语句的执行计划通常看起来像简单的直线查询计划，以单个访问方法作为源，并在管道的末尾使用数据修改运算符。</p>
<p>​    然而，在某些情况下，这些计划同时查询和修改相同的数据。读取和写入同一个表（可能多次）的混合需要一些小心。一个简单的例子是臭名昭著的“万圣节问题”，之所以如此称呼，是因为它是由System R小组在10月31日发现的。</p>
<p>万圣节的问题来自于一个特定的执行策略，比如“给工资低于2万美元的人加薪10%”这个查询的一个简单计划将一个索引扫描迭代器通过Emp.salary字段管道到一个更新迭代器中（图4.3的左侧）。这个流水线提供了良好的I/O局部性，因为它会在元组从B+树中获取后对其进行修改。然而，这种流水线也可能导致索引扫描“重新发现(rediscovering)”以前修改过的元组，该元组在修改后在树中向右移动，从而导致每个员工多次加薪。在我们的例子中，所有低薪员工都会得到反复加薪，直到他们挣得超过2万美元。这不是声明的意图。</p>
<p>​    SQL语义禁止这种行为：单个SQL语句不允许“看到”自己的更新。需要注意确保遵守此可见性规则。一个简单、安全的实现是查询优化器选择避免更新列上索引的计划。在某些情况下，这可能效率很低。另一种技术是使用批量读写方案。这将在数据流中的索引扫描和数据修改运算符之间插入记录ID物化和获取运算符（图4.3的右侧）。物化运算符接收所有要修改的元组的ID并将它们存储在临时文件中。然后它扫描临时文件并通过RID获取每个物理元组ID，并将生成的元组提供给数据修改运算符。如果优化器选择一个索引，在大多数情况下，这意味着只有几个元组被更改。因此，这种技术的明显低效可能是可以接受的，因为临时表可能完全保留在缓冲池中。流水线更新方案也是可能的，但需要来自存储引擎的（有点奇特的）多版本支持。</p>
<h2 id="45-access-methods"><a class="markdownIt-Anchor" href="#45-access-methods"></a> 4.5 Access Methods</h2>
<p>访问方法是管理对系统支持的各种基于磁盘的数据结构的访问的例程。这些通常包括无序文件（“堆”）和各种索引。所有主要的商业系统都实现堆和B+树索引。Oracle和PostgreSQL都支持用于相等查找的哈希索引。一些系统开始引入对多维索引的基本支持，例如R-tree。PostgreSQL支持一种称为通用搜索树（GiST）的可扩展索引，目前使用它来实现多维数据的R-tree和文本数据的RD-tree。IBMUDB版本8引入了多维集群（MDC）索引，用于通过多维范围访问数据。以读取为主的数据仓库工作负载为目标的系统通常还包括索引的专门位图变体，正如我们在第4.6节中描述的那样。</p>
<p>​    访问方法提供的基本API是迭代器API。init()例程被扩展为接受表单列运算符constant的“搜索参数”（或在System R的术语中，SARG）。NULL SARG被视为扫描表中所有元组的请求。当没有更多元组满足搜索参数时，访问方法层的get next()调用返回NULL。</p>
<p>​    将SARG传递到访问方法层有两个原因。第一个原因应该很清楚：像B+树这样的索引访问方法需要SARG才能有效运行。第二个原因是一个更微妙的性能问题，但它适用于堆扫描和索引扫描。假设调用访问方法层的例程检查了SARG。然后每次访问方法从get next（）返回时，它必须要么（a）返回驻留在缓冲池中帧中的元组的句柄，并将页面固定在该帧中以避免替换，要么（b）复制元组。如果调用者发现SARG不满足，它负责（a）减少页面上的pin计数，或（b）删除复制的元组。然后它必须重新调用get next（）来尝试页面上的下一个元组。这种逻辑在函数调用/返回对中消耗了大量的CPU周期，并且会不必要地将页面固定在缓冲池中（为缓冲帧产生不必要的争用），或者不必要地创建和销毁元组的副本——在流式传输数百万个元组时，这是一个巨大的CPU开销。请注意，典型的堆扫描将访问给定页面上的所有元组，导致每个页面多次迭代此交互。相比之下，如果所有这些逻辑都在访问方法层完成，则可以通过一次测试SARG页面来避免重复的调用/返回以及pin/unpin或复制/删除，并且只从满足SARG的元组的get next()调用中返回。SARGS在存储引擎和关系引擎之间保持了良好的架构边界，同时获得了出色的性能。（注：这就是谓词下推罢，将筛选的逻辑下推到下层算子甚至访问层）因此，许多系统支持非常丰富的SARG支持并广泛使用它们。就主题而言，这是标准DBMS智慧在集合中的多个项目之间摊销工作的一个实例，但在这种情况下，它被应用于CPU性能，而不是磁盘性能。</p>
<p>​    所有DBMS都需要某种方式来“指向”基表中的行，以便索引条目可以适当地引用行。在许多DBMS中，这是通过使用直接行ID（RID）来实现的，这些行ID是基表中行的物理磁盘地址。这样做的好处是速度快，但缺点是基表行移动非常昂贵，因为指向该行的所有辅助索引都需要更新。查找和更新这些行可能都很昂贵。当更新更改行大小并且当前页面上的空间不可用于新更新的行时，行需要移动。当拆分B+树时，许多行需要移动。DB2使用转发指针来避免第一个问题。这需要第二个I/O来查找移动的页面，但避免了更新辅助索引。DB2通过简单地不支持B+树作为基表元组的主存储来避免第二个问题。MicrosoftSQLServer和Oracle支持B+树作为主存储，并且必须能够有效地处理行移动。采用的方法是避免在辅助索引中使用物理行地址，而是使用行主键（如果表没有唯一键，则使用一些额外的系统提供的位来强制唯一性）而不是物理RID。这在使用辅助索引访问基表行时牺牲了一些性能，但避免了行移动导致的问题。在某些情况下，Oracle通过保留带有主键的物理指针来避免这种方法的性能损失。如果该行没有移动，将使用物理指针快速找到它。但是，如果它已经移动，将使用较慢的主键技术。</p>
<p>​     Oracle通过允许行跨越页面来避免移动堆文件中的行。因此，当一行更新为不再适合原始页面的更长值时，而不是被迫移动行，它们存储适合原始页面的内容，其余部分可以跨越到下一个页面。</p>
<p>​    与所有其他迭代器相比，访问方法与围绕事务的并发和恢复逻辑具有深度交互，如第4节所述。</p>
<h2 id="46-data-warehouses"><a class="markdownIt-Anchor" href="#46-data-warehouses"></a> 4.6 Data Warehouses</h2>
<p>数据仓库——用于决策支持的大型历史数据库，定期加载新数据——已经发展到需要专门的查询处理支持，在下一节中，我们将概述它们往往需要的一些关键功能。这个主题与两个主要原因相关：</p>
<ol>
<li>数据仓库是DBMS技术的一个非常重要的应用。有人声称仓库占所有DBMS活动的1/3。</li>
<li>本节到目前为止讨论的传统查询优化和执行引擎在数据仓库上不能很好地工作。因此，需要扩展或修改才能获得良好的性能。</li>
</ol>
<p>关系DBMS最初是在20世纪70年代和80年代设计的，目的是满足业务数据处理应用程序的需求，因为这是当时的主要需求。20世纪90年代初，数据仓库和“业务分析”市场出现，并从那时起急剧增长。</p>
<p>​    到20世纪90年代，联机事务处理取代了批处理业务数据，成为数据库使用的主要模式。此外，大多数联机事务处理系统都有计算机操作员银行提交交易，要么通过与最终客户的电话交谈，要么通过从纸上输入数据。自动柜员机已经普及，允许客户在没有操作员干预的情况下直接进行某些交互。此类交易的响应时间对产品至关重要。随着网络迅速用最终客户的自助服务取代运营商，这种响应时间要求在今天变得更加紧迫和多样化。</p>
<p>​    大约在同一时间，零售领域的企业有了捕获所有历史销售交易的想法，并将它们存储一两年。买家可以利用这些历史销售数据来找出“什么热门，什么不热门”这些信息可以用来影响购买模式。同样，这些数据可以用来决定促销什么商品，哪些商品打折，哪些商品寄回给制造商。当时的普遍看法是，零售领域的历史数据仓库在几个月内通过更好的库存管理、货架和商店布局来收回成本。</p>
<p>​    当时很明显，数据仓库应该部署在与联机事务处理系统不同的硬件上。使用这种方法论，冗长（通常不可预测）的商业智能查询不会破坏联机事务处理的响应时间。此外，数据的性质非常不同；数据仓库处理历史，联机事务处理“现在”。最后，发现历史数据所需的模式通常与当前数据所需的模式不匹配，需要进行数据转换才能从一个模式转换为另一个模式。</p>
<p>​    出于这些原因，构建了工作流系统，从操作联机事务处理系统中“抓取”数据并将其加载到数据仓库中。这种系统被命名为“提取、转换和加载”（ETL）系统。流行的ETL产品包括IBM的数据阶段和Informatica的PowerCenter。在过去十年中，ETL供应商通过数据清理工具、重复数据删除工具和其他以质量为导向的产品扩展了他们的产品。</p>
<p>​    正如我们下面讨论的，在数据仓库环境中必须处理几个问题。</p>
<h3 id="461-bitmap-indexs"><a class="markdownIt-Anchor" href="#461-bitmap-indexs"></a> 4.6.1 Bitmap Indexs</h3>
<p>B+树针对记录的快速插入、删除和更新进行了优化。相比之下，数据仓库执行初始加载，然后数据在几个月或几年内保持静态。此外，数据仓库通常具有具有少量值的列。例如，考虑存储客户的性别。只有两个值，这可以用位图中每条记录的一位来表示。相比之下，B+树将需要（值，记录指针）对每条记录，并且通常每条记录消耗40位。</p>
<p>​    位图对于合取筛选也有优势，例如：</p>
<p>
    </p><center>Customer.sex="F" and Custore. state="California"</center>
<p></p>
<p>​    在这种情况下，可以通过相交位图来确定结果集。有许多更复杂的位图算术技巧可以用来提高常见分析查询的性能。</p>
<p>​    在当前产品中，位图索引补充了Oracle中用于索引存储数据的B+树，而DB2提供了更有限的版本。Sybase IQ广泛使用位图索引，当然，位图的缺点是更新成本很高，因此它们的实用性仅限于仓库环境。</p>
<h3 id="462-fast-load"><a class="markdownIt-Anchor" href="#462-fast-load"></a> 4.6.2 Fast Load</h3>
<p>通常，数据仓库会在半夜加载当天的事务数据。对于只在白天营业的零售场所来说，这是一个明显的策略。夜间大量加载的第二个原因是避免在用户交互期间出现更新。考虑一个业务分析师的情况，他希望制定某种棘手查询，也许是为了调查飓风对客户购买模式的影响。这个查询的结果可能会建议后续查询，例如调查大风暴期间（注：类似于双十一）的购买模式。这两个查询的结果应该是兼容的，即答案应该在同一个数据集上计算。如果同时加载数据，这对于包括最近历史的查询可能会有问题。考虑一个业务分析师的情况，他希望制定某种临时查询，也许是为了调查大风暴对客户购买模式的影响。这个查询的结果可能会建议后续查询，例如调查大风暴期间的购买模式。这两个查询的结果应该是兼容的，即答案应该在同一个数据集上计算。如果同时加载数据，这对于包括最近历史的查询可能会有问题。</p>
<p>​    因此，数据仓库快速批量加载是至关重要的。尽管可以使用一系列SQL插入语句对仓库加载进行编程，但这种策略从未在实践中使用过。相反，使用了一个批量加载器，它将大量记录流式传输到存储中，而没有SQL层的开销，并利用特殊的批量加载方法来访问方法，如B+树。按整数计算，批量装载机比SQL插件快一个数量级，所有主要供应商都提供高性能批量装载机。</p>
<p>​    随着世界转向电子商务和每天24小时的销售，这种批量装载策略变得不那么有意义。但是转向“实时”仓库有几个问题。首先，插入，无论是来自批量加载器还是来自事务，都必须按照第6.3节中的讨论设置写锁。这些与查询获取的读锁发生冲突，并可能导致仓库“冻结”。其次，如上所述跨查询集提供兼容的答案是有问题的。</p>
<p>​    这两个问题都可以通过避免就地更新和提供历史查询来规避。如果保留更新前后的值，并适当地添加时间戳，那么就可以提供最近一段时间的查询。运行同一历史时间的查询集合将提供兼容的答案。此外，无需设置读锁即可运行相同的历史查询。</p>
<p>​    如第5.2.1节所述，一些供应商提供了多版本（MVCC）隔离级别，如SNAPSHOT ISOLATION，尤其是Oracle。随着实时仓库变得越来越流行，其他供应商可能会效仿。</p>
<h3 id="463-materialized-views"><a class="markdownIt-Anchor" href="#463-materialized-views"></a> 4.6.3 Materialized Views</h3>
<p>数据仓库通常是巨大的，连接多个大表的查询倾向于“永远”运行。为了提高流行查询的性能，大多数供应商提供物化视图。与本节前面讨论的纯逻辑视图不同，物化视图采用的是可以查询的实际表，但对应于真正的“基本”数据表上的逻辑视图表达式。对物化视图的查询将避免在运行时执行视图表达式中的连接。代替的是，物化视图必须在执行更新时保持最新。</p>
<p>​    物化视图的使用有三个方面：（a）选择要物化的视图，（b）保持视图的新鲜度（freshness），以及（c）考虑在棘手的查询中使用物化视图。对于（a）是我们在4.3节中提到的自动数据库调优的一个高级方面。对于（c）在各种产品中实现了不同程度；即使对于简单的单块查询，这个问题在理论上也是具有挑战性的，对于具有聚合和子查询的通用SQL来说更是如此。对于（b），大多数供应商提供了多种刷新技术，从每次更新到派生物化视图的表执行物化视图更新，到定期丢弃然后重新创建物化视图。这种策略在运行时开销和物化视图的数据展示一致性之间提供了权衡。</p>
<h3 id="464-olap-and-ad-hoc-query-support"><a class="markdownIt-Anchor" href="#464-olap-and-ad-hoc-query-support"></a> 4.6.4 OLAP and Ad-hoc Query Support</h3>
<p>一些仓库工作负载有可预测的查询。例如，在每个月底，可能会运行一份汇总报告，以按部门提供零售链中每个销售区域的总销售额。与此工作负载穿插的是由业务分析师动态制定的棘手查询。</p>
<p>​    显然，适当构造的物化视图可以支持可预测的查询。更一般地说，由于大多数业务分析查询都要求聚合，因此可以计算一个物化视图，即每个商店按部门的聚合销售额。然后，如果指定了上述区域查询，则可以通过“滚动”每个区域中的单个商店来满足它。</p>
<p>​    这种聚合通常被称为数据立方体(data cubes)，是一类有趣的物化视图。在20世纪90年代初，Essbase等产品提供了定制工具，用于以优先立方体格式存储数据，同时提供基于立方体的用户界面来导航数据，这种能力后来被称为在线分析处理（OLAP）。随着时间的推移，数据立方体支持已经被添加到全功能关系数据库系统中，通常被称为关系OLAP（ROLAP）。许多提供ROLAP的DBMS已经发展到在特殊情况下在内部实现一些早期的OLAP风格的存储方案，因此有时被称为HOLAP（混合OLAP）方案。</p>
<p>​    显然，数据立方体为可预测的、有限类别的查询提供了高性能。但是，它们通常对支持棘手的查询没有帮助。</p>
<h3 id="465-optimization-of-snowflake-schema-queries"><a class="markdownIt-Anchor" href="#465-optimization-of-snowflake-schema-queries"></a> 4.6.5 Optimization of Snowflake Schema Queries</h3>
<p>许多数据仓库遵循特定的模式设计方法。具体来说，它们存储事实的集合，在零售环境中，这些事实通常是简单的记录，例如“客户X在时间T从商店Z购买了产品Y”。</p>
<p>中央事实表记录有关每个事实的信息，例如购买价格、折扣、销售税信息等。事实表中还有一组维度中每个维度的外键。（Also in the fact table are foreign keys for each of a set of dimensions.）维度可以包括客户、产品、商店、时间等。这种形式的模式通常称为星形模式，因为它有一个由维度包围的中心事实表，每个维度与事实表有1-N 的 primary-key-foreign-key关系。在实体关系图中绘制，这样的模式是星形的。</p>
<p>​    许多维度自然是分层的。例如，如果商店可以聚合到区域中，那么商店维度表在区域维度表中添加了一个外键。类似的层次结构对于涉及时间（月/天/年）、管理层次结构等的属性很典型。在这些情况下，会产生多级星形或雪花模式。</p>
<p>​    本质上，所有数据仓库查询都需要对这些表中的某些属性过滤雪花模式中的一个或多个维度，然后将结果连接到中央事实表，按事实表或维度表中的某些属性分组，然后计算SQL聚合。</p>
<p>​    随着时间的推移，供应商在他们的优化器中对此类查询进行了特殊设置，因为它非常流行，并且为如此长时间运行的命令选择一个好的计划至关重要。</p>
<h3 id="466-data-warehousing-conclusions"><a class="markdownIt-Anchor" href="#466-data-warehousing-conclusions"></a> 4.6.6 Data Warehousing: Conclusions</h3>
<p>可以看出，数据仓库需要与联机事务处理环境完全不同的功能。除了B+树之外，还需要位图索引。除了通用优化器，还需要特别关注雪花模式上的聚合查询。需要的不是普通视图，而是物化视图。需要的不是快速事务更新，而是快速批量加载等。</p>
<p>​    主要的关系供应商从面向联机事务处理的体系结构开始，并随着时间的推移增加了面向仓库的功能。此外，还有各种较小的供应商在这一领域提供DBMS解决方案。其中包括Teradata和Netezza，它们提供运行DBMS的无共享专有硬件。此外，向该领域销售的还有Greenplum（PostgreSQL的并行化）、DATAllegro和EnterpriseDB，它们都在更传统的硬件上运行。</p>
<p>​    最后，有些人（包括其中一位作者）声称，与传统存储引擎相比，列存储在数据仓库空间中具有巨大优势，传统存储引擎的存储单位是表行。当表“宽”（高密度）时，单独存储每一列特别有效，访问往往只在几列上。列存储还可以实现简单有效的磁盘压缩，因为列中的所有数据都来自同一类型。列存储的挑战在于，表中行的位置需要在所有存储的列中保持一致，或者需要额外的机制来连接列。这对于联机事务处理来说是一个大问题，但对于附加（主要是仓库或系统日志存储库等数据库）来说不是一个主要问题。</p>
<h2 id="47-database-extensibility"><a class="markdownIt-Anchor" href="#47-database-extensibility"></a> 4.7 Database Extensibility</h2>
<p>传统上，关系数据库被认为存储的数据类型有限，主要关注公司和行政记录保存中使用的“事实和数据”。然而，今天，它们拥有以各种流行编程语言表示的广泛数据类型。这是通过使核心关系DBMS以各种方式可扩展来实现的。在本节中，我们简要调查了广泛使用的扩展类型，强调了在交付这种可扩展性时出现的一些架构问题。这些特性在不同程度上出现在当今大多数商业DBMS中，也出现在开源PostgreSQL DBMS中。</p>
<h3 id="471-abstract-data-types"><a class="markdownIt-Anchor" href="#471-abstract-data-types"></a> 4.7.1 Abstract Data Types</h3>
<p>原则上，关系模型与可以放置在模式列上的标量数据类型的选择无关。但是最初的关系数据库系统只支持一组静态的字母数字列类型，这种限制与关系模型本身有关。关系DBMS可以在运行时扩展到新的抽象数据类型，如早期的IngresADT系统所示，在后续的Postgres系统中更积极。为了实现这一点，DBMS类型系统——也就是解析器——必须从系统目录（system catalog）中驱动，系统目录维护系统已知类型的列表，以及用于操作类型的“方法”（代码）的指针。在这种方法中，DBMS不解释类型，它只是在表达式计算中适当地调用它们的方法；因此得名“抽象数据类型”作为一个典型的例子，可以为二维空间“矩形”注册一个类型，以及矩形交集或联合等操作的方法。这也意味着系统必须为用户定义的代码提供运行时引擎，并安全地执行该代码，而不会有任何导致数据库服务器崩溃或损坏数据的风险。当今所有主要的DBMS都允许用户以现代SQL的命令式“存储过程”子语言定义函数。除了MySQL，大多数都支持至少几种其他语言，通常是C和Java。在Windows平台上，MicrosoftSQLServer和IBMDB2支持编译到Microsoft. Net Common Language Runtime的代码，该代码可以用多种语言编写，最常见的是Visual Basic、C++和C#。PostgreSQL附带对C、Perl、Python和Tcl的支持，并允许在运行时将新语言添加到系统中——有流行的Ruby第三方插件和开源R统计包。</p>
<p>​    为了使抽象数据类型在DBMS中高效运行，查询优化器必须在选择和连接谓词中考虑“昂贵的”用户定义代码，并且在某些情况下将选择推迟到连接之后。为了使ADT更加高效，能够在其上定义索引是很有用的。至少，B+树需要扩展到ADT上的索引表达式，而不仅仅是列（有时称为“功能索引”），优化器必须扩展以在适用时选择它们。对于线性阶以外的谓词 (&lt;,&gt;,=), B+-树是不够的，系统需要支持可扩展的索引方案；文献中的两种方法是原始的Postgres可扩展访问方法接口和GiST。</p>
<h3 id="472-structured-types-and-xml"><a class="markdownIt-Anchor" href="#472-structured-types-and-xml"></a> 4.7.2 Structured Types and XML</h3>
<p>ADT被设计为与关系模型完全兼容——它们不会以任何方式改变基本的关系代数，它们只改变属性值的表达式。然而，多年来，有许多建议对数据库进行更积极的更改，以支持非关系结构化类型：即嵌套集合类型，如数组、集合、树和嵌套元组和/或关系。处理结构化类型（如XML）的方法大致有三种。第一种方法是构建一个自定义数据库系统，对具有结构化类型的数据进行操作；从历史上看，这些尝试被在传统关系DBMS中适应结构化类型的方法所掩盖，在XML的情况下也遵循了这一趋势。第二种方法是将复杂类型视为ADT。例如，可以定义一个关系表，其中包含一个XML类型的列，每行存储一个XML文档。这意味着搜索XML的表达式——例如XPath树匹配模式——以查询优化器不透明的方式执行。第三种方法是DBMS在插入时将嵌套结构“规范化”为一组关系，外键将子对象连接到它们的父对象。这种技术，有时称为“粉碎”XML，将所有数据结构公开给关系框架内的DBMS，但增加了存储开销，并且需要连接以在查询时“重新连接”数据。当今大多数DBMS供应商都提供ADT和粉碎存储选项，并允许数据库设计人员在它们之间进行选择。在XML的情况下，在shredded方法中，提供删除嵌套在同一级别的XML元素之间的排序信息的选项也很常见，这可以通过允许连接重新排序和其他关系优化来提高查询性能。</p>
<p>​    一个相关的问题是对关系模型进行更适度的扩展以处理嵌套表和元组以及数组。例如，这些在Oracle安装中被广泛使用。设计权衡在许多方面与处理XML的权衡相似。</p>
<p>（注：XML有时被称为“半结构化”数据，因为它对文档的结构没有限制。然而，与自由文本不同，它鼓励结构化，包括排序和嵌套集合等非关系复杂性。在数据库中存储和查询XML的复杂性往往来自处理XML文档的结构，而不是处理文档中的非结构化文本的问题。事实上，许多用于XML查询处理的技术都源于对结构丰富的ODMG对象数据库模型及其OQL查询语言的研究。）</p>
<h3 id="473-full-text-search"><a class="markdownIt-Anchor" href="#473-full-text-search"></a> 4.7.3 Full-Text Search</h3>
<p>传统上，关系数据库在处理丰富的文本数据和通常随之而来的关键字搜索方面是出了名的差。原则上，在数据库中对自由文本进行建模是存储文档、定义与形式元组（word、docentID、位置）的“倒排文件”关系以及在word列上构建B+树索引的简单事情。这大致是任何文本搜索引擎中发生的事情，模块化了一些单词的语言规范化，以及一些额外的每个元组属性以帮助排序搜索结果。但是除了模型之外，大多数文本索引引擎还实现了许多特定于此模式的性能优化，这些优化在典型的DBMS中没有实现。其中包括“非规范化”模式以使每个单词仅出现一次，并带有每个单词出现的列表，即（word， list&lt;docentID，point&gt;）。这允许对列表进行积极的增量压缩（通常称为“发布列表”），这对于文档中单词的典型倾斜（Zipfian）分布至关重要。此外，文本数据库倾向于以数据仓库的方式使用，绕过任何用于事务的DBMS逻辑。人们普遍认为，像上面这样在DBMS中实现文本搜索的简单方法比自定义文本索引引擎运行得慢大约一个数量级。</p>
<p>​    然而，今天的大多数DBMS要么包含文本索引子系统，要么可以与单独的引擎捆绑在一起来完成这项工作。文本索引工具通常既可以用于全文文档，也可以用于元组中的短文本属性。在大多数情况下，全文索引是异步更新的（“爬取”），而不是事务性地维护；PostgreSQL在提供带有事务更新的全文索引选项方面很不寻常。在一些系统中，全文索引存储在DBMS之外，因此需要单独的工具进行备份和恢复。在关系数据库中处理全文搜索的一个关键挑战是以一种有用和灵活的方式将关系查询（无序和完整的结果集）的语义学与使用关键字（有序和通常不完整的结果）的排序文档搜索联系起来。例如，当每个关系上都有关键字搜索谓词时，尚不清楚如何对两个关系的连接查询的输出进行排序。这个问题在当前实践中仍然相当棘手。给定查询输出的语义，另一个挑战是关系查询优化器推理文本索引的选择性和成本估计，以及判断其答案集在用户交互界面中排序和分页并且可能无法完全检索的查询的适当成本模型。所有报告都显示，许多流行的DBMS都在积极探讨最后一个主题。</p>
<h3 id="474-additional-extensibility-issues"><a class="markdownIt-Anchor" href="#474-additional-extensibility-issues"></a> 4.7.4 Additional Extensibility Issues</h3>
<p>除了数据库可扩展性的三个驱动使用场景之外，我们还在引擎中提出了两个核心组件，它们通常可以扩展以用于各种用途。</p>
<p>​    有许多关于可扩展查询优化器的建议，包括支持IBMDB2优化器的设计，以及支持Tandem和Microsoft优化器的设计。所有这些方案都提供了生成或修改查询计划的规则驱动子系统，并允许独立注册新的优化规则。当向查询执行器添加新功能时，或者当为特定查询重写或计划优化开发新想法时，这些技术有助于更容易扩展优化器。这些通用架构对于启用上述许多特定的可扩展类型功能很重要。</p>
<p>​    自早期系统以来出现的另一种跨领域可扩展性形式是数据库能够将远程数据源“包装”在模式中，就好像它们是本机表一样，并在查询处理期间访问它们。这方面的一个挑战是优化器处理不支持扫描的数据源，但会响应为变量赋值的请求；这需要将与索引SARG匹配的优化器逻辑推广到查询谓词。另一个挑战是执行器有效地处理远程数据源，这些数据源在生成输出时可能很慢或突发；这概括了让查询执行器执行异步磁盘I/O的设计挑战，将访问时间可变性增加了一个数量级或更多。</p>
<h2 id="48-standard-practice"><a class="markdownIt-Anchor" href="#48-standard-practice"></a> 4.8 Standard Practice</h2>
<p>基本上所有关系数据库查询引擎的粗略架构看起来都类似于System R原型。多年来，查询处理研究和开发一直专注于该框架内的创新，以加速越来越多类别的查询和模式。系统之间的主要设计差异出现在优化器搜索策略（自上而下与自下而上）和查询执行器控制流模型中，尤其是对于无共享和共享磁盘并行性（迭代器和交换运算符与异步生产者/消费者方案）。在更细粒度的层面上，优化器、执行器和访问方法中使用的方案组合存在很大差异，以实现不同工作负载的良好性能，包括联机事务处理、仓储决策支持和OLAP。商业产品中的这种“秘密调味汁”决定了它们在特定情况下的性能，但就第一个近似值而言，所有商业系统在广泛的工作负载中都做得很好，并且在特定工作负载中看起来很慢。</p>
<p>​    在开源领域，PostgreSQL具有相当复杂的查询处理器，具有传统的基于成本的优化器、广泛的执行算法集以及商业产品中没有的许多可扩展性功能。MySQL的查询处理器要简单得多，它是围绕索引上的嵌套循环连接构建的。MySQL查询优化器专注于分析查询，以确保常见操作是轻量级和高效的——特别是键/外键连接、外部连接到连接的重写以及只要求结果集前几行的查询。通读MySQL手册和查询处理代码并将其与更复杂的传统设计进行比较是很有启发性的，记住MySQL在实践中的高采用率，以及它似乎擅长的任务。</p>
<h2 id="49-discussion-and-additional-material"><a class="markdownIt-Anchor" href="#49-discussion-and-additional-material"></a> 4.9 Discussion  and Additional Material</h2>
<p>由于查询优化和执行的干净模块化，多年来在这种环境中开发了大量的算法、技术和技巧，关系查询处理研究至今仍在继续。令人高兴的是，大多数已经在实践中使用的想法（以及许多没有使用过的想法）都可以在研究文献中找到。查询优化研究的一个很好的起点是Chaudhuri的简短调查。对于查询处理研究，Graefe提供了一个非常全面的调查。</p>
<p>​    除了传统的查询处理之外，近年来还有大量工作将丰富的统计方法整合到大型数据集的处理中。一个自然的扩展是使用抽样或汇总统计来提供聚合查询的数字近似值，可能以不断改进的在线方式。然而，尽管研究结果相当成熟，但这在市场上的应用相对缓慢。Oracle和DB2都提供了简单的基表采样技术，但没有提供涉及多个表的查询的统计稳健估计。大多数供应商没有关注这些特性，而是选择丰富他们的OLAP特性，这限制了可以快速回答的查询，但为用户提供了100%正确的答案。</p>
<p>​    另一个重要但更基本的扩展是在DBMS中包括“数据挖掘”技术。流行的技术包括统计聚类、分类、回归和关联规则。除了研究文献中研究的这些技术的独立实现之外，在将这些技术与丰富的关系查询集成时还存在架构挑战。</p>
<p>​    最后，值得注意的是，更广泛的计算社区最近对数据并行感到兴奋，如谷歌的Map-Reduce、微软的Dryad和雅虎支持的开源Hadoop代码等框架所体现的那样！这些系统非常像shared-nothing-parallel关系查询执行器，由应用程序逻辑的程序员实现自定义查询运算符。它们还包括管理参与节点故障的简单但合理设计的方法，这种故障在大规模范围内很常见。也许这一趋势最有趣的方面是它被创造性地用于计算中的各种数据密集型问题，包括文本和图像处理以及统计方法。看看这些框架的用户是否借鉴了数据库引擎的其他想法将会很有趣——例如，雅虎早期的工作是用声明式查询和优化器扩展Hadoop。建立在这些框架上的创新也可以被并入数据库引擎。</p>
<h1 id="5-storage-management"><a class="markdownIt-Anchor" href="#5-storage-management"></a> 5 Storage Management</h1>
<p>目前商业上使用的DBMS存储管理器有两种基本类型：（1）DBMS直接与磁盘的低级块模式设备驱动程序交互（通常称为原始模式访问），或（2）DBMS使用标准操作系统文件系统设施。这一决定会影响DBMS在空间和时间上控制存储的能力。我们依次考虑这两个维度，并继续更详细地讨论存储层次结构的使用。</p>
<h2 id="51-spatial-control"><a class="markdownIt-Anchor" href="#51-spatial-control"></a> 5.1 Spatial Control</h2>
<p>进出磁盘的顺序带宽比随机访问快10到100倍，而且这一比例正在增加。磁盘密度每18个月翻一番，带宽大约随着密度的平方根而上升（并与旋转速度成线性关系）。然而，磁盘臂移动的改善速度要慢得多——大约7%/年。因此，对于DBMS存储管理器来说，在磁盘上放置块以便需要大量数据的查询可以顺序访问它是至关重要的。由于DBMS可以比底层操作系统更深入地了解其工作负载访问模式，因此DBMS架构师对磁盘上数据库块的空间定位进行完全控制是有意义的。</p>
<p>​    DBMS控制其数据空间局部性的最佳方法是将数据直接存储到“原始”磁盘设备并完全避开文件系统。这之所以有效，是因为原始设备地址通常与存储位置的物理接近度密切对应。大多数商业数据库系统都提供此功能以获得最佳性能。这种技术虽然有效，但确实有一些缺点。首先，它要求DBA将整个磁盘分区专用于DBMS，这使得它们对需要文件系统接口的实用程序（备份等）不可用。其次，“原始磁盘”访问接口通常是特定于操作系统的，这会使DBMS更难移植。然而，这是大多数商业DBMS供应商多年前克服的障碍。最后，RAID、存储区域网络（SAN）和逻辑卷管理器等存储行业的发展变得流行起来。我们现在正处于“虚拟”磁盘设备在当今大多数场景中成为常态的地步——“原始”设备接口实际上正在被设备或软件拦截，这些设备或软件在一个或多个物理磁盘上积极地重新定位数据。因此，DBMS显式物理控制的好处随着时间的推移而被稀释。我们将在第7.3节中进一步讨论这个问题。</p>
<p>​    原始磁盘访问的另一种选择是DBMS在操作系统文件系统中创建一个非常大的文件，并将数据定位为该文件中的偏移量。该文件本质上被视为磁盘驻留页面的线性数组。这避免了原始设备访问的一些缺点，并且仍然提供了相当好的性能。在大多数流行的文件系统中，如果在空磁盘上分配一个非常大的文件，则该文件中的偏移量将与存储区域的物理距离相当接近。大多数虚拟化存储系统还设计为在附近物理位置的文件中放置接近偏移量。因此，随着时间的推移，使用大文件而不是原始磁盘时失去的相对控制变得不那么重要。使用文件系统接口对时间控制有其他影响，我们将在下一小节中讨论。</p>
<p>​    作为一个数据点，我们最近比较了使用主要商业DBMS之一的中型系统上的直接原始访问和大文件访问，发现在运行TPC-C基准测试时只有6%的降级，并且对较少的I/O密集型工作负载几乎没有负面影响。DB2报告说，当使用直接I/O（DIO）及其变体（如并发I/O（CIO））时，文件系统开销低至1%。因此，DBMS供应商通常不再推荐原始存储，很少有客户在这种配置下运行。它仍然是主要商业系统中主要用于基准测试使用的受支持功能。</p>
<p>​    一些商业DBMS还允许将数据库页面大小自定义设置为适合预期工作负载的大小。IBM DB2和Oracle都支持此选项。其他商业系统如Microsoft SQL Server由于由此带来的管理复杂性增加而不支持多个页面大小。如果支持可调页面大小，则所选择的大小应该是文件系统（如果使用原始I/O，则为原始设备）使用的页面大小的倍数。“5分钟规则”论文中讨论了页面大小的适当选择，该论文随后更新为“30分钟规则”。如果正在使用文件系统而不是原始设备访问，则可能需要特殊接口来写入与文件系统不同大小的页面；例如，POSIX mmap/msync调用提供了这种支持。</p>
<h2 id="52-temporal-controlbuffering"><a class="markdownIt-Anchor" href="#52-temporal-controlbuffering"></a> 5.2 Temporal Control：Buffering</h2>
<p>除了控制数据在磁盘上的位置之外，数据库管理系统还必须控制数据何时物理写入磁盘。正如我们将在第5节中讨论的，数据库管理系统包含关于何时向磁盘写入块的关键逻辑。大多数操作系统文件系统还提供内置的输入/输出缓冲机制来决定何时对文件块进行读写。如果数据库管理系统使用标准文件系统接口进行写入，操作系统缓冲会通过静默推迟或重新排序写入来混淆数据库管理系统逻辑的意图。这可能会给数据库管理系统带来重大问题。</p>
<p>​    第一组问题涉及数据库的ACID事务承诺的正确性：如果不明确控制磁盘写入的时间和顺序，DBMS无法保证软件或硬件故障后的原子恢复。正如我们将在第5.3节中讨论的，预写日志协议要求对日志设备的写入必须先于对数据库设备的相应写入，并且在提交日志记录可靠地写入日志设备之前，提交请求不能返回给用户。</p>
<p>​    操作系统缓冲的第二组问题与性能有关，但对正确性没有影响。现代操作系统通常有一些对预读（推测读取）和后写（延迟、批量写入）的内置支持。这些通常不太适合DBMS访问模式。文件系统逻辑依赖于文件中物理字节偏移的连续性来做出预读决策。DBMS级别的I/O设施可以支持基于未来读取请求的逻辑预测I/O决策，这些请求在SQL查询处理级别已知，但在文件系统级别不易识别。例如，当扫描不一定连续的B+树的叶子（行存储在B+树的叶子中）时，可以请求逻辑DBMS级预读。通过让DBMS提前发出I/O请求，在DBMS逻辑中很容易实现逻辑预读。查询执行计划包含有关数据访问算法的相关信息，并包含有关查询未来访问模式的完整信息。类似地，DBMS可能希望根据将锁争用与I/O吞吐量等问题混合在一起的考虑，自行决定何时刷新日志尾部。这些详细的未来访问模式知识可用于DBMS，但不适用于操作系统文件系统。</p>
<p>​    最后的性能问题是“双缓冲”和内存副本的高CPU开销。鉴于DBMS必须仔细地进行自己的缓冲以确保正确性，操作系统的任何额外缓冲都是多余的。这种冗余导致了两个开销。首先，它通过有效地减少用于做有用工作的可用存储器来浪费系统内存。其次，它通过导致额外的复制步骤来浪费时间和处理资源：在读取时，数据首先从磁盘复制到操作系统缓冲区，然后再次复制到DBMS缓冲池。在写入时，这两个复制都是不需要的。</p>
<p>​    在内存中复制数据可能是一个严重的瓶颈。副本会导致延迟，消耗CPU周期，并且会淹没CPU数据缓存。对于那些没有操作或实现过数据库系统的人来说，这一事实通常是惊讶的，他们认为与磁盘I/O相比，主存操作是“免费的”。但是在实践中，经过良好调整的事务处理DBMS的吞吐量通常不受I/O限制。在高端安装中，这是通过购买足够的磁盘和RAM来实现的，以便缓冲池吸收重复的页面请求，并且磁盘I/O在磁盘臂之间以可以满足系统中所有处理器数据需求的速率共享。一旦这种“系统平衡”实现，I/O延迟不再是主要的系统吞吐量瓶颈，剩余的主存瓶颈成为系统中的限制因素。内存副本正在成为计算机架构中的主要瓶颈：这是由于每美元每秒原始CPU周期（遵循摩尔定律）和RAM访问速度（明显落后于摩尔定律）之间的性能演进差距。</p>
<p>​    操作系统缓冲的问题在数据库研究文献和业界已经有一段时间了。大多数现代操作系统现在都提供钩子（hooks）（例如，POSIX mmap套件调用或平台特定的DIO和CIO API集），以便数据库服务器等程序可以绕过文件缓存的双重缓冲。这确保了在请求时写入磁盘，避免双重缓冲，并且DBMS可以控制页面替换策略。</p>
<h2 id="53-buffer-management"><a class="markdownIt-Anchor" href="#53-buffer-management"></a> 5.3 Buffer Management</h2>
<p>为了提供对数据库页面的有效访问，每个DBMS都在自己的内存空间中实现了一个大型共享缓冲池。在早期，缓冲池是静态分配给管理选择的值，但现在大多数商业DBMS根据系统需求和可用资源动态调整缓冲池大小。缓冲池被组织成一个帧数组，其中每个帧是一个数据库磁盘块大小的内存区域。块从磁盘复制到缓冲池而不改变格式，在内存中以这种本机格式进行操作，然后写回。这种无需翻译的方法避免了“编组”和“解组”数据到磁盘/从磁盘的CPU瓶颈；也许更重要的是，固定大小的帧避开了通用技术导致的外部碎片和压缩的内存管理复杂性。</p>
<p>​    与缓冲池帧阵列相关联的是一个哈希表，它将（1）当前保存在内存中的页码映射到它们在帧表中的位置，（2）该页在后备磁盘存储上的位置，以及（3）关于该页的一些元数据。元数据包括一个脏位，以指示页面自从磁盘读取后是否发生了变化，以及页面替换策略在缓冲池已满时选择要驱逐的页面所需的任何信息。大多数系统还包括一个引脚计数，以表明页面没有资格参与页面替换算法。当pin计数不为零时，页面被“固定”在内存中，不会被强制磁盘或被盗(stolen)。这允许DBMS的工作线程通过在操作页面之前增加pin计数，然后再递减来固定缓冲池中的页面。其目的是在任何固定时间点固定缓冲池的一小部分。一些系统还提供将表固定在内存中的能力作为管理选项，这可以缩短对小型、大量使用的表的访问时间。但是，固定页面会减少可用于正常缓冲池活动的页面数量，并且随着固定页面百分比的增加会对性能产生负面影响。</p>
<p>​    关系系统早期的许多研究集中在页面替换策略的设计上，因为DBMS中发现的数据访问模式的多样性使简单的技术无效。例如，某些数据库操作往往需要全表扫描，当扫描的表比缓冲池大得多时，这些操作往往会清除池中所有常用引用的数据。对于这样的访问模式，引用的新近程度是未来引用概率的预测指标是糟糕的，因此众所周知，像LRU和CLOCK这样的操作系统页面替换方案对于许多数据库访问模式来说表现不佳。提出了多种替代方案，包括一些试图通过查询执行计划信息来调整替换策略的方案。今天，大多数系统使用对LRU方案的简单增强来解释全表扫描的情况。一个出现在研究文献中并已在商业系统中实现的是LRU-2。商业系统中使用的另一种方案是让替换策略取决于页面类型：例如，B+树的根可能会被替换为与堆文件中的页面不同的策略。这让人想起Reiter的域分离方案。</p>
<p>​    最近的硬件趋势，包括64位寻址和内存价格下降，使得非常大的缓冲池在经济上成为可能。这为利用大型主存储器提高效率开辟了新的机会。作为对位，庞大且非常活跃的缓冲池也给重启恢复速度和高效检查点等问题带来了更多挑战。这些主题将在第6节中进一步讨论。</p>
<h2 id="54-standard-practice"><a class="markdownIt-Anchor" href="#54-standard-practice"></a> 5.4 Standard Practice</h2>
<p>在过去十年中，商业文件系统已经发展到可以很好地支持数据库存储系统的程度。在标准使用模型中，系统管理员在DBMS中的每个磁盘或逻辑卷上创建一个文件系统。然后，DBMS在每个文件系统中分配一个大文件，并通过mmap套件等低级接口控制该文件中数据的放置。DBMS基本上将每个磁盘或逻辑卷视为（几乎）连续数据库页面的线性阵列。在这种配置中，现代文件系统为DBMS提供了合理的空间和时间控制，这种存储模型基本上适用于所有数据库系统实现。原始磁盘支持在大多数数据库系统中仍然是一个常见的高性能选项，然而，它的使用范围正在迅速缩小到仅用于性能基准。</p>
<h2 id="55-discussion-and-additional-material"><a class="markdownIt-Anchor" href="#55-discussion-and-additional-material"></a> 5.5 Discussion and Additional Material</h2>
<p>数据库存储子系统是一项非常成熟的技术，但近年来出现了许多关于数据库存储的新考虑，这些考虑有可能在很多方面改变数据管理技术。</p>
<p>​    一个关键的技术变化是闪存作为一种经济上可行的随机存取持久存储技术的出现。从数据库系统研究的早期开始，就一直在讨论由于新的存储技术取代磁盘而导致的DBMS设计的巨大变化。闪存似乎既在技术上可行，又在经济上得到广泛市场的支持，并且相对于磁盘和RAM而言，它提供了一种有趣的中间成本/性能权衡。闪存是三十多年来在这方面取得成功的第一种新的持久性存储介质，因此它的特性可能会对未来的DBMS设计产生重大影响。</p>
<p>​    最近出现的另一个传统主题是数据库数据的压缩。关于该主题的早期工作集中在磁盘压缩上，以最大限度地减少读取期间的磁盘延迟，并最大限度地提高数据库缓冲池的容量。随着处理器性能的提高和RAM延迟跟不上步伐，考虑即使在计算期间也保持数据压缩变得越来越重要，以便最大限度地提高数据在处理器缓存中的驻留性。但这需要适合数据处理的压缩表示，以及操作压缩数据的查询处理内部。关系数据库压缩的另一个问题是数据库是可重新排序的元组集，而大多数压缩工作都集中在字节流上，而不考虑重新排序。最近关于这个主题的研究表明，在不久的将来数据库压缩有很大的希望。</p>
<p>​    最后，在传统的关系数据库市场之外，人们对大规模但稀疏的数据存储技术的兴趣增强了。逻辑上有数千列，其中大部分对于任何给定的行都是空的。这些场景通常通过某种属性-值对或三元组来表示。实例包括Google的BigTable[9]、Microsoft的Active Directory和Exchange产品使用的标记列，以及为“Semantic Web.”提出的资源描述框架（RDF）。这些方法的共同点是使用根据数据表的列而不是行来组织磁盘的存储系统。列化存储的想法在最近的一些数据库研究工作中得到了复兴和详细探索。</p>
<h1 id="6-transactionsconcurrency-control-and-recovery"><a class="markdownIt-Anchor" href="#6-transactionsconcurrency-control-and-recovery"></a> 6 Transactions：Concurrency Control and Recovery</h1>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="https://Dog-Du.github.io">DogDu</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="https://dog-du.github.io/posts/8453.html">https://dog-du.github.io/posts/8453.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a><a class="post-meta__tags" href="/tags/%E8%AE%BA%E6%96%87/">论文</a><a class="post-meta__tags" href="/tags/%E6%9C%AA%E5%AE%8C%E6%88%90/">未完成</a></div><div class="post-share"><div class="social-share" data-image="/img/top_img.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related full-width" href="/posts/31315.html" title="复习操作系统"><img class="cover" src="/img/top_img.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">Previous</div><div class="info-item-2">复习操作系统</div></div><div class="info-2"><div class="info-item-1">看中山大学OS，学操作系统</div></div></div></a></nav><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> Comments</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/head.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">DogDu</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">16</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">12</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">2</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Dog-Du"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is DogDu's Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#architecture-of-a-database-system"><span class="toc-text"> Architecture of a Database System</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#abstract"><span class="toc-text"> Abstract</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1-introduction"><span class="toc-text"> 1 Introduction</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#11-relational-systems-the-life-of-a-query"><span class="toc-text"> 1.1 Relational Systems: The Life of a Query</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-scope-and-overview"><span class="toc-text"> 1.2 Scope and  Overview</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-process-models"><span class="toc-text"> 2 Process Models</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#21-uniprocessors-and-lightweight-threads"><span class="toc-text"> 2.1 Uniprocessors and Lightweight Threads</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#211-process-per-dbms-worker"><span class="toc-text"> 2.1.1 Process per DBMS Worker</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#212-thread-per-dbms-worker"><span class="toc-text"> 2.1.2 Thread per DBMS worker</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#213-process-pool"><span class="toc-text"> 2.1.3 Process Pool</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#214-shared-data-and-process-boundaries"><span class="toc-text"> 2.1.4 Shared Data and Process Boundaries</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22-dbms-threads"><span class="toc-text"> 2.2 DBMS Threads</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#221-dbms-threads"><span class="toc-text"> 2.2.1 DBMS Threads</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23-standard-practice"><span class="toc-text"> 2.3 Standard Practice</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#24-admission-control"><span class="toc-text"> 2.4 Admission Control</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#25-discussion-and-additional-material"><span class="toc-text"> 2.5 Discussion and Additional Material</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-parallel-architectureprocess-and-memory-coordination"><span class="toc-text"> 3 Parallel Architecture：Process and Memory Coordination</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#31-shared-memory"><span class="toc-text"> 3.1 Shared Memory</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#32-shared-nothing"><span class="toc-text"> 3.2 Shared-Nothing</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#33-shared-disk"><span class="toc-text"> 3.3 Shared-Disk</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#34-numa"><span class="toc-text"> 3.4 NUMA</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#35-dbms-threads-and-multi-processors"><span class="toc-text"> 3.5 DBMS Threads and Multi-processors</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#36-standard-practice"><span class="toc-text"> 3.6 Standard Practice</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#37-discussion-and-additional-material"><span class="toc-text"> 3.7 Discussion and Additional Material</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-relational-query-processor"><span class="toc-text"> 4 Relational Query Processor</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#41-query-parsing-and-authorization"><span class="toc-text"> 4.1 Query Parsing and Authorization</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#42-query-rewrite"><span class="toc-text"> 4.2 Query Rewrite</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#43-query-optimizer"><span class="toc-text"> 4.3 Query Optimizer</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#431-a-note-on-query-compilation-and-recompilation"><span class="toc-text"> 4.3.1 A Note on Query Compilation and Recompilation</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#44-query-executor"><span class="toc-text"> 4.4 Query  Executor</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#441-iterator-discussion"><span class="toc-text"> 4.4.1 Iterator Discussion</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#442-wheres-the-data"><span class="toc-text"> 4.4.2 Where’s the Data?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#443-data-modification-statements"><span class="toc-text"> 4.4.3 Data Modification Statements</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#45-access-methods"><span class="toc-text"> 4.5 Access Methods</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#46-data-warehouses"><span class="toc-text"> 4.6 Data Warehouses</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#461-bitmap-indexs"><span class="toc-text"> 4.6.1 Bitmap Indexs</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#462-fast-load"><span class="toc-text"> 4.6.2 Fast Load</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#463-materialized-views"><span class="toc-text"> 4.6.3 Materialized Views</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#464-olap-and-ad-hoc-query-support"><span class="toc-text"> 4.6.4 OLAP and Ad-hoc Query Support</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#465-optimization-of-snowflake-schema-queries"><span class="toc-text"> 4.6.5 Optimization of Snowflake Schema Queries</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#466-data-warehousing-conclusions"><span class="toc-text"> 4.6.6 Data Warehousing: Conclusions</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#47-database-extensibility"><span class="toc-text"> 4.7 Database Extensibility</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#471-abstract-data-types"><span class="toc-text"> 4.7.1 Abstract Data Types</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#472-structured-types-and-xml"><span class="toc-text"> 4.7.2 Structured Types and XML</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#473-full-text-search"><span class="toc-text"> 4.7.3 Full-Text Search</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#474-additional-extensibility-issues"><span class="toc-text"> 4.7.4 Additional Extensibility Issues</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#48-standard-practice"><span class="toc-text"> 4.8 Standard Practice</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#49-discussion-and-additional-material"><span class="toc-text"> 4.9 Discussion  and Additional Material</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-storage-management"><span class="toc-text"> 5 Storage Management</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#51-spatial-control"><span class="toc-text"> 5.1 Spatial Control</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#52-temporal-controlbuffering"><span class="toc-text"> 5.2 Temporal Control：Buffering</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#53-buffer-management"><span class="toc-text"> 5.3 Buffer Management</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#54-standard-practice"><span class="toc-text"> 5.4 Standard Practice</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#55-discussion-and-additional-material"><span class="toc-text"> 5.5 Discussion and Additional Material</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-transactionsconcurrency-control-and-recovery"><span class="toc-text"> 6 Transactions：Concurrency Control and Recovery</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Posts</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/8453.html" title="读论文-Architecture of a Database System">读论文-Architecture of a Database System</a><time datetime="2025-03-27T08:37:49.000Z" title="Created 2025-03-27 16:37:49">2025-03-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/31315.html" title="复习操作系统">复习操作系统</a><time datetime="2025-03-14T02:43:15.000Z" title="Created 2025-03-14 10:43:15">2025-03-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/984.html" title="计网复习">计网复习</a><time datetime="2025-03-10T00:54:15.000Z" title="Created 2025-03-10 08:54:15">2025-03-10</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By DogDu</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.3</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="Scroll to Comments"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null

  const commentCount = n => {
    const isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
    if (isCommentCount) {
      isCommentCount.textContent= n
    }
  }

  const initGitalk = (el, path) => {
    if (isShuoshuo) {
      window.shuoshuoComment.destroyGitalk = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }

    const gitalk = new Gitalk({
      clientID: 'Ov23lip70wbjDSj3yXVa',
      clientSecret: '229af146a5a288cca20082b54bcaf2ea896347af',
      repo: 'Dog-Du.github.io',
      owner: 'Dog-Du',
      admin: ['Dog-Du'],
      updateCountCallback: commentCount,
      ...option,
      id: (decodeURIComponent(location.pathname)).substring(0, 48),
      distractionFreeMode: false
    })

    gitalk.render('gitalk-container')
  }

  const loadGitalk = async(el, path) => {
    if (typeof Gitalk === 'function') initGitalk(el, path)
    else {
      await btf.getCSS('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css')
      await btf.getScript('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js')
      initGitalk(el, path)
    }
  }

  if (isShuoshuo) {
    'Gitalk' === 'Gitalk'
      ? window.shuoshuoComment = { loadComment: loadGitalk }
      : window.loadOtherComment = loadGitalk
    return
  }

  if ('Gitalk' === 'Gitalk' || !false) {
    if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
    else loadGitalk()
  } else {
    window.loadOtherComment = loadGitalk
  }
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>