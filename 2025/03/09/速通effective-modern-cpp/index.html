<!DOCTYPE html><html lang="cn-ZH" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>听课，速通effective-modern-cpp | DogDu's blog</title><meta name="author" content="DogDu"><meta name="copyright" content="DogDu"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="听课，用effective-modern-cpp速通cpp八股">
<meta property="og:type" content="article">
<meta property="og:title" content="听课，速通effective-modern-cpp">
<meta property="og:url" content="https://dog-du.github.io/2025/03/09/%E9%80%9F%E9%80%9Aeffective-modern-cpp/index.html">
<meta property="og:site_name" content="DogDu&#39;s blog">
<meta property="og:description" content="听课，用effective-modern-cpp速通cpp八股">
<meta property="og:locale" content="cn_ZH">
<meta property="og:image" content="https://dog-du.github.io/img/top_img.jpg">
<meta property="article:published_time" content="2025-03-09T13:54:15.000Z">
<meta property="article:modified_time" content="2025-03-12T13:54:00.069Z">
<meta property="article:author" content="DogDu">
<meta property="article:tag" content="八股">
<meta property="article:tag" content="未完成">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://dog-du.github.io/img/top_img.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "听课，速通effective-modern-cpp",
  "url": "https://dog-du.github.io/2025/03/09/%E9%80%9F%E9%80%9Aeffective-modern-cpp/",
  "image": "https://dog-du.github.io/img/top_img.jpg",
  "datePublished": "2025-03-09T13:54:15.000Z",
  "dateModified": "2025-03-12T13:54:00.069Z",
  "author": [
    {
      "@type": "Person",
      "name": "DogDu",
      "url": "https://dog-du.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/head.jpg"><link rel="canonical" href="https://dog-du.github.io/2025/03/09/%E9%80%9F%E9%80%9Aeffective-modern-cpp/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":300,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '听课，速通effective-modern-cpp',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="alternate" href="/atom.xml" title="DogDu's blog" type="application/atom+xml">
</head><body><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/top_img.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="/img/head.jpg" alt="Logo"><span class="site-name">DogDu's blog</span></a><a class="nav-page-title" href="/"><span class="site-name">听课，速通effective-modern-cpp</span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">听课，速通effective-modern-cpp</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2025-03-09T13:54:15.000Z" title="Created 2025-03-09 21:54:15">2025-03-09</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2025-03-12T13:54:00.069Z" title="Updated 2025-03-12 21:54:00">2025-03-12</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%AD%A6%E4%B9%A0%E7%B1%BB/">学习类</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p><strong>课程   bilibili: <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Gg4y1p71w">effective-modern-cpp</a></strong></p>
<h1 id="第一章类型推导"><a class="markdownIt-Anchor" href="#第一章类型推导"></a> 第一章：类型推导</h1>
<h3 id="顶层const和底层const"><a class="markdownIt-Anchor" href="#顶层const和底层const"></a> 顶层const和底层const</h3>
<p><img src="/img/%E9%80%9F%E9%80%9Aeffective-modern-cpp/image-20250309151313265.png" alt="image-20250309151313265"></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="comment">/* 没有指针，这里是顶层 */</span> <span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="type">const</span> <span class="comment">/* 引用由指针实现，这里是底层 */</span> <span class="type">int</span> &amp;a = <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="comment">/* 底层const */</span> <span class="type">int</span> *<span class="type">const</span> <span class="comment">/* 顶层const */</span> p;</span><br><span class="line"><span class="comment">// 当执行copy时，常量的顶层const不受什么影响，而底层const必须有一致的const资格。</span></span><br><span class="line"><span class="comment">// 我因为底层的const是所指向的对象的属性，顶层const是本身的属性，</span></span><br><span class="line"><span class="comment">// 本身当然不能修改所指向的对象的属性</span></span><br><span class="line"><span class="comment">// 从安全角度考虑更容易理解</span></span><br></pre></td></tr></tbody></table></figure>
<p><img src="/img/%E9%80%9F%E9%80%9Aeffective-modern-cpp/image-20250309152134974.png" alt="image-20250309152134974"></p>
<p>有点嗯背了。</p>
<p><strong>只有指针有所谓的const顶层，const底层。其他类型包括引用只有底层。</strong></p>
<h3 id="值类型与右值引用"><a class="markdownIt-Anchor" href="#值类型与右值引用"></a> 值类型与右值引用</h3>
<p><img src="/img/%E9%80%9F%E9%80%9Aeffective-modern-cpp/image-20250309152738190.png" alt="image-20250309152738190"></p>
<ol>
<li>
<p>联想到汇编很容易理解</p>
</li>
<li>
<p>想到重载的 T&amp; operator++() 和 const T operator++(int)</p>
<p><img src="/img/%E9%80%9F%E9%80%9Aeffective-modern-cpp/image-20250309153344915.png" alt="image-20250309153344915"></p>
<p><img src="/img/%E9%80%9F%E9%80%9Aeffective-modern-cpp/image-20250309154132253.png" alt="image-20250309154132253"></p>
<p><img src="/img/%E9%80%9F%E9%80%9Aeffective-modern-cpp/image-20250309155148904.png" alt="image-20250309155148904"></p>
</li>
<li>
<p>右值引用&amp;&amp;只能绑定右值（但他仍然是引用），左值引用&amp;只能绑定左值，</p>
</li>
<li>
<p>那么可见std::move其实就是**将左值类型强制转化为右值。**移动语义没移动 -&gt; 是类本身做的这个事情，如果类没有实现移动构造，那么会调用const T&amp;构造。完美转发不完美，哈哈哈。</p>
</li>
<li>
<p>字符串字面量不是右值，因为它存在静态内存中，是持久存在的。</p>
</li>
<li>
<p><strong>把左值转化为右值的值，成为将亡值，所以它既是左值也是右值。</strong></p>
</li>
<li>
<p>T &amp;&amp;a = std::move(b); 什么都不会发生，差不多等于：T &amp;a = b;</p>
</li>
<li>
<p><strong>顶层const不构成重载。</strong></p>
</li>
<li>
<p><strong>右值引用仍然是左值，</strong></p>
</li>
</ol>
<h3 id="类型推导"><a class="markdownIt-Anchor" href="#类型推导"></a> 类型推导</h3>
<p><img src="/img/%E9%80%9F%E9%80%9Aeffective-modern-cpp/image-20250309155312674.png" alt="image-20250309155312674"></p>
<p><img src="/img/%E9%80%9F%E9%80%9Aeffective-modern-cpp/image-20250309160258748.png" alt="image-20250309160258748"></p>
<ol>
<li>数组名不等于指针，但是数组可以退化成指针。也就是<strong>数组的长度信息丢失了。</strong></li>
<li>字符串字面量，是字符串数组，放在静态区，“hello world” 其实是 const char[12]，所以可以 const char *s = “hello world”来进行赋值。这里发生了数组类型的退化。对于 char *s = “hello world” 来说，编译器会警告，如果进行写操作会段错误。</li>
<li>函数指针与函数名，对函数指针赋值的时候 ptr = func/&amp;func；都可以，可以认为发生了函数名的退化。同样的，在使用的时候 (*ptr)()/ptr(); 都可以，这就比较混乱了。</li>
<li>类型别名，typedef 和 using都可以定义类型别名，不过using更好用。typedef在定义函数指针别名时，需要typedef bool (*func)(int, int)也就是using func = bool (*)(int, int)/ using func = bool (int, int)</li>
<li>函数指针作为返回值使用</li>
</ol>
<h2 id="条款一理解模板类型推导"><a class="markdownIt-Anchor" href="#条款一理解模板类型推导"></a> 条款一：理解模板类型推导</h2>
<p><img src="/img/%E9%80%9F%E9%80%9Aeffective-modern-cpp/image-20250309161826547.png" alt="image-20250309161826547"></p>
<p><img src="/img/%E9%80%9F%E9%80%9Aeffective-modern-cpp/image-20250309162038873.png" alt="image-20250309162038873"></p>
<ol>
<li>
<p>up主想的一个很鬼畜的事情，对函数指针进行底层const，这是没必要的事情，因为函数本身就不可能被修改，总不能深入代码区去修改字节码吧。同样，函数指针的底层const会被编译器忽略，也是很合理的事情。</p>
</li>
<li>
<p>template<typename t=""> func(&amp;&amp; T) 会发生<strong>引用折叠</strong>，会把T的&amp;给折叠成一个，当然引用折叠会发生在多个情况。在函数的声明中使用 &amp;&amp; 是万能引用了，因为既可以接受右值引用也可以接受左值引用。</typename></p>
</li>
<li>
<p>GPT出来的：T&amp;  &amp; 折叠为 T&amp;； T&amp;  &amp;&amp; 折叠为 T&amp;； T&amp;&amp;  &amp; 折叠为 T&amp;&amp;； T&amp;&amp;  &amp;&amp; 折叠为 T&amp;&amp;。</p>
</li>
<li>
<p><strong>万能引用的写法只有 &amp;&amp; T 和 auto &amp;</strong>&amp;，只要稍作更改，比如 const &amp;&amp; T，那么就会变成右值引用。</p>
</li>
</ol>
<h2 id="条款七区别使用与-创建对象"><a class="markdownIt-Anchor" href="#条款七区别使用与-创建对象"></a> 条款七：区别使用（）与 {} 创建对象</h2>
<p><img src="/img/%E9%80%9F%E9%80%9Aeffective-modern-cpp/image-20250309164901023.png" alt="image-20250309164901023"></p>
<p><img src="/img/%E9%80%9F%E9%80%9Aeffective-modern-cpp/image-20250309170228603.png" alt="image-20250309170228603"></p>
<p><img src="/img/%E9%80%9F%E9%80%9Aeffective-modern-cpp/image-20250309165614290.png" alt="image-20250309165614290"></p>
<p><img src="/img/%E9%80%9F%E9%80%9Aeffective-modern-cpp/image-20250309170430444.png" alt="image-20250309170430444"></p>
<p><img src="/img/%E9%80%9F%E9%80%9Aeffective-modern-cpp/image-20250309171047875.png" alt="image-20250309171047875"></p>
<ol>
<li>
<p>构造有五种： A a=10; A a(10); A a=(10); /   A a{10}; A a={10}; 前三种一样（在开启返回值优化之后，否则会发生一次隐式转换），后两种一样（在auto初始化时略有区别）。</p>
</li>
<li>
<p>A a=10;和A a=(10)；的缺陷是，只能接受一个参数，同时会发生一次隐式转换。</p>
</li>
<li>
<p>A a(10)的缺陷是，在作为参数传递时，会发生一次copy构造。</p>
</li>
<li>
<p>A a{10}；的优点就是解决了上面的缺陷，同时<strong>不允许缩窄转换。简化了聚合类的初始化。对解析问题天生免疫。</strong></p>
<p>（解析问题就是括号问题导致的变量声明和函数声明区别）。</p>
</li>
<li>
<p>{}初始化包裹问题，感觉更多的是字面量初始化的时候的问题。</p>
</li>
<li>
<p><strong>总是优先匹配列表初始化，即时编译时报错。除非类型之间不存在隐式转换。</strong></p>
</li>
<li>
<p>空的 { } 不会调用列表初始化，但是{ { } }和 ({ })会</p>
</li>
</ol>
<h2 id="条款二理解auto类型推导"><a class="markdownIt-Anchor" href="#条款二理解auto类型推导"></a> 条款二：理解auto类型推导</h2>
<p><img src="/img/%E9%80%9F%E9%80%9Aeffective-modern-cpp/image-20250309171742198.png" alt="image-20250309171742198"></p>
<ol>
<li>
<p>auto x = {2};会匹配成列表，但是 auto x{2}会把 2 当成int；</p>
</li>
<li>
<p>auto x = {2,3};是列表。但是 auto x{2,3}八成会报错。</p>
</li>
<li>
<p>typelate<typename t=""> func(T x)是推导不出来列表的，必须直接声明出列表。</typename></p>
</li>
<li>
<p>auto作为返回值时，是按模板的规则走的。</p>
</li>
<li>
<p><strong>auto和模板大部分一致，个别不一致。</strong></p>
<h2 id="条款九优先考虑别名声明而非typedef"><a class="markdownIt-Anchor" href="#条款九优先考虑别名声明而非typedef"></a> 条款九：优先考虑别名声明而非typedef</h2>
<p><img src="/img/%E9%80%9F%E9%80%9Aeffective-modern-cpp/image-20250309172701661.png" alt="image-20250309172701661"></p>
<p><img src="/img/%E9%80%9F%E9%80%9Aeffective-modern-cpp/image-20250309173313241.png" alt="image-20250309173313241"></p>
<p><img src="/img/%E9%80%9F%E9%80%9Aeffective-modern-cpp/image-20250309173542873.png" alt="image-20250309173542873"></p>
</li>
<li>
<p>typename 用来澄清模板内部的** T 标志某个类型成员，而非数据成员。**</p>
</li>
<li>
<p><strong>C++默认访问的是一个非类型成员，在使用 :: 的时候。</strong></p>
</li>
<li>
<p>对于模板来说，using比typedef更好用。使用using声明别名可以更清晰的表示是一个类型，即使在模板内部。</p>
</li>
<li>
<p>类型萃取器。用来添加/删除模板T的修饰。也可以用来判断一个对象是否是某个类的实例。</p>
</li>
<li>
<p>注意using的作用域。</p>
</li>
</ol>
<h2 id="条款二十三理解stdmove和stdforward"><a class="markdownIt-Anchor" href="#条款二十三理解stdmove和stdforward"></a> 条款二十三：理解std::move和std::forward</h2>
<p><img src="/img/%E9%80%9F%E9%80%9Aeffective-modern-cpp/image-20250309190343629.png" alt="image-20250309190343629"></p>
<p><img src="/img/%E9%80%9F%E9%80%9Aeffective-modern-cpp/image-20250309192157134.png" alt="image-20250309192157134"></p>
<ol>
<li>std::move的实现：使用类型萃取，把类型萃取出来，然后加上 &amp;&amp; ， std::move本质是右值转换。把一个右值转化为将亡值。让这个对象很适合被移动，但是到底移动不移动，这不好说。，</li>
<li>对于const类型，std::move还是返回的是一个const类型的右值引用，但这个时候const的右值引用和右值引用类型是不匹配的。</li>
<li>std::forward就是转发。结果一个问题：<strong>对于函数参数，T &amp;&amp;param，函数内部一定对param变成一个左值，而非右值。原参数的左右值信息丢失了</strong></li>
<li>std::forward就是有条件的move，只有实参用右值初始化的时候才转化为右值，而std::move本质是将左值转化为右值。</li>
</ol>
<h2 id="条款三理解delctype"><a class="markdownIt-Anchor" href="#条款三理解delctype"></a> 条款三：理解delctype</h2>
<p><img src="/img/%E9%80%9F%E9%80%9Aeffective-modern-cpp/image-20250309192733425.png" alt="image-20250309192733425"></p>
<p><img src="/img/%E9%80%9F%E9%80%9Aeffective-modern-cpp/image-20250309193626706.png" alt="image-20250309193626706"></p>
<ol>
<li>
<p>decltype + 变量，所有信息均被保留，数组与函数也不会退化。</p>
</li>
<li>
<p>decltype + 表达式 会返回表达式结果对应的类型。不是左值就是右值</p>
<p>{左值：得到该类型的引用；右值：得到该类型}</p>
</li>
<li>
<p>decltype 不是实际计算表达式的值，只会推断其类型。</p>
</li>
<li>
<p>decltype(auto)可以保留 xxx 的全部细节。可以认为等价于 auto -&gt; decltype(返回值)</p>
</li>
<li>
<p><strong>右值不一定不能放在等号的左边，因为这本质上是在调用operator = 操作</strong>，但是这种操作应该避免，避免在函数返回值返回 T ，应该返回const T来避免这种情况。</p>
</li>
<li>
<p>func(T &amp;&amp;t) { return t; } 返回的是一个左值，可以用完美转发来替代。</p>
</li>
</ol>
<h3 id="c类对象的布局"><a class="markdownIt-Anchor" href="#c类对象的布局"></a> C++类对象的布局</h3>
<p><img src="/img/%E9%80%9F%E9%80%9Aeffective-modern-cpp/image-20250309194857870.png" alt="image-20250309194857870"></p>
<p><img src="/img/%E9%80%9F%E9%80%9Aeffective-modern-cpp/image-20250309200314815.png" alt="image-20250309200314815"></p>
<ol>
<li>
<p>非虚函数，不会影响对象的大小，放在代码区中。</p>
</li>
<li>
<p><strong>虚函数，当然函数还是放在代码区，会影响对象的大小，多 8/4 个字节，用来存放一个指针，指向虚表。</strong></p>
</li>
<li>
<p>非静态成员，会影响对象大小。</p>
</li>
<li>
<p>静态成员，不会影响对象大小。</p>
</li>
<li>
<p>**有虚函数的类，其地址本身就是指向虚表的指针的地址。**也就是说指向虚表的指针的地址存在类的最起点，可以根据这个地址来进行验证虚表的存在。</p>
</li>
<li>
<p><strong>type_info是C++的一个标准数据类型，在虚表的头，也就是虚表的 -1 处</strong>，记录着有关类的信息。比如类名之类的。</p>
</li>
</ol>
<h3 id="c中的多态和rtti"><a class="markdownIt-Anchor" href="#c中的多态和rtti"></a> C++中的多态和RTTI</h3>
<p><img src="/img/%E9%80%9F%E9%80%9Aeffective-modern-cpp/image-20250309202258454.png" alt="image-20250309202258454"></p>
<p><img src="/img/%E9%80%9F%E9%80%9Aeffective-modern-cpp/image-20250309202712393.png" alt="image-20250309202712393"></p>
<p><img src="/img/%E9%80%9F%E9%80%9Aeffective-modern-cpp/image-20250309203410209.png" alt="image-20250309203410209"></p>
<ol>
<li>**RTTI（RunTime Type Identification）也即运行期间类型识别，但在C++中，只有包含虚函数的类才能支持RTTI。**原因也很简单，因为只有包含虚函数的类，才有虚表，才有type_info</li>
<li>对于需要使用继承的基类，其析构函数应该为虚函数，这点在effective C++也提到了。</li>
<li>对于类的函数来说，成员函数有一个隐含的参数为this指针。相当于Python的self。</li>
<li>**typeid（）**是RTTI的机制，也就是访问虚表的type_info信息。</li>
<li>dynamic_cast 也是RTTI的机制</li>
</ol>
<h3 id="各种类型转换"><a class="markdownIt-Anchor" href="#各种类型转换"></a> 各种类型转换</h3>
<p><img src="/img/%E9%80%9F%E9%80%9Aeffective-modern-cpp/image-20250309204639866.png" alt="image-20250309204639866"></p>
<ol>
<li>static_cast 静态类型转换，这是在编译期间完成的类型转换。
<ul>
<li>子类可以转化成父类。反之不行。</li>
</ul>
</li>
</ol>
<p><img src="/img/%E9%80%9F%E9%80%9Aeffective-modern-cpp/image-20250309204908364.png" alt="image-20250309204908364"></p>
<ol start="2">
<li>dynamic_cast 动态类型转换，在运行期间判断</li>
</ol>
<p><img src="/img/%E9%80%9F%E9%80%9Aeffective-modern-cpp/image-20250309204931074.png" alt="image-20250309204931074"></p>
<ol start="3">
<li>const_cast 增加一个底层const，或者去掉一个底层const
<ul>
<li>虽然可以去掉const，但是操作的时候该段错误还是段错误。</li>
<li>用途是可以<strong>重载const函数。减少代码重复。</strong></li>
</ul>
</li>
</ol>
<p><img src="/img/%E9%80%9F%E9%80%9Aeffective-modern-cpp/image-20250309205308978.png" alt="image-20250309205308978"></p>
<ol start="4">
<li>reinterpret_cast 是重新解释，是最强的类型转换
<ul>
<li>是静态类型转换，是编译期间发生的。</li>
<li>与C语言的强制类型转换略有区别，比如 ： int x = (float)y;  在C语言中，会进行类型转换。但是reinterpret_cast不会进行类型转换，反而告诉你不能转换。</li>
<li>要求两个东西必须 sizeof 相等。</li>
<li>更多用于指针包括整型之间的转换。</li>
</ul>
</li>
</ol>
<h1 id="第二章auto"><a class="markdownIt-Anchor" href="#第二章auto"></a> 第二章：auto</h1>
<h3 id="lambda表达式初探"><a class="markdownIt-Anchor" href="#lambda表达式初探"></a> lambda表达式初探</h3>
<p><img src="/img/%E9%80%9F%E9%80%9Aeffective-modern-cpp/image-20250309205558870.png" alt="image-20250309205558870"></p>
<ol>
<li>
<p>lambda的实现，是实现一个匿名的可调用类，重载了operator ()</p>
<p>例如：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> sz = <span class="number">0</span>; </span><br><span class="line"><span class="keyword">auto</span> Sizecomp = [sz] (<span class="type">const</span> string &amp;a) { <span class="keyword">return</span> a.<span class="built_in">size</span>() &gt; sz; }</span><br></pre></td></tr></tbody></table></figure>
<p>​	-&gt;</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Sizecomp</span> {</span><br><span class="line">	<span class="type">size_t</span> sz;</span><br><span class="line">	<span class="built_in">Sizecomp</span>(<span class="type">size_t</span> sz_) : <span class="built_in">sz</span>(sz_) {}</span><br><span class="line">	<span class="function"><span class="keyword">auto</span> <span class="title">operator</span><span class="params">(<span class="type">const</span> string &amp;a)</span> </span>{ <span class="keyword">return</span> a.<span class="built_in">size</span>() &gt; sz; }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p><img src="/img/%E9%80%9F%E9%80%9Aeffective-modern-cpp/image-20250309211342239.png" alt="image-20250309211342239"></p>
<p><img src="/img/%E9%80%9F%E9%80%9Aeffective-modern-cpp/image-20250309211411411.png" alt="image-20250309211411411"></p>
</li>
<li>
<p>lambda 表达式语法。[captures] (params) specifies exception -&gt; ret { body; }</p>
<ul>
<li>
<p>specfies 默认为 const 相当于类中成员函数的 const 修饰，也即默认不能修改捕获列表中的变量，即使是copy来的变量。</p>
</li>
<li>
<p>exception：可使用noexcept表示函数是否会抛出异常。</p>
</li>
<li>
<p>ret 可选返回类型，大多情况可以自行推导，但<strong>初始化列表不行。</strong></p>
</li>
<li>
<p>params 可选参数列表，since C++14 可以使用 auto</p>
</li>
<li>
<p>capture 捕获列表</p>
<ol>
<li>
<p><strong>只能捕获非静态局部变量</strong>，可按值，按引用或者组合。因为全局变量或者静态变量，<strong>不需要捕获</strong>，按照lambda使用类来实现，是一个局部变量来考虑的话，倒也好理解。</p>
</li>
<li>
<p>**捕获发生在定义，而不是使用时。**这也好理解，lambda是一个局部的对象的示例，当定义之后，就相当于对象的定义以及构造。</p>
</li>
<li>
<p>**广义的捕获（since C++14）：捕获列表客传右值。**这样可以让一个不可拷贝的函数变得可以使用，避免无意义拷贝。</p>
</li>
<li>
<p><strong>特殊的捕获方法</strong></p>
<p>[this] 捕获this指针，可以使用this类型的成员变量与函数。</p>
<p>[=] 捕获所有局部变量的值，包括this。但是是用到哪些才捕获那些，不会实际上全部捕获。</p>
<p>[&amp;] 捕获<sub>，引用</sub></p>
<p>[*this] 捕获*this的<strong>副本</strong>，since C++17</p>
</li>
</ol>
</li>
</ul>
</li>
</ol>
<h3 id="可调用对象类型"><a class="markdownIt-Anchor" href="#可调用对象类型"></a> 可调用对象类型</h3>
<p><img src="/img/%E9%80%9F%E9%80%9Aeffective-modern-cpp/image-20250309212830119.png" alt="image-20250309212830119"></p>
<ol>
<li>
<p>闭包：带有<strong>上下文 (状态)</strong> 的函数。</p>
<ul>
<li>闭包的实现方法：operator()； lambda； std::bind （把一个函数的某个参数特化，有点函数特化的意思）；</li>
<li><strong>为了实现泛型，更加灵活。</strong></li>
</ul>
</li>
<li>
<p>可调用对象和function</p>
<p>C++中的可调用对象</p>
<ul>
<li>
<p>函数  -&gt; <strong>可退化为函数指针</strong></p>
</li>
<li>
<p>函数指针</p>
</li>
<li>
<p>lambda -&gt; 当<strong>捕获列表</strong>一无所有的时候，可退化为函数指针</p>
</li>
<li>
<p>std::bind：</p>
<p>std::bind(callable, arg1, arg2, arg3,….)；callable为可调用对象，如果为类的非静态成员函数，需要在arg1传入对象实例的指针，相当于传this。std::placeholders::_1 等占位符可以用来占位。</p>
</li>
<li>
<p>重载operator() 的类</p>
</li>
</ul>
<p>这五种类型都不同，他们五个不能完全相互转换。</p>
<p>但是<strong>std::function</strong>可以容纳他们五种所有的可调用对象。</p>
</li>
</ol>
<h2 id="条款五优先考虑auto而非显示类型声明"><a class="markdownIt-Anchor" href="#条款五优先考虑auto而非显示类型声明"></a> 条款五：优先考虑auto而非显示类型声明</h2>
<p><img src="/img/%E9%80%9F%E9%80%9Aeffective-modern-cpp/image-20250310185634874.png" alt="image-20250310185634874"></p>
<p><img src="/img/%E9%80%9F%E9%80%9Aeffective-modern-cpp/image-20250310185808816.png" alt="image-20250310185808816"></p>
<p><img src="/img/%E9%80%9F%E9%80%9Aeffective-modern-cpp/image-20250310190018184.png" alt="image-20250310190018184"></p>
<p><img src="/img/%E9%80%9F%E9%80%9Aeffective-modern-cpp/image-20250310190048993.png" alt="image-20250310190048993"></p>
<ol>
<li>
<p>lambda返回值一定要用auto？这不一定，可以用std::function，不过这有一定的性能损耗</p>
</li>
<li>
<p>避免copy，比如：for(auto &amp;p : map) 和 for(const std::pair&lt;int, int&gt; &amp;p : map)，其中类型是错误的，可能会出现一个隐藏的copy。</p>
</li>
</ol>
<h3 id="crtp与expression-templates"><a class="markdownIt-Anchor" href="#crtp与expression-templates"></a> CRTP与Expression Templates</h3>
<p><img src="/img/%E9%80%9F%E9%80%9Aeffective-modern-cpp/image-20250310190948061.png" alt="image-20250310190948061"></p>
<p><img src="/img/%E9%80%9F%E9%80%9Aeffective-modern-cpp/image-20250310191042303.png" alt="image-20250310191042303"></p>
<p><img src="/img/%E9%80%9F%E9%80%9Aeffective-modern-cpp/image-20250310191426979.png" alt="image-20250310191426979"></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/HaoBBNuanMM/article/details/109740504">【编程技术】C++ CRTP &amp; Expression Templates_crtp与expression templates-CSDN博客</a></p>
<ol>
<li>
<p>CRTP 奇异模板递归：</p>
<p>编译器多态实现运行时多态。而且没有查虚表的过程。</p>
</li>
<li>
<p>Expression Templates表达式模板: 延时计算与节省表达式中间结果。</p>
<p>这个在高性能计算中非常强大。</p>
<p>例如：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector v0 = {<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>}, v1 = {<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>}, v2 = {<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>};</span><br><span class="line"><span class="keyword">auto</span> v3 = v0 + v1 + v2; <span class="comment">// 中间有临时变量的存在，导致非常低效</span></span><br></pre></td></tr></tbody></table></figure>
</li>
</ol>
<p>​	延时计算：推迟计算，直到需要结果。</p>
<p><img src="/img/%E9%80%9F%E9%80%9Aeffective-modern-cpp/885b8531b7c266da2093a935283ded46.png" alt="img"></p>
<p>​	也就是说把运算符转化为一个模板类，直到通过模板类来获取结果的时候才进行计算。</p>
<p>​	<strong>优点是直到需要才计算</strong>，缺点是每次访问都需要计算。</p>
<p>​	模板类它本身不存储结果。</p>
<p>​	相当于把运算结果委托给一个模板类，在通过这个委托模板类来获取计算结果时，这个时候模板类才进行计算。</p>
<p>​	就是下面所说的代理类。</p>
<h3 id="auto推导若非己愿则使用显示类型声明"><a class="markdownIt-Anchor" href="#auto推导若非己愿则使用显示类型声明"></a> auto推导若非己愿，则使用显示类型声明</h3>
<ol>
<li>
<p>代理类，代理类就是模仿和增强一些类型的行为为目的而存在的类。</p>
<p>比如：std::vector<bool>::reference 来引用 std:;vector<bool> 的bit。</bool></bool></p>
<p>比如：智能指针是代理类，实现对原始指针的封装。</p>
</li>
<li>
<p>C++不允许一个类型到另一个类型两次隐式类型转换。</p>
</li>
<li>
<p>临时变量的引用，不要用引用来接。也就是不要对临时变量来引用。</p>
<p>例如：A &amp;a = func()[2];  其中 func 返回一个临时变量。</p>
</li>
<li>
<p>第一点和第三点结合起来，可能会导致 auto 推导出一个对临时代理类的引用。</p>
</li>
<li>
<p>请记住：</p>
<ul>
<li>不可见的代理类可能会使 auto 从表达式中推导出不期望得到的类型</li>
<li>显式类型初始化惯用法强制 auto 推导出你想要的类型</li>
</ul>
</li>
</ol>
<h1 id="第三章移步现代c"><a class="markdownIt-Anchor" href="#第三章移步现代c"></a> 第三章：移步现代C++</h1>
<h2 id="条款八优先考虑nullptr而非null和0"><a class="markdownIt-Anchor" href="#条款八优先考虑nullptr而非null和0"></a> 条款八：优先考虑nullptr，而非NULL和0</h2>
<p><img src="/img/%E9%80%9F%E9%80%9Aeffective-modern-cpp/image-20250310200449985.png" alt="image-20250310200449985"></p>
<ul>
<li>
<p>因为 NULL 和 0 是 long 类型，而非指针类型。当重载时，会导致调用与期望不符的函数。</p>
</li>
<li>
<p>使用模板时，<strong>NULL 和 0 可能会导致 long 或 int 类型的模板实例化</strong>，这是灾难性的。</p>
</li>
<li>
<p>nullptr可以保证是一个指针。</p>
</li>
</ul>
<h3 id="构造函数语义学"><a class="markdownIt-Anchor" href="#构造函数语义学"></a> 构造函数语义学</h3>
<p><img src="/img/%E9%80%9F%E9%80%9Aeffective-modern-cpp/image-20250310201144798.png" alt="image-20250310201144798"></p>
<ol>
<li>
<p>编译器是何如完善构造函数的。</p>
<ol>
<li>列表初始化先于构造函数。</li>
<li>基类存在默认构造函数，编译器负责按插子类构造函数。</li>
<li>如果存在虚表指针，编译器进行虚表指针的安放。</li>
</ol>
</li>
<li>
<p>如果定义的class中没有默认的构造函数</p>
<ol>
<li>如果编译器需要做什么，那么会构造默认的构造函数。</li>
<li>否则，编译器不会合成默认构造函数。</li>
</ol>
</li>
<li>
<p>基类如果没有默认构造函数，子类需要手动初始化，这显然。</p>
</li>
<li>
<p>使用 using 去掉子类中冗余的构造函数。using Base::Base; 可以直接使用父类的构造函数。</p>
</li>
</ol>
<h3 id="尽量使用constexpr"><a class="markdownIt-Anchor" href="#尽量使用constexpr"></a> 尽量使用constexpr</h3>
<p><img src="/img/%E9%80%9F%E9%80%9Aeffective-modern-cpp/image-20250310202341274.png" alt="image-20250310202341274"></p>
<p><img src="/img/%E9%80%9F%E9%80%9Aeffective-modern-cpp/image-20250310203256292.png" alt="image-20250310203256292"></p>
<p><img src="/img/%E9%80%9F%E9%80%9Aeffective-modern-cpp/image-20250310204950376.png" alt="image-20250310204950376"></p>
<ol>
<li>
<p>const常量的不确定性。</p>
<p>const的常量必须是真正的字面量才会归为编译器常量。</p>
<p>说白了就是增强了const 的能力，让编译器在编译期间能够得知更多的常量。</p>
</li>
<li>
<p>PS：gcc的数组长度支持动态。</p>
</li>
<li>
<p>constexpr值，只要用constexpr就确定变量是编译期常量。</p>
<p><strong>所有constexpr都是const，但不是所有const都是constexpr。</strong></p>
</li>
<li>
<p>对函数进行constexpr的修饰</p>
<ul>
<li>
<p>C++11 ： 这个时候的 constexpr 纯废物。</p>
<ol>
<li>普通函数返回值必须返回个什么东西。</li>
<li>普通的 constexpr 函数体只能是 return expr； 只能有一句话。而且expr也必须是一个常量表达式</li>
<li>如果传给 constexpr 函数运行时的值，那么 constexpr 函数会退化成一个普通函数。</li>
<li>constexpr 不能传给形参。</li>
<li>constexpr 构造函数初始化列表必须是常量表达式。</li>
<li>constexpr 构造函数的函数体必须为空</li>
<li>所有用constexpr修饰构造函数的类，析构函数都是默认的。</li>
<li>constexpr声明的成员函数，具有 const 属性。</li>
</ol>
</li>
<li>
<p>C++14对 constexpr 进行了增强。</p>
<ol>
<li>C++11 中 1.、2.、6.、8. 限制被删除。</li>
<li>函数可以**修改生命周期与变量表达式相同的对象。**这是容易理解的。</li>
<li>即可退化也可编译期间。</li>
</ol>
</li>
<li>
<p>C++17可以 if constexpr （***）</p>
<p>比 #if 更加优秀的方法。让一部分东西直接不编译。</p>
</li>
</ul>
<p>constexpr显然会提高编译时间。</p>
</li>
</ol>
<h2 id="条款十七理解特殊成员函数的生成"><a class="markdownIt-Anchor" href="#条款十七理解特殊成员函数的生成"></a> 条款十七：理解特殊成员函数的生成</h2>
<p><img src="/img/%E9%80%9F%E9%80%9Aeffective-modern-cpp/image-20250310210703529.png" alt="image-20250310210703529"></p>
<ol>
<li>
<p>声明这五个特殊成员函数之一，那么剩下四个也应该声明出来。</p>
<p>原因：只有需要手动管理资源的时候，才会声明这些函数。</p>
</li>
<li>
<p>C++11以及之后，声明 上图1/2/3 不会生成 4/5.</p>
</li>
<li>
<p>移动构造和复制更像是一种请求，这个时候不会生成默认移动构造函数，就会有问题，导致代码很低效。</p>
</li>
<li>
<p>析构函数如果不声明，永远会自动生成。显然对象必须析构。</p>
</li>
</ol>
<h3 id="c中的异常处理与swap-copy"><a class="markdownIt-Anchor" href="#c中的异常处理与swap-copy"></a> C++中的异常处理与swap &amp; copy</h3>
<p><img src="/img/%E9%80%9F%E9%80%9Aeffective-modern-cpp/image-20250310212625906.png" alt="image-20250310212625906"></p>
<p><img src="/img/%E9%80%9F%E9%80%9Aeffective-modern-cpp/image-20250311203209977.png" alt="image-20250311203209977"></p>
<p><img src="/img/%E9%80%9F%E9%80%9Aeffective-modern-cpp/image-20250311203920388.png" alt="image-20250311203920388"></p>
<p><img src="/img/%E9%80%9F%E9%80%9Aeffective-modern-cpp/image-20250311204215388.png" alt="image-20250311204215388"></p>
<ol>
<li>
<p>异常处理的手段</p>
<p>抛出异常：throw 异常； 然后给调用者，层层递进。</p>
<p>接住异常：catch异常，尽量用引用接住。</p>
<p>如果异常是因为内存不足导致的，那么catch时还是用copy的话可能会出现意想不到的问题。</p>
</li>
<li>
<p>异常类型不确定可以使用 …</p>
</li>
<li>
<p>异常可以递归抛出。</p>
</li>
<li>
<p>栈展开。异常抛出之后，栈的临时变量会被销毁。<strong>栈展开发生在catch</strong>的时候，如果没有东西catch，那么不会进行栈展开。</p>
</li>
<li>
<p>**构造函数的 try catch 。**需要把列表初始化中的给括住。</p>
</li>
<li>
<p>异常安全保证：</p>
<ol>
<li>
<p><strong>不抛出保证</strong>：不抛出异常。</p>
<p><strong>noexcept （constexpr bool）关键字</strong>保证不会抛出异常，如果确定这个函数确实不会出现异常。</p>
<p>但如果声明了 noexcept （constexpr bool）却抛出了异常，那么会直接崩溃。</p>
<p><strong>gunc () noexcept(noexcept(func(a, b)))</strong> 表示如果 func(a, b) 不抛出异常则 gunc 函数不抛出异常。</p>
<p><strong>noexcept 关键字可以是 bool 表达式</strong></p>
</li>
<li>
<p><strong>强异常保证</strong>：抛出异常，状态不变，相当于没有执行。</p>
</li>
<li>
<p>弱异常保证：状态改变，但是状态合理。</p>
</li>
</ol>
</li>
<li>
<p>构造函数如果抛出了异常，那么应该认为对象没有创建出来。</p>
<p>也就是构造函数相当于没有执行，因此对应的析构函数也没有执行。</p>
<p>也就是说，构造函数应该提供强安全保证。</p>
</li>
<li>
<p><strong>copy and swap</strong></p>
<p>operator=(T other) 这里改为临时的变量，然后直接swap，可以<strong>强异常保证</strong></p>
<p>使用copy and swap可以容易的实现强异常保证。</p>
</li>
<li>
<p>关于swap函数，使用友元，然后在函数体中 using std; 并且直接使用 swap 而不是 std::swap</p>
<p>这点在effective C++有说，也就是编译器优先匹配的问题。</p>
</li>
</ol>
<h2 id="条款十四如果函数不抛出异常请使用-noexcept"><a class="markdownIt-Anchor" href="#条款十四如果函数不抛出异常请使用-noexcept"></a> 条款十四：如果函数不抛出异常请使用 noexcept</h2>
<p><img src="/img/%E9%80%9F%E9%80%9Aeffective-modern-cpp/image-20250311210551906.png" alt="image-20250311210551906"></p>
<ol>
<li>一些容器如果移动构造函数不是 noexcept 的话，那么不会去调用移动构造函数。</li>
</ol>
<p><img src="/img/%E9%80%9F%E9%80%9Aeffective-modern-cpp/image-20250311210759577.png" alt="image-20250311210759577"></p>
<h2 id="条款十优先考虑限域-enum-而非未限域-enum"><a class="markdownIt-Anchor" href="#条款十优先考虑限域-enum-而非未限域-enum"></a> 条款十：优先考虑限域 enum 而非未限域 enum</h2>
<p><img src="/img/%E9%80%9F%E9%80%9Aeffective-modern-cpp/image-20250311211129411.png" alt="image-20250311211129411"></p>
<p><img src="/img/%E9%80%9F%E9%80%9Aeffective-modern-cpp/image-20250311211710923.png" alt="image-20250311211710923"></p>
<p><img src="/img/%E9%80%9F%E9%80%9Aeffective-modern-cpp/image-20250311212829145.png" alt="image-20250311212829145"></p>
<ol>
<li>
<p>enum 中的数字可以相等</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> {</span><br><span class="line">	block = <span class="number">0</span>;</span><br><span class="line">	white = <span class="number">0</span>; <span class="comment">// 这是允许的</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<p>未限域的 enum</p>
<ul>
<li>
<p>默认是<strong>全局的</strong>，可能会导致污染。</p>
<p>enum A {a, b};  enum B {b, c};</p>
</li>
<li>
<p><strong>可隐式转换成整型</strong>。 而且如果把一个范围外的整型强制转化为 enum 是奇怪的。</p>
</li>
<li>
<p>通常情况下<strong>无法前置声明</strong>，因为不知道分配多大大小，即使指明 short，int 长度也不行。必须指明都有什么。</p>
</li>
</ul>
</li>
<li>
<p>限域的 enum，相当于变成了一个类型。</p>
<p>并且默认是int，可以得知分配的大小。</p>
<p>同时避免了隐式转换。</p>
<p>可以通过使用模板方法来进行显示转化。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">Color</span> {</span><br><span class="line">	</span><br><span class="line">}; <span class="comment">// 即可，就是限域的 enum</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<p>enum 类型<strong>不能直接支持成员函数。</strong></p>
<p>但是可以：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Color</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">enum</span> <span class="title class_">Value</span> : <span class="type">int</span> {</span><br><span class="line">		Block = <span class="number">0</span>,</span><br><span class="line">		White,</span><br><span class="line">	};</span><br><span class="line"><span class="comment">// 下略</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Value value_;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>来同时支持限域枚举和成员方法。</p>
</li>
<li>
<p>可以用列表初始化有定义整形的枚举类型。</p>
</li>
<li>
<p>可以通过 using 来打开枚举的限域。</p>
</li>
</ol>
<h3 id="友元"><a class="markdownIt-Anchor" href="#友元"></a> 友元</h3>
<ol>
<li>友元，让一个函数或者一个类来访问另一个类的私有部分。</li>
<li>友元不是一个好的编码风格，但是更加灵活。</li>
<li>友元函数和友元类是在<strong>被访问的类</strong>中进行声明的。</li>
<li>友元的声明在 public 和 private 都是可以的。</li>
</ol>
<h2 id="条款十一优先考虑使用-deleted-函数而非使用未定义的私有声明"><a class="markdownIt-Anchor" href="#条款十一优先考虑使用-deleted-函数而非使用未定义的私有声明"></a> 条款十一：优先考虑使用 deleted 函数而非使用未定义的私有声明</h2>
<p><img src="/img/%E9%80%9F%E9%80%9Aeffective-modern-cpp/image-20250311214551204.png" alt="image-20250311214551204"></p>
<p><img src="/img/%E9%80%9F%E9%80%9Aeffective-modern-cpp/image-20250311214617016.png" alt="image-20250311214617016"></p>
<ol>
<li>
<p>原因很简单：</p>
<p><strong>未定义的私有声明可能会被访问：友元。</strong></p>
<p>虽然会出现错误，但是这是一个链接上的错误，不直观。</p>
</li>
<li>
<p>把删除的函数，放在 public 中可以更清楚的知道是因为函数被删除了，而不是因为无权限访问。</p>
</li>
<li>
<p>delete可以用来删除任何函数。可以用来删除全局函数。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">isLuck</span>(<span class="type">int</span> x);</span><br><span class="line"><span class="comment">// 可能会出现 char -&gt; int</span></span><br><span class="line"><span class="comment">// 为了避免：</span></span><br><span class="line"><span class="built_in">isLuck</span>(<span class="type">char</span>) = <span class="keyword">delete</span>;</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<p><strong>delete可以删除一个模板的示例化。</strong></p>
</li>
<li>
<p>delete 可以在类中删除一个指定的成员模板函数。避免传入不想要的类型。</p>
</li>
</ol>
<h2 id="条款十二使用-override-声明重写函数"><a class="markdownIt-Anchor" href="#条款十二使用-override-声明重写函数"></a> 条款十二：使用 override 声明重写函数</h2>
<p><img src="/img/%E9%80%9F%E9%80%9Aeffective-modern-cpp/image-20250311214959952.png" alt="image-20250311214959952"></p>
<ol>
<li>
<p>重写函数其实不需要 override ，只需要：</p>
<ul>
<li>
<p>基类函数为 virtual</p>
</li>
<li>
<p>函数名（析构除外），形参，常量性 必须一致。</p>
</li>
<li>
<p>返回值类型与原类型必须兼容（不一定一致）</p>
</li>
<li>
<p>引用限定符必须一致。</p>
</li>
</ul>
<p>但是报错不直观。</p>
<p>添加 override 可以保证更加明确。</p>
</li>
<li>
<p>final：向虚函数加 final 可以防止派生类重写。</p>
</li>
<li>
<p>final： 用于类可以防止继承</p>
</li>
<li>
<p><strong>引用限定符：用于区分成员函数被左值对象调用还是右值对象调用。</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">get</span>() &amp;;  <span class="comment">// 会被左值调用</span></span><br><span class="line">	<span class="built_in">get</span>() &amp;&amp;; <span class="comment">// 会被右值调用</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
</li>
</ol>
<h2 id="条款十三优先使用-const_iterator-而非-iterator"><a class="markdownIt-Anchor" href="#条款十三优先使用-const_iterator-而非-iterator"></a> 条款十三：优先使用 const_iterator 而非 iterator</h2>
<p><img src="/img/%E9%80%9F%E9%80%9Aeffective-modern-cpp/image-20250311215843242.png" alt="image-20250311215843242"></p>
<ol>
<li>iterator 可以转化成 const_iterator，但是 const_iterator 不能转化为 iterator。因此一些做法会很怪异。</li>
<li>cbegin 和 cend 可以通过想 begin 和 end 传入一个 const 容器获得。</li>
</ol>
<h1 id="第四章智能指针"><a class="markdownIt-Anchor" href="#第四章智能指针"></a> 第四章：智能指针</h1>
<h3 id="堆栈内存分配流程与内存泄漏"><a class="markdownIt-Anchor" href="#堆栈内存分配流程与内存泄漏"></a> 堆栈内存分配流程与内存泄漏</h3>
<p><img src="/img/%E9%80%9F%E9%80%9Aeffective-modern-cpp/image-20250311220637527.png" alt="image-20250311220637527"></p>
<h3 id="c申请内存的各种方法"><a class="markdownIt-Anchor" href="#c申请内存的各种方法"></a> C++申请内存的各种方法</h3>
<p><img src="/img/%E9%80%9F%E9%80%9Aeffective-modern-cpp/image-20250311223226696.png" alt="image-20250311223226696"></p>
<p><img src="/img/%E9%80%9F%E9%80%9Aeffective-modern-cpp/image-20250311224617483.png" alt="image-20250311224617483"></p>
<ol>
<li>
<p>malloc / free 的实现感觉 csapp 已经讲完了。</p>
</li>
<li>
<p>new / delete</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// new 等价于：</span></span><br><span class="line"><span class="type">void</span> *ptr = <span class="keyword">operator</span> <span class="built_in">new</span>(<span class="built_in">sizeof</span>(T));</span><br><span class="line">T *t = (T *)ptr;</span><br><span class="line">t-&gt;<span class="built_in">t</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// delete 等价于：</span></span><br><span class="line">t-&gt;~<span class="built_in">t</span>();</span><br><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(t)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<p>placement new 给定地址原地构造。本身不会额外申请内存。</p>
</li>
<li>
<p>修改类内的 operator new/delete 可以完全控制类的创建。</p>
</li>
</ol>
<h3 id="重写operator-newdelete-的意义"><a class="markdownIt-Anchor" href="#重写operator-newdelete-的意义"></a> 重写operator new/delete 的意义</h3>
<ol>
<li>
<p>内存碎片化。</p>
</li>
<li>
<p>malloc时间开销代价大。</p>
</li>
<li>
<p>::operator new 表示全局的new操作符。</p>
</li>
</ol>
<h3 id="array-newarray-delete与stdallocator的引入"><a class="markdownIt-Anchor" href="#array-newarray-delete与stdallocator的引入"></a> Array new，Array delete与std::allocator的引入</h3>
<p><img src="/img/%E9%80%9F%E9%80%9Aeffective-modern-cpp/image-20250312184900403.png" alt="image-20250312184900403"></p>
<p><img src="/img/%E9%80%9F%E9%80%9Aeffective-modern-cpp/image-20250312185028341.png" alt="image-20250312185028341"></p>
<p><img src="/img/%E9%80%9F%E9%80%9Aeffective-modern-cpp/image-20250312185516037.png" alt="image-20250312185516037"></p>
<ol>
<li>对于new T[]； 如果没有delete [] T；而是delete T，那么 T[] 本身不会出现内存泄漏，但是 T 内部的内存可能会泄露。同时可能会出现崩溃。</li>
<li>如果每个类都重载 new / delete 太臃肿了，那么可以使用 std::allocator 即可。</li>
</ol>
<h2 id="条款十八对于独占资源使用stdunique_ptr"><a class="markdownIt-Anchor" href="#条款十八对于独占资源使用stdunique_ptr"></a> 条款十八：对于独占资源使用std::unique_ptr</h2>
<p><img src="/img/%E9%80%9F%E9%80%9Aeffective-modern-cpp/image-20250312185659937.png" alt="image-20250312185659937"></p>
<ol>
<li>
<p>智能指针的自定义删除器</p>
<p>删除器是可调用对象即可。</p>
<p><img src="/img/%E9%80%9F%E9%80%9Aeffective-modern-cpp/image-20250312190447330.png" alt="image-20250312190447330"></p>
</li>
</ol>
<p><img src="/img/%E9%80%9F%E9%80%9Aeffective-modern-cpp/image-20250312190644963.png" alt="image-20250312190644963"></p>
<h2 id="条款十九对共享资源使用-stdshared_ptr"><a class="markdownIt-Anchor" href="#条款十九对共享资源使用-stdshared_ptr"></a> 条款十九：对共享资源使用 std::shared_ptr</h2>
<p><img src="/img/%E9%80%9F%E9%80%9Aeffective-modern-cpp/image-20250312190815053.png" alt="image-20250312190815053"></p>
<p><img src="/img/%E9%80%9F%E9%80%9Aeffective-modern-cpp/image-20250312190952158.png" alt="image-20250312190952158"></p>
<p><img src="/img/%E9%80%9F%E9%80%9Aeffective-modern-cpp/image-20250312191307825.png" alt="image-20250312191307825"></p>
<p><img src="/img/%E9%80%9F%E9%80%9Aeffective-modern-cpp/image-20250312191526827.png" alt="image-20250312191526827"></p>
<p><img src="/img/%E9%80%9F%E9%80%9Aeffective-modern-cpp/image-20250312191829921.png" alt="image-20250312191829921"></p>
<ol>
<li>
<p>std::shared_ptr 始终是 2 倍指针</p>
<p>另一个指针指向 control block，因此他不会因为可调用对象的类型而变化大小，但是堆上的大小会发生变化。</p>
</li>
<li>
<p><strong>control block的生成时机</strong></p>
<ol>
<li>使用make_shared</li>
<li>通过unique_ptr创建shared_ptr</li>
<li>向shared_ptr的构造函数中传入一个裸指针</li>
<li>其他时候永远不会生成 control block。-&gt; 多个control block 会导致重复释放。</li>
</ol>
</li>
<li>
<p>如果两个共享指针构造时，指向同一个指针，那么可能会重复释放</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>);</span><br><span class="line">{</span><br><span class="line">	<span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">sp1</span><span class="params">(p)</span></span>;</span><br><span class="line">	<span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">sp2</span><span class="params">(p)</span></span>;</span><br><span class="line">} <span class="comment">// 这个时候 sp1, sp2 释放，p 被释放两次</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<p>解决方法：RAII</p>
</li>
<li>
<p>使用 this 指针作为 std::shared_ptr 构造函数实参的例子：</p>
<p>将本身放入智能指针的容器中。</p>
<p><strong><code>shared_ptr</code> 托管的对象需要获得一个指向自己的 <code>shared_ptr</code>。</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">T</span> : <span class="keyword">public</span> std::enable_shared_from_this&lt;T&gt;;</span><br><span class="line"><span class="comment">// 使用 shared_from_this() 就可以得到一个指向自己的指针。</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<p>shared_ptr 不支持数组，但是可以自定义删除器。</p>
</li>
</ol>
<h2 id="条款二十当-stdshared_ptr-可以悬空时使用-stdweak_ptr"><a class="markdownIt-Anchor" href="#条款二十当-stdshared_ptr-可以悬空时使用-stdweak_ptr"></a> 条款二十：当 std::shared_ptr 可以悬空时使用 std::weak_ptr</h2>
<p><img src="/img/%E9%80%9F%E9%80%9Aeffective-modern-cpp/image-20250312192627354.png" alt="image-20250312192627354"></p>
<p><img src="/img/%E9%80%9F%E9%80%9Aeffective-modern-cpp/image-20250312193139122.png" alt="image-20250312193139122"></p>
<ol>
<li>
<p>sweak_ptr 不能单独存在，必须传入一个共享指针。</p>
</li>
<li>
<p>weak_ptr 不能延长堆内存的生死，但是可以<strong>知道堆内存是否生死 （调用 expired() ）</strong></p>
</li>
<li>
<p>weak_ptr 也不能直接访问内存，必须要通过 <strong>lock 方法创建一个 shared_ptr 来访问</strong>。</p>
</li>
<li>
<p>weak_ptr 的作用：<strong>监视者。</strong></p>
</li>
<li>
<p>智能指针对资源有完全的控制权。而 weak_ptr 不影响 shared_ptr 的释放。</p>
<p>比如：缓存。</p>
<p>缓存过期就是 shared_ptr 指针释放，但是我在缓存中不希望影响外部指针的释放。</p>
<p>为了避免这种情况，可以使用 weak_ptr。</p>
</li>
<li>
<p>上面图中的 2 中所展示的，有一个所谓的<strong>循环引用。</strong></p>
</li>
</ol>
<h2 id="条款二十一优先考虑使用stdmake_unique和stdmake_shared而非new"><a class="markdownIt-Anchor" href="#条款二十一优先考虑使用stdmake_unique和stdmake_shared而非new"></a> 条款二十一：优先考虑使用std::make_unique和std::make_shared而非new</h2>
<p><img src="/img/%E9%80%9F%E9%80%9Aeffective-modern-cpp/image-20250312193750342.png" alt="image-20250312193750342"></p>
<p><img src="/img/%E9%80%9F%E9%80%9Aeffective-modern-cpp/image-20250312193757302.png" alt="image-20250312193757302"></p>
<p><img src="/img/%E9%80%9F%E9%80%9Aeffective-modern-cpp/image-20250312193928467.png" alt="image-20250312193928467"></p>
<p><img src="/img/%E9%80%9F%E9%80%9Aeffective-modern-cpp/image-20250312194136217.png" alt="image-20250312194136217"></p>
<p><img src="/img/%E9%80%9F%E9%80%9Aeffective-modern-cpp/image-20250312194115756.png" alt="image-20250312194115756"></p>
<p><img src="/img/%E9%80%9F%E9%80%9Aeffective-modern-cpp/image-20250312194257579.png" alt="image-20250312194257579"></p>
<p><img src="/img/%E9%80%9F%E9%80%9Aeffective-modern-cpp/image-20250312194628757.png" alt="image-20250312194628757"></p>
<ol>
<li>
<p>避免异常问题，如果操作被打断，make_shared 可以保证内存不会泄露。</p>
</li>
<li>
<p>make的局限</p>
<ul>
<li>
<p>删除器没办法传递</p>
</li>
<li>
<p>无法通过 { } 初始化指向的对象，因为 { } 无法完美转发</p>
</li>
<li>
<p>如果类中重载了 operator new / delete 使用 make_shared <strong>不会调用重载函数</strong>，这个时候只能使用 shared_ptr 或者 std::allocated_shared.</p>
</li>
<li>
<p>使用 make_shared ， T object 与 control block 会一起申请，也会一起释放。</p>
<p><strong>当 weak_ptr 存在时，对象的销毁与内存释放之间的间隔时间可能很长。</strong></p>
</li>
</ul>
</li>
</ol>
<h2 id="条款二十二当使用pimpl惯用法请在实现文件中定义特殊成员函数"><a class="markdownIt-Anchor" href="#条款二十二当使用pimpl惯用法请在实现文件中定义特殊成员函数"></a> 条款二十二：当使用Pimpl惯用法，请在实现文件中定义特殊成员函数</h2>
<p><img src="/img/%E9%80%9F%E9%80%9Aeffective-modern-cpp/image-20250312202152295.png" alt="image-20250312202152295"></p>
<p><img src="/img/%E9%80%9F%E9%80%9Aeffective-modern-cpp/image-20250312202359427.png" alt="image-20250312202359427"></p>
<p><img src="/img/%E9%80%9F%E9%80%9Aeffective-modern-cpp/image-20250312202609161.png" alt="image-20250312202609161"></p>
<ol>
<li>
<p><strong>Pimpl即Point to Implementation</strong> 是减少代码依赖和编译时间的技巧。</p>
<p>其基本思想是将一个外部可见类(visible class)的实现细节（一般是所有私有的非虚成员）放在一个单独的实现类(implementation class)中，而在可见类中通过一个私有指针来间接访问该实现类。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用Pimpl</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在头文件person.hpp中</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> {</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Person</span>();</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// Person类的实现细节放置在该前向声明的实现类中。</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">Impl</span>;</span><br><span class="line">  <span class="comment">// 指向实现类Impl的私有指针</span></span><br><span class="line">  std::unique_ptr&lt;Impl&gt; pimpl_;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在源文件person.cpp中</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"person.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"basic_info.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span>::Impl {</span><br><span class="line">  std::string name;</span><br><span class="line">  std::string id;</span><br><span class="line">  BasicInfo basic_info;</span><br><span class="line">};</span><br><span class="line">Person::<span class="built_in">Person</span>() : <span class="built_in">pimpl_</span>(std::<span class="built_in">make_unique</span>&lt;Impl&gt;()) {}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<p><strong>如果不在实现文件中实现特殊成员函数，生成的默认函数会导致编译不通过</strong> 这是因为默认生成的代码已经在使用类型了实际上。</p>
</li>
</ol>
<h1 id="第五章右值引用-移动语义-完美转发"><a class="markdownIt-Anchor" href="#第五章右值引用-移动语义-完美转发"></a> 第五章：右值引用 移动语义 完美转发</h1>
<h2 id="条款二十四区分通用万能引用与右值引用"><a class="markdownIt-Anchor" href="#条款二十四区分通用万能引用与右值引用"></a> 条款二十四：区分通用（万能）引用与右值引用</h2>
<p><img src="/img/%E9%80%9F%E9%80%9Aeffective-modern-cpp/image-20250312203033399.png" alt="image-20250312203033399"></p>
<p><img src="/img/%E9%80%9F%E9%80%9Aeffective-modern-cpp/image-20250312203448927.png" alt="image-20250312203448927"></p>
<p><strong>什么是通用引用？什么不是通用引用？</strong></p>
<ol>
<li>
<p>模板的通用引用 要求： T&amp;&amp; + 类型推导（必须是模板）</p>
</li>
<li>
<p>可变参数模板的通用引用，要求： Args &amp;&amp;… + 类型推导</p>
</li>
<li>
<p>auto 的通用引用 要求：auto &amp;&amp;/ auto &amp;&amp;… + 类型推导</p>
</li>
</ol>
<h3 id="c的返回值优化"><a class="markdownIt-Anchor" href="#c的返回值优化"></a> C++的返回值优化</h3>
<p><img src="/img/%E9%80%9F%E9%80%9Aeffective-modern-cpp/image-20250312204003198.png" alt="image-20250312204003198"></p>
<p><img src="/img/%E9%80%9F%E9%80%9Aeffective-modern-cpp/image-20250312204900492.png" alt="image-20250312204900492"></p>
<p><a target="_blank" rel="noopener" href="https://pvs-studio.com/en/blog/terms/6516/">RVO 和 NRVO</a></p>
<ol>
<li>
<p>**URVO（Unknown Return Value Optimization）**匿名返回值优化</p>
<p>C++17以及之后，这是编译器必须遵守的规则。</p>
<p>URVO不可被禁用。</p>
</li>
<li>
<p>**NRVO（Named Return Value Optimization）**具名返回值优化.</p>
<p>但是，只有当实际返回的对象类型和根据函数签名返回的对象类型完全一致时，我们才能应用 NRVO。</p>
<p>NRVO可以被禁用。</p>
</li>
</ol>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">GetVector2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">result</span><span class="params">(<span class="number">1'000'000</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  <span class="keyword">auto</span> vect = <span class="built_in">GetVector</span>();</span><br><span class="line">  ....</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 优化之后：</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GetVector2</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt; *x)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  <span class="keyword">new</span> (x) std::<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">1'000'000</span>, <span class="number">0</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  <span class="keyword">auto</span> *x = <span class="keyword">static_cast</span>&lt;std::vector&lt;<span class="type">int</span>&gt; *&gt;(</span><br><span class="line">              <span class="built_in">alloca</span>(<span class="built_in">sizeof</span>(std::vector&lt;<span class="type">int</span>&gt;)));</span><br><span class="line">  <span class="built_in">GetVector2</span>(x);</span><br><span class="line">  ....</span><br><span class="line">  <span class="keyword">delete</span> x;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong>返回值优化失效</strong></p>
<p>失效指 NRVO 失效，而不是 VRVO 失效。</p>
<ol>
<li>
<p>可能返回不同对象。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">T <span class="title">func</span><span class="params">(<span class="type">bool</span> f)</span> </span>{</span><br><span class="line">	<span class="function">T <span class="title">t1</span><span class="params">(<span class="number">1</span>)</span>, <span class="title">t2</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">	<span class="comment">/* do something both t1 and t2 */</span></span><br><span class="line">	<span class="keyword">if</span> (f) </span><br><span class="line">		<span class="keyword">return</span> t1;</span><br><span class="line">	<span class="keyword">return</span> t2;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<p>返回一个全局变量</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">T a;</span><br><span class="line"><span class="function">T <span class="title">fun</span><span class="params">()</span> </span>{</span><br><span class="line">	<span class="keyword">return</span> a; </span><br><span class="line">}</span><br><span class="line"><span class="comment">// 因为 a 是一个全局变量，即使返回也是左值</span></span><br><span class="line"><span class="comment">// 也就是生命周期很长</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<p>返回函数参数</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">T <span class="title">fun</span><span class="params">(T &amp;t)</span> </span>{</span><br><span class="line">	<span class="keyword">return</span> t;</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 与上面一样，是生命周期超过函数本身</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<p>存在赋值行为</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">T <span class="title">fun</span><span class="params">()</span> </span>{</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">T</span>(<span class="number">10</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>{</span><br><span class="line">	<span class="function">T <span class="title">result</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line">	result = <span class="built_in">fun</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 因为存在 result 的反复初始化。肯定不能优化</span></span><br><span class="line"><span class="comment">// 而且直接赋值也更符合这段代码的逻辑。</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<p>返回成员变量</p>
<p>和2、3一样，都是生命周期长于函数本身</p>
</li>
<li>
<p>使用std::move()返回</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">T <span class="title">fun</span><span class="params">()</span> </span>{</span><br><span class="line">	<span class="function">T <span class="title">t</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">	<span class="keyword">return</span> std::<span class="built_in">move</span>(t);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>{</span><br><span class="line">	T result = <span class="built_in">fun</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 因为编译器不能改变行为，有move就必须move</span></span><br><span class="line"><span class="comment">// 而且因为编译器不能轻易猜测函数的行为（move的行为）</span></span><br><span class="line"><span class="comment">// 这就导致了编译器的无法优化</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="条款二十五对右值引用使用stdmove对通用万能引用使用stdforward"><a class="markdownIt-Anchor" href="#条款二十五对右值引用使用stdmove对通用万能引用使用stdforward"></a> 条款二十五：对右值引用使用std::move，对通用（万能）引用使用std::forward</h2>
<p><img src="/img/%E9%80%9F%E9%80%9Aeffective-modern-cpp/image-20250312211127257.png" alt="image-20250312211127257"></p>
<p><img src="/img/%E9%80%9F%E9%80%9Aeffective-modern-cpp/image-20250312211725309.png" alt="image-20250312211725309"></p>
<p><img src="/img/%E9%80%9F%E9%80%9Aeffective-modern-cpp/image-20250312211742704.png" alt="image-20250312211742704"></p>
</li>
<li>
<p>const 引用与右值引用重载提高效率。</p>
</li>
<li>
<p>使用通用引用可以更好的完成任务。</p>
</li>
<li>
<p>返回万能引用用forward，返回右值引用用move</p>
</li>
</ol>
<h3 id="emplace_back与push_back"><a class="markdownIt-Anchor" href="#emplace_back与push_back"></a> emplace_back与push_back</h3>
<p><img src="/img/%E9%80%9F%E9%80%9Aeffective-modern-cpp/image-20250312211945377.png" alt="image-20250312211945377"></p>
<ol>
<li>
<p>push_back 是模板，但不是通用引用。</p>
<p>重载两个函数来区分右值和左值。</p>
</li>
<li>
<p>emplace_back 是可变参数模板，可以区分左右值，一定是万能引用。</p>
</li>
<li>
<p>编译器时间的对比，emplace_back时间更长，因为是一个一个模板。</p>
</li>
</ol>
<h2 id="条款二十六避免在通用引用上重载"><a class="markdownIt-Anchor" href="#条款二十六避免在通用引用上重载"></a> 条款二十六：避免在通用引用上重载</h2>
<p><img src="/img/%E9%80%9F%E9%80%9Aeffective-modern-cpp/image-20250312212559726.png" alt="image-20250312212559726"></p>
<p><img src="/img/%E9%80%9F%E9%80%9Aeffective-modern-cpp/image-20250312212748437.png" alt="image-20250312212748437"></p>
<p><img src="/img/%E9%80%9F%E9%80%9Aeffective-modern-cpp/image-20250312212856029.png" alt="image-20250312212856029"></p>
<ol>
<li>
<p>通用引用普通函数的重载。</p>
<p>主要原因在于隐式转换，因为多个int类型之间存在隐式转换。</p>
</li>
<li>
<p>通用引用构造函数的重载。</p>
<p>主要原因在于 const 修饰和 右值类型 不完全匹配，导致走上不希望的函数。</p>
</li>
<li>
<p>在 2 的基础上加上继承。</p>
<p>也是因为类型的不完全匹配，导致不希望的函数。</p>
</li>
</ol>
<p><strong>总结：不完全的匹配</strong></p>
<h3 id="模板元编程初探sfinaeenable_if"><a class="markdownIt-Anchor" href="#模板元编程初探sfinaeenable_if"></a> 模板元编程初探，SFINAE，enable_if</h3>
<p><img src="/img/%E9%80%9F%E9%80%9Aeffective-modern-cpp/image-20250312213211803.png" alt="image-20250312213211803"></p>
<p><img src="/img/%E9%80%9F%E9%80%9Aeffective-modern-cpp/image-20250312213827579.png" alt="image-20250312213827579"></p>
<p><img src="/img/%E9%80%9F%E9%80%9Aeffective-modern-cpp/image-20250312214112434.png" alt="image-20250312214112434"></p>
<ol>
<li>
<p>元(meta)的含义： meta X = X about X</p>
<p>模板元编程：用模板编写程序的程序</p>
<p>模板元函数：编译期执行且输入输出都可为数值（只能为bool或者整型），也可以为类型。</p>
<p>编译期间执行</p>
</li>
<li>
<p>SFINAE 替换失败并非错误</p>
<p>写一个明显错误的东西，但是替换失败并不报错，让一个函数永远不会被调用。只是让一个万能引用不会被匹配上。</p>
</li>
<li>
<p>enable_if</p>
</li>
</ol>
<p>​	通过让匹配模板有时能匹配上，有时匹配不上，来排除和选择。</p>
<p>​	<strong>enable_if<condition>::type 来获得类型。</condition></strong></p>
<h2 id="条款四十一对于移动成本低且总是被拷贝的可拷贝形参考虑按值传递"><a class="markdownIt-Anchor" href="#条款四十一对于移动成本低且总是被拷贝的可拷贝形参考虑按值传递"></a> 条款四十一：对于移动成本低且总是被拷贝的可拷贝形参，考虑按值传递</h2>
<p><img src="/img/%E9%80%9F%E9%80%9Aeffective-modern-cpp/image-20250312214517501.png" alt="image-20250312214517501"></p>
<p><img src="/img/%E9%80%9F%E9%80%9Aeffective-modern-cpp/image-20250312214915438.png" alt="image-20250312214915438"></p>
<p>​	## 条款二十七：熟悉通用引用重载的替代方法。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="https://Dog-Du.github.io">DogDu</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="https://dog-du.github.io/2025/03/09/%E9%80%9F%E9%80%9Aeffective-modern-cpp/">https://dog-du.github.io/2025/03/09/%E9%80%9F%E9%80%9Aeffective-modern-cpp/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%85%AB%E8%82%A1/">八股</a><a class="post-meta__tags" href="/tags/%E6%9C%AA%E5%AE%8C%E6%88%90/">未完成</a><a class="post-meta__tags" href="/tags/C/">C++</a></div><div class="post-share"><div class="social-share" data-image="/img/top_img.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/03/03/CSAPP%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/" title="CSAPP学习记录（已完结）"><img class="cover" src="/img/top_img.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">Previous</div><div class="info-item-2">CSAPP学习记录（已完结）</div></div><div class="info-2"><div class="info-item-1">CSAPP的LAB完成记录，本体不含代码，但包括读书笔记和代码仓库</div></div></div></a><a class="pagination-related" href="/2025/03/10/%E8%AE%A1%E7%BD%91%E5%85%AB%E8%82%A1/" title="计网八股"><img class="cover" src="/img/top_img.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">Next</div><div class="info-item-2">计网八股</div></div><div class="info-2"><div class="info-item-1">看小林coding，嗯背计网八股</div></div></div></a></nav><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> Comments</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/head.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">DogDu</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">14</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">10</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">2</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Dog-Du"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is DogDu's Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC"><span class="toc-text"> 第一章：类型推导</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B6%E5%B1%82const%E5%92%8C%E5%BA%95%E5%B1%82const"><span class="toc-text"> 顶层const和底层const</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%80%BC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8"><span class="toc-text"> 值类型与右值引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC"><span class="toc-text"> 类型推导</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE%E4%B8%80%E7%90%86%E8%A7%A3%E6%A8%A1%E6%9D%BF%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC"><span class="toc-text"> 条款一：理解模板类型推导</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE%E4%B8%83%E5%8C%BA%E5%88%AB%E4%BD%BF%E7%94%A8%E4%B8%8E-%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1"><span class="toc-text"> 条款七：区别使用（）与 {} 创建对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE%E4%BA%8C%E7%90%86%E8%A7%A3auto%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC"><span class="toc-text"> 条款二：理解auto类型推导</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE%E4%B9%9D%E4%BC%98%E5%85%88%E8%80%83%E8%99%91%E5%88%AB%E5%90%8D%E5%A3%B0%E6%98%8E%E8%80%8C%E9%9D%9Etypedef"><span class="toc-text"> 条款九：优先考虑别名声明而非typedef</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE%E4%BA%8C%E5%8D%81%E4%B8%89%E7%90%86%E8%A7%A3stdmove%E5%92%8Cstdforward"><span class="toc-text"> 条款二十三：理解std::move和std::forward</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE%E4%B8%89%E7%90%86%E8%A7%A3delctype"><span class="toc-text"> 条款三：理解delctype</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#c%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B8%83%E5%B1%80"><span class="toc-text"> C++类对象的布局</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#c%E4%B8%AD%E7%9A%84%E5%A4%9A%E6%80%81%E5%92%8Crtti"><span class="toc-text"> C++中的多态和RTTI</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%84%E7%A7%8D%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-text"> 各种类型转换</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0auto"><span class="toc-text"> 第二章：auto</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%88%9D%E6%8E%A2"><span class="toc-text"> lambda表达式初探</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E8%B0%83%E7%94%A8%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B"><span class="toc-text"> 可调用对象类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE%E4%BA%94%E4%BC%98%E5%85%88%E8%80%83%E8%99%91auto%E8%80%8C%E9%9D%9E%E6%98%BE%E7%A4%BA%E7%B1%BB%E5%9E%8B%E5%A3%B0%E6%98%8E"><span class="toc-text"> 条款五：优先考虑auto而非显示类型声明</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#crtp%E4%B8%8Eexpression-templates"><span class="toc-text"> CRTP与Expression Templates</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#auto%E6%8E%A8%E5%AF%BC%E8%8B%A5%E9%9D%9E%E5%B7%B1%E6%84%BF%E5%88%99%E4%BD%BF%E7%94%A8%E6%98%BE%E7%A4%BA%E7%B1%BB%E5%9E%8B%E5%A3%B0%E6%98%8E"><span class="toc-text"> auto推导若非己愿，则使用显示类型声明</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%A7%BB%E6%AD%A5%E7%8E%B0%E4%BB%A3c"><span class="toc-text"> 第三章：移步现代C++</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE%E5%85%AB%E4%BC%98%E5%85%88%E8%80%83%E8%99%91nullptr%E8%80%8C%E9%9D%9Enull%E5%92%8C0"><span class="toc-text"> 条款八：优先考虑nullptr，而非NULL和0</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E8%AF%AD%E4%B9%89%E5%AD%A6"><span class="toc-text"> 构造函数语义学</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%BD%E9%87%8F%E4%BD%BF%E7%94%A8constexpr"><span class="toc-text"> 尽量使用constexpr</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE%E5%8D%81%E4%B8%83%E7%90%86%E8%A7%A3%E7%89%B9%E6%AE%8A%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E7%9A%84%E7%94%9F%E6%88%90"><span class="toc-text"> 条款十七：理解特殊成员函数的生成</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#c%E4%B8%AD%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E4%B8%8Eswap-copy"><span class="toc-text"> C++中的异常处理与swap &amp; copy</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE%E5%8D%81%E5%9B%9B%E5%A6%82%E6%9E%9C%E5%87%BD%E6%95%B0%E4%B8%8D%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8%E8%AF%B7%E4%BD%BF%E7%94%A8-noexcept"><span class="toc-text"> 条款十四：如果函数不抛出异常请使用 noexcept</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE%E5%8D%81%E4%BC%98%E5%85%88%E8%80%83%E8%99%91%E9%99%90%E5%9F%9F-enum-%E8%80%8C%E9%9D%9E%E6%9C%AA%E9%99%90%E5%9F%9F-enum"><span class="toc-text"> 条款十：优先考虑限域 enum 而非未限域 enum</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8B%E5%85%83"><span class="toc-text"> 友元</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE%E5%8D%81%E4%B8%80%E4%BC%98%E5%85%88%E8%80%83%E8%99%91%E4%BD%BF%E7%94%A8-deleted-%E5%87%BD%E6%95%B0%E8%80%8C%E9%9D%9E%E4%BD%BF%E7%94%A8%E6%9C%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E7%A7%81%E6%9C%89%E5%A3%B0%E6%98%8E"><span class="toc-text"> 条款十一：优先考虑使用 deleted 函数而非使用未定义的私有声明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE%E5%8D%81%E4%BA%8C%E4%BD%BF%E7%94%A8-override-%E5%A3%B0%E6%98%8E%E9%87%8D%E5%86%99%E5%87%BD%E6%95%B0"><span class="toc-text"> 条款十二：使用 override 声明重写函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE%E5%8D%81%E4%B8%89%E4%BC%98%E5%85%88%E4%BD%BF%E7%94%A8-const_iterator-%E8%80%8C%E9%9D%9E-iterator"><span class="toc-text"> 条款十三：优先使用 const_iterator 而非 iterator</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="toc-text"> 第四章：智能指针</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86%E6%A0%88%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E6%B5%81%E7%A8%8B%E4%B8%8E%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="toc-text"> 堆栈内存分配流程与内存泄漏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#c%E7%94%B3%E8%AF%B7%E5%86%85%E5%AD%98%E7%9A%84%E5%90%84%E7%A7%8D%E6%96%B9%E6%B3%95"><span class="toc-text"> C++申请内存的各种方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E5%86%99operator-newdelete-%E7%9A%84%E6%84%8F%E4%B9%89"><span class="toc-text"> 重写operator new&#x2F;delete 的意义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#array-newarray-delete%E4%B8%8Estdallocator%E7%9A%84%E5%BC%95%E5%85%A5"><span class="toc-text"> Array new，Array delete与std::allocator的引入</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE%E5%8D%81%E5%85%AB%E5%AF%B9%E4%BA%8E%E7%8B%AC%E5%8D%A0%E8%B5%84%E6%BA%90%E4%BD%BF%E7%94%A8stdunique_ptr"><span class="toc-text"> 条款十八：对于独占资源使用std::unique_ptr</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE%E5%8D%81%E4%B9%9D%E5%AF%B9%E5%85%B1%E4%BA%AB%E8%B5%84%E6%BA%90%E4%BD%BF%E7%94%A8-stdshared_ptr"><span class="toc-text"> 条款十九：对共享资源使用 std::shared_ptr</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE%E4%BA%8C%E5%8D%81%E5%BD%93-stdshared_ptr-%E5%8F%AF%E4%BB%A5%E6%82%AC%E7%A9%BA%E6%97%B6%E4%BD%BF%E7%94%A8-stdweak_ptr"><span class="toc-text"> 条款二十：当 std::shared_ptr 可以悬空时使用 std::weak_ptr</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE%E4%BA%8C%E5%8D%81%E4%B8%80%E4%BC%98%E5%85%88%E8%80%83%E8%99%91%E4%BD%BF%E7%94%A8stdmake_unique%E5%92%8Cstdmake_shared%E8%80%8C%E9%9D%9Enew"><span class="toc-text"> 条款二十一：优先考虑使用std::make_unique和std::make_shared而非new</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE%E4%BA%8C%E5%8D%81%E4%BA%8C%E5%BD%93%E4%BD%BF%E7%94%A8pimpl%E6%83%AF%E7%94%A8%E6%B3%95%E8%AF%B7%E5%9C%A8%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E4%B8%AD%E5%AE%9A%E4%B9%89%E7%89%B9%E6%AE%8A%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-text"> 条款二十二：当使用Pimpl惯用法，请在实现文件中定义特殊成员函数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8-%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89-%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91"><span class="toc-text"> 第五章：右值引用 移动语义 完美转发</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE%E4%BA%8C%E5%8D%81%E5%9B%9B%E5%8C%BA%E5%88%86%E9%80%9A%E7%94%A8%E4%B8%87%E8%83%BD%E5%BC%95%E7%94%A8%E4%B8%8E%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8"><span class="toc-text"> 条款二十四：区分通用（万能）引用与右值引用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#c%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC%E4%BC%98%E5%8C%96"><span class="toc-text"> C++的返回值优化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE%E4%BA%8C%E5%8D%81%E4%BA%94%E5%AF%B9%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E4%BD%BF%E7%94%A8stdmove%E5%AF%B9%E9%80%9A%E7%94%A8%E4%B8%87%E8%83%BD%E5%BC%95%E7%94%A8%E4%BD%BF%E7%94%A8stdforward"><span class="toc-text"> 条款二十五：对右值引用使用std::move，对通用（万能）引用使用std::forward</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#emplace_back%E4%B8%8Epush_back"><span class="toc-text"> emplace_back与push_back</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE%E4%BA%8C%E5%8D%81%E5%85%AD%E9%81%BF%E5%85%8D%E5%9C%A8%E9%80%9A%E7%94%A8%E5%BC%95%E7%94%A8%E4%B8%8A%E9%87%8D%E8%BD%BD"><span class="toc-text"> 条款二十六：避免在通用引用上重载</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E5%85%83%E7%BC%96%E7%A8%8B%E5%88%9D%E6%8E%A2sfinaeenable_if"><span class="toc-text"> 模板元编程初探，SFINAE，enable_if</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE%E5%9B%9B%E5%8D%81%E4%B8%80%E5%AF%B9%E4%BA%8E%E7%A7%BB%E5%8A%A8%E6%88%90%E6%9C%AC%E4%BD%8E%E4%B8%94%E6%80%BB%E6%98%AF%E8%A2%AB%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%8F%AF%E6%8B%B7%E8%B4%9D%E5%BD%A2%E5%8F%82%E8%80%83%E8%99%91%E6%8C%89%E5%80%BC%E4%BC%A0%E9%80%92"><span class="toc-text"> 条款四十一：对于移动成本低且总是被拷贝的可拷贝形参，考虑按值传递</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Posts</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/10/%E8%AE%A1%E7%BD%91%E5%85%AB%E8%82%A1/" title="计网八股">计网八股</a><time datetime="2025-03-10T00:54:15.000Z" title="Created 2025-03-10 08:54:15">2025-03-10</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/09/%E9%80%9F%E9%80%9Aeffective-modern-cpp/" title="听课，速通effective-modern-cpp">听课，速通effective-modern-cpp</a><time datetime="2025-03-09T13:54:15.000Z" title="Created 2025-03-09 21:54:15">2025-03-09</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/03/CSAPP%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/" title="CSAPP学习记录（已完结）">CSAPP学习记录（已完结）</a><time datetime="2025-03-03T12:44:15.000Z" title="Created 2025-03-03 20:44:15">2025-03-03</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By DogDu</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.3</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="Scroll to Comments"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null

  const commentCount = n => {
    const isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
    if (isCommentCount) {
      isCommentCount.textContent= n
    }
  }

  const initGitalk = (el, path) => {
    if (isShuoshuo) {
      window.shuoshuoComment.destroyGitalk = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }

    const gitalk = new Gitalk({
      clientID: 'Ov23lip70wbjDSj3yXVa',
      clientSecret: '229af146a5a288cca20082b54bcaf2ea896347af',
      repo: 'Dog-Du.github.io',
      owner: 'Dog-Du',
      admin: ['Dog-Du'],
      updateCountCallback: commentCount,
      ...option,
      id: (decodeURIComponent(location.pathname)).substring(0, 48),
      distractionFreeMode: false
    })

    gitalk.render('gitalk-container')
  }

  const loadGitalk = async(el, path) => {
    if (typeof Gitalk === 'function') initGitalk(el, path)
    else {
      await btf.getCSS('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css')
      await btf.getScript('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js')
      initGitalk(el, path)
    }
  }

  if (isShuoshuo) {
    'Gitalk' === 'Gitalk'
      ? window.shuoshuoComment = { loadComment: loadGitalk }
      : window.loadOtherComment = loadGitalk
    return
  }

  if ('Gitalk' === 'Gitalk' || !false) {
    if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
    else loadGitalk()
  } else {
    window.loadOtherComment = loadGitalk
  }
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>