<!DOCTYPE html><html lang="cn-ZH" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>计网复习 | DogDu's blog</title><meta name="author" content="DogDu"><meta name="copyright" content="DogDu"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="看小林coding，复习计网">
<meta property="og:type" content="article">
<meta property="og:title" content="计网复习">
<meta property="og:url" content="https://dog-du.github.io/2025/03/10/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/index.html">
<meta property="og:site_name" content="DogDu&#39;s blog">
<meta property="og:description" content="看小林coding，复习计网">
<meta property="og:locale" content="cn_ZH">
<meta property="og:image" content="https://dog-du.github.io/img/top_img.jpg">
<meta property="article:published_time" content="2025-03-10T00:54:15.000Z">
<meta property="article:modified_time" content="2025-03-29T13:07:24.632Z">
<meta property="article:author" content="DogDu">
<meta property="article:tag" content="已完成">
<meta property="article:tag" content="复习">
<meta property="article:tag" content="计算机网络">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://dog-du.github.io/img/top_img.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "计网复习",
  "url": "https://dog-du.github.io/2025/03/10/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/",
  "image": "https://dog-du.github.io/img/top_img.jpg",
  "datePublished": "2025-03-10T00:54:15.000Z",
  "dateModified": "2025-03-29T13:07:24.632Z",
  "author": [
    {
      "@type": "Person",
      "name": "DogDu",
      "url": "https://dog-du.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/head.jpg"><link rel="canonical" href="https://dog-du.github.io/2025/03/10/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":300,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '计网复习',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="alternate" href="/atom.xml" title="DogDu's blog" type="application/atom+xml">
</head><body><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/top_img.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="/img/head.jpg" alt="Logo"><span class="site-name">DogDu's blog</span></a><a class="nav-page-title" href="/"><span class="site-name">计网复习</span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">计网复习</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2025-03-10T00:54:15.000Z" title="Created 2025-03-10 08:54:15">2025-03-10</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2025-03-29T13:07:24.632Z" title="Updated 2025-03-29 21:07:24">2025-03-29</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%AD%A6%E4%B9%A0%E7%B1%BB/">学习类</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p><a target="_blank" rel="noopener" href="https://xiaolincoding.com/network/">图解网络介绍 | 小林coding</a></p>
<h1 id="基础篇"><a class="markdownIt-Anchor" href="#基础篇"></a> 基础篇</h1>
<h2 id="tcpip-网络模型有哪几层"><a class="markdownIt-Anchor" href="#tcpip-网络模型有哪几层"></a> TCP/IP 网络模型有哪几层</h2>
<h3 id="应用层"><a class="markdownIt-Anchor" href="#应用层"></a> 应用层</h3>
<ol>
<li>
<p>而且应用层是工作在操作系统中的用户态，传输层及以下则工作在内核态。</p>
<p>应用层只需要专注于为用户提供应用功能，比如 HTTP、FTP、Telnet、DNS、SMTP等。</p>
</li>
</ol>
<h3 id="传输层"><a class="markdownIt-Anchor" href="#传输层"></a> 传输层</h3>
<ol>
<li>
<p>传输层为应用层服务，有两个传输协议TCP（传输控制协议）和UDP（用户数据包协议）、</p>
</li>
<li>
<p>UDP 也可以实现可靠传输，把 TCP 的特性在应用层上实现就可以，但这也不容易。流量控制、超时重传、拥塞控制</p>
</li>
<li>
<p>传输层的数据包大小超过 MSS（TCP 最大报文段长度） ，就要将数据包分块。</p>
</li>
</ol>
<h3 id="网络层"><a class="markdownIt-Anchor" href="#网络层"></a> 网络层</h3>
<ol>
<li>帮助实现应用到应用的通信，而实际的传输功能就交给下一层，也就是网络层。</li>
<li>网络层最常使用的是 IP 协议，IP 协议会将传输层的报文作为数据部分，再加上 IP 包头组装成 IP 报文，如果 IP 报文大小超过 MTU（以太网中一般为 1500 字节）会再次分片。</li>
</ol>
<p><img src="/img/%E8%AE%A1%E7%BD%91%E5%85%AB%E8%82%A1/image-20250310084731363.png" alt="image-20250310084731363"></p>
<ol start="3">
<li>
<p>IP 地址分成两种意义： 一个是网络号，负责标识该 IP 地址是属于哪个「子网」的； 一个是主机号，负责标识同一「子网」下的不同主机； 怎么分的呢？这需要配合子网掩码才能算出 IP 地址 的网络号和主机号。</p>
</li>
<li>
<p>寻址的过程中，先匹配到相同的网络号（表示要找到同一个子网），才会去找对应的主机。 除了寻址能力， IP 协议还有另一个重要的能力就是路由。</p>
<p><img src="/img/%E8%AE%A1%E7%BD%91%E5%85%AB%E8%82%A1/image-20250310084943962.png" alt="image-20250310084943962"></p>
</li>
</ol>
<h3 id="网络接口层"><a class="markdownIt-Anchor" href="#网络接口层"></a> 网络接口层</h3>
<ol>
<li>
<p>生成了 IP 头部之后，接下来要交给网络接口层（Link Layer）在 IP 头部的前面加上 MAC 头部，并封装成数据帧（Data frame）发送到网络上。</p>
</li>
<li>
<p>MAC 头部是以太网使用的头部，它包含了接收方和发送方的 MAC 地址等信息，我们可以通过 ARP 协议获取对方的 MAC 地址。 所以说，网络接口层主要为网络层提供「链路级别」传输的服务，负责在以太网、WiFi 这样的底层网络上发送原始数据包，工作在网卡这个层次，使用 MAC 地址来标识网络上的设备。</p>
</li>
</ol>
<h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3>
<p><img src="/img/%E8%AE%A1%E7%BD%91%E5%85%AB%E8%82%A1/image-20250310085312456.png" alt="image-20250310085312456"></p>
<h2 id="键入网址到网页显示期间发生了什么"><a class="markdownIt-Anchor" href="#键入网址到网页显示期间发生了什么"></a> 键入网址到网页显示，期间发生了什么？</h2>
<p><img src="/img/%E8%AE%A1%E7%BD%91%E5%85%AB%E8%82%A1/image-20250310085539528.png" alt="image-20250310085539528"></p>
<h4 id="浏览器解析url生成http请求消息"><a class="markdownIt-Anchor" href="#浏览器解析url生成http请求消息"></a> <strong>浏览器解析URL</strong>，生成HTTP请求消息。</h4>
<h4 id="浏览器把域名发给dns得到对应ip地址"><a class="markdownIt-Anchor" href="#浏览器把域名发给dns得到对应ip地址"></a> 浏览器把域名发给DNS，<strong>得到对应IP地址</strong>。</h4>
<p><img src="/img/%E8%AE%A1%E7%BD%91%E5%85%AB%E8%82%A1/image-20250310085923698.png" alt="image-20250310085923698"></p>
<p>当然中间有缓存，浏览器缓存，操作系统缓存，hosts文件，之后再去找本地DNS</p>
<h4 id="把http的传输工作交给操作系统的协议栈"><a class="markdownIt-Anchor" href="#把http的传输工作交给操作系统的协议栈"></a> 把HTTP的传输工作交给操作系统的协议栈。</h4>
<p><img src="/img/%E8%AE%A1%E7%BD%91%E5%85%AB%E8%82%A1/image-20250310090248139.png" alt="image-20250310090248139"></p>
<h4 id="可靠传输tcp"><a class="markdownIt-Anchor" href="#可靠传输tcp"></a> 可靠传输TCP</h4>
<p><img src="/img/%E8%AE%A1%E7%BD%91%E5%85%AB%E8%82%A1/image-20250310090404439.png" alt="image-20250310090404439"></p>
<p><img src="/img/%E8%AE%A1%E7%BD%91%E5%85%AB%E8%82%A1/image-20250310090752204.png" alt="image-20250310090752204"></p>
<ul>
<li>
<p><strong>TCP 三握手</strong></p>
<p><img src="/img/%E8%AE%A1%E7%BD%91%E5%85%AB%E8%82%A1/image-20250310091020905.png" alt="image-20250310091020905"></p>
<p>​	保证有接受和发送的能力，因为在三次握手中，两方都进行了一收一发。<strong>第三次握手中可以发送信息了。</strong></p>
</li>
</ul>
<p><img src="/img/%E8%AE%A1%E7%BD%91%E5%85%AB%E8%82%A1/image-20250310092812353.png" alt="image-20250310092812353"></p>
<p>MTU：一个网络包的最大长度</p>
<p>MSS：除去IP和TCP头部之后，一个网络包所能容纳的TCP数据的最大长度</p>
<h4 id="远程定位ip"><a class="markdownIt-Anchor" href="#远程定位ip"></a> 远程定位IP</h4>
<p>在 IP 协议里面需要有源地址 IP 和 目标地址 IP： 源地址IP，即是客户端输出的 IP 地址； 目标地址，即通过 DNS 域名解析得到的 Web 服务器 IP。 因为 HTTP 是经过 TCP 传输的，所以在 IP 包头的协议号，要填写为 06（十六进制），表示协议为 TCP。</p>
<p><img src="/img/%E8%AE%A1%E7%BD%91%E5%85%AB%E8%82%A1/image-20250310093625131.png" alt="image-20250310093625131"></p>
<h4 id="两点传输mac"><a class="markdownIt-Anchor" href="#两点传输mac"></a> 两点传输MAC</h4>
<p>生成了 IP 头部之后，接下来网络包还需要在 IP 头部的前面加上 <strong>MAC 头部</strong>。</p>
<p><img src="/img/%E8%AE%A1%E7%BD%91%E5%85%AB%E8%82%A1/image-20250310093803506.png" alt="image-20250310093803506"></p>
<p>接受方的MAC地址，就在自己的ROM中。</p>
<p>发送方的MAC地址，则需要使用ARP协议。先问操作系统缓存IP-MAC的映射是否存在，不在，则去广播询问整个以太网/子网。</p>
<p><img src="/img/%E8%AE%A1%E7%BD%91%E5%85%AB%E8%82%A1/21.jpg" alt="MAC 层报文"></p>
<h4 id="出口-网卡"><a class="markdownIt-Anchor" href="#出口-网卡"></a> 出口-网卡</h4>
<p><img src="/img/%E8%AE%A1%E7%BD%91%E5%85%AB%E8%82%A1/image-20250310094601768.png" alt="image-20250310094601768"></p>
<h4 id="交换机"><a class="markdownIt-Anchor" href="#交换机"></a> 交换机</h4>
<p>​	将网络包不做任何修改的原样发送到目的地。成为二层网络设备，本身不具有一般MAC地址和IP地址。只是进行转发，保留一个MAC地址到端口的映射表，如MAC在表中，则转发，否则广播并且计入表中。</p>
<h4 id="路由器"><a class="markdownIt-Anchor" href="#路由器"></a> 路由器</h4>
<p>​	网络包经过交换机之后，现在到达了路由器，并在此被转发到下一个路由器或目标设备。</p>
<p>​	这一步转发的工作原理和交换机类似，也是通过查表判断包转发的目标。 不过在具体的操作过程上，路由器和交换机是有区别的。</p>
<p>​	因为路由器是基于 IP 设计的，俗称三层网络设备，<strong>路由器的各个端口都具有 MAC 地址和 IP 地址</strong>； 而<strong>交换机是基于以太网设计</strong>的，俗称二层网络设备，交换机的端口不具有 MAC 地址。</p>
<p>​	<img src="/img/%E8%AE%A1%E7%BD%91%E5%85%AB%E8%82%A1/image-20250310100205359.png" alt="image-20250310100205359"></p>
<p><strong>在网络包传输的过程中，源 IP 和目标 IP 始终是不会变的，一直变化的是 MAC 地址，因为需要 MAC 地址在以太网内进行两个设备之间的包传输。</strong></p>
<h4 id="服务器与客户端"><a class="markdownIt-Anchor" href="#服务器与客户端"></a> 服务器与客户端</h4>
<p>​	数据包抵达服务器后，服务器会先扒开数据包的 MAC 头部，查看是否和服务器自己的 MAC 地址符合，符合就将包收起来。</p>
<p>​	接着继续扒开数据包的 IP 头，发现 IP 地址符合，根据 IP 头中协议项，知道自己上层是 TCP 协议。</p>
<p>​	 于是，扒开 TCP 的头，里面有序列号，需要看一看这个序列包是不是我想要的，如果是就放入缓存中然后返回一个 ACK，如果不是就丢弃。TCP头部里面还有端口号， HTTP 的服务器正在监听这个端口号。</p>
<p>​	于是，服务器自然就知道是 HTTP 进程想要这个包，于是就将包发给 HTTP 进程。 服务器的 HTTP 进程看到，原来这个请求是要访问一个页面，于是就把这个网页封装在 HTTP 响应报文里。</p>
<p>​	HTTP 响应报文也需要穿上 TCP、IP、MAC 头部，不过这次是源地址是服务器 IP 地址，目的地址是客户端 IP 地址。</p>
<h4 id="tcp关闭时四次挥手"><a class="markdownIt-Anchor" href="#tcp关闭时四次挥手"></a> TCP关闭时四次挥手</h4>
<p>​	数据传输完毕后，双方都可释放连接。最开始的时候，客户端和服务器都是处于ESTABLISHED状态，然后客户端主动关闭，服务器被动关闭。</p>
<p>​	<strong>第一次挥手</strong> 客户端发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，<strong>客户端进入FIN-WAIT-1（终止等待1）状态</strong></p>
<p>​	<strong>第二次挥手</strong> 服务器端接收到连接释放报文后，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，<strong>服务端就进入了CLOSE-WAIT 关闭等待状态</strong></p>
<p>​	<strong>第三次挥手</strong> 客户端接收到服务器端的确认请求后，<strong>客户端就会进入FIN-WAIT-2（终止等待2）状态</strong>，等待服务器发送连接释放报文，服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，<strong>服务器就进入了LAST-ACK（最后确认）状态</strong>，等待客户端的确认。</p>
<p>​	<strong>第四次挥手</strong> 客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，<strong>客户端就进入了TIME-WAIT（时间等待）状态</strong>，但此时TCP连接还未终止，必须要<strong>经过2MSL</strong>后（最长报文寿命），当客户端撤销相应的TCB后，<strong>客户端才会进入CLOSED关闭状态</strong>，服务器端接收到确认报文后，会<strong>立即进入CLOSED关闭状态</strong>，到这里TCP连接就断开了，四次挥手完成</p>
<p><strong>为什么客户端要等待2MSL？</strong><br>
主要原因是为了保证客户端发送那个的第一个ACK报文能到到服务器，因为这个ACK报文可能丢失，并且2MSL是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃，这样新的连接中不会出现旧连接的请求报文。</p>
<h2 id="linux系统是如何收发网络包的"><a class="markdownIt-Anchor" href="#linux系统是如何收发网络包的"></a> Linux系统是如何收发网络包的？</h2>
<p>OSI模型：</p>
<ul>
<li>
<p>应用层，负责给应用程序提供统一的接口；</p>
</li>
<li>
<p>表示层，负责把数据转换成兼容另一个系统能识别的格式；</p>
</li>
<li>
<p>会话层，负责建立、管理和终止表示层实体之间的通信会话；</p>
</li>
<li>
<p>传输层，负责端到端的数据传输；</p>
</li>
<li>
<p>网络层，负责数据的路由、转发、分片；</p>
</li>
<li>
<p>数据链路层，负责数据的封帧和差错检测，以及 MAC 寻址；</p>
</li>
<li>
<p>物理层，负责在物理网络中传输数据帧；</p>
</li>
</ul>
<p>TCP/IP 网络模型：</p>
<ul>
<li>应用层，负责向用户提供一组应用程序，比如 HTTP、DNS、FTP 等;</li>
<li>传输层，负责端到端的通信，比如 TCP、UDP 等；</li>
<li>网络层，负责网络包的封装、分片、路由、转发，比如 IP、ICMP 等；</li>
<li>网络接口层，负责网络包在物理网络中的传输，比如网络包的封帧、 MAC 寻址、差错检测，以及通过网卡传输网络帧等；</li>
</ul>
<p><img src="/img/%E8%AE%A1%E7%BD%91%E5%85%AB%E8%82%A1/image-20250310105255876.png" alt="image-20250310105255876"></p>
<h3 id="linux网络协议栈"><a class="markdownIt-Anchor" href="#linux网络协议栈"></a> Linux网络协议栈</h3>
<p><strong>Linux使用的是TCP/IP的模型。</strong></p>
<p><img src="/img/%E8%AE%A1%E7%BD%91%E5%85%AB%E8%82%A1/%E5%8D%8F%E8%AE%AE%E6%A0%88.png" alt="img"></p>
<h3 id="linux接受网络包流程"><a class="markdownIt-Anchor" href="#linux接受网络包流程"></a> Linux接受网络包流程</h3>
<p>​	网卡是一个硬件，负责收发网络包，当网卡接受到一个网络包之后，用DMA写入内存，然后告知操作系统网络包已达。</p>
<p>​	告知OS的方法：</p>
<ol>
<li>
<p>中断。但是频繁中断会导致性能开销。</p>
</li>
<li>
<p>使用轮询poll。</p>
<p>CPU收到硬件中断请求之后，调用已经注册的硬件中断函数。</p>
</li>
</ol>
<p>​	硬件中断函数先暂时屏蔽中断，然后调用软中断函数，之后恢复刚才屏蔽的中断。</p>
<p><img src="/img/%E8%AE%A1%E7%BD%91%E5%85%AB%E8%82%A1/image-20250310111522770.png" alt="image-20250310111522770"></p>
<p><strong>Linux接收网络包流程：</strong></p>
<ol>
<li>网络接口层 检查和去掉帧头和帧尾</li>
<li>网络层，取出IP包，判断是发送还是接收。如果是接收，会看看TCP还是UDP，然后去掉IP头和IP尾。</li>
<li>传输层取出TCP或者UDP的头，根据 [源IP，源端口，目标IP，目标端口]作为表示，找出socket，放在socket接收缓冲区。</li>
<li>应用层程序调用socket接口，把内核的socket接收缓冲区的数据copy到应用层的缓冲区，并唤醒用户进程。</li>
<li>完成接收。</li>
</ol>
<p>​	<img src="/img/%E8%AE%A1%E7%BD%91%E5%85%AB%E8%82%A1/%E6%94%B6%E5%8F%91%E6%B5%81%E7%A8%8B.png" alt="img"></p>
<p><strong>Linux发送网络包流程</strong></p>
<p>​	发送网络包的流程和接收流程相反。</p>
<p>​	首先，应用程序会<strong>调用 Socket 发送数据包的接口，由于这个是系统调用</strong>，所以会从用户态陷入到内核态中的 Socket 层，内核会申请一个内核态的 sk_buff 内存，将用户待发送的数据拷贝到 sk_buff 内存，并将其加入到发送缓冲区。</p>
<p>​	接下来，网络协议栈从 Socket 发送缓冲区中<strong>取出 sk_buff，并按照 TCP/IP 协议栈从上到下逐层处理</strong> 。如果使用的是 TCP 传输协议发送数据，那么先拷贝一个新的 sk_buff 副本 ，这是因为 sk_buff 后续在调用网络层，最后到达网卡发送完成的时候，这个 sk_buff 会被释放掉。而 TCP 协议是支持丢失重传的，在<strong>收到对方的 ACK 之前，这个 sk_buff 不能被删除</strong>。所以内核的做法就是每次调用网卡发送的时候，实际上传递出去的是 sk_buff 的一个拷贝，等收到 ACK 再真正删除。</p>
<p>​	接着，对 sk_buff 填充 TCP 头。这里提一下，sk_buff 可以表示各个层的数据包，<strong>在应用层数据包叫 data，在 TCP 层我们称为 segment，在 IP 层我们叫 packet，在数据链路层称为 frame。</strong> 你可能会好奇，为什么全部数据包只用一个结构体来描述呢？协议栈采用的是分层结构，上层向下层传递数据时需要增加包头，下层向上层数据时又需要去掉包头，如果每一层都用一个结构体，那在层之间传递数据的时候，就要发生多次拷贝，这将大大降低 CPU 效率。</p>
<p>于是，为了在层级之间传递数据时，不发生拷贝，只用 sk_buff 一个结构体来描述所有的网络包，那它是如何做到的呢？是通过调整 sk_buff 中 data 的指针，比如： 当接收报文时，从网卡驱动开始，通过协议栈层层往上传送数据报，通过增加 skb-&gt;data 的值，来逐步剥离协议首部。 当要发送报文时，创建 sk_buff 结构体，<strong>数据缓存区的头部预留足够的空间，用来填充各层首部</strong>，在经过各下层协议时，通过减少 skb-&gt;data 的值来增加协议首部。</p>
<p><img src="/img/%E8%AE%A1%E7%BD%91%E5%85%AB%E8%82%A1/sk_buff.jpg" alt="img"></p>
<p>​	至此，传输层的工作也就都完成了。</p>
<p>​	然后交给网络层，在网络层里会做这些工作：选取路由（确认下一跳的 IP）、填充 IP 头、netfilter 过滤、对超过 MTU 大小的数据包进行分片。处理完这些工作后会交给网络接口层处理。</p>
<p>​	网络接口层会通过 ARP 协议获得下一跳的 MAC 地址，然后对 sk_buff 填充帧头和帧尾，接着将 sk_buff 放到网卡的发送队列中。</p>
<p>​	这一些工作准备好后，会触发<strong>软中断 告诉网卡驱动程序</strong>，这里有新的网络包需要发送，驱动程序会从发送队列中读取 sk_buff，将这个 sk_buff 挂到 RingBuffer 中，接着将 sk_buff 数据映射到网卡可访问的内存 DMA 区域，最后触发真实的发送。</p>
<p>​	当数据发送完成以后，其实工作并没有结束，因为内存还没有清理。当发送完成的时候，网卡设备会触发一个硬中断来释放内存，主要是释放 sk_buff 内存和清理 RingBuffer 内存。</p>
<p>​	最后，当收到这个 TCP 报文的 ACK 应答时，传输层就会释放原始的 sk_buff 。</p>
<p><strong>当发送网络数据时，涉及几次数据copy？</strong></p>
<ol>
<li>应用层把数据发给内核的sk_buff内存，加入缓冲区。第一次。</li>
<li>使用TCP时，传输层到网络层会copy，只有收到ACK之后，才会释放。第二次。</li>
<li>IP层发现sk_buff大于MTU进行切片时。申请额外sk_buff。第三次</li>
</ol>
<h1 id="http篇"><a class="markdownIt-Anchor" href="#http篇"></a> HTTP篇</h1>
<p><img src="/img/%E8%AE%A1%E7%BD%91%E5%85%AB%E8%82%A1/6b9bfd38d2684b3f9843ebabf8771212.png" alt="提纲"></p>
<h2 id="http-基本概念"><a class="markdownIt-Anchor" href="#http-基本概念"></a> HTTP 基本概念</h2>
<p><strong>HTTP即超文本传输协议，HyperText Transfer Protocol</strong></p>
<ul>
<li>
<p><strong>协议</strong>：它使用计算机能够理解的语言确立了一种计算机之间交流通信的规范（两个以上的参与者），以及相关的各种控制和错误处理方式（行为约定和规范）。</p>
</li>
<li>
<p><strong>传输</strong>： 是一个在计算机世界里专门用来在两点之间传输数据的约定和规范。</p>
</li>
<li>
<p><strong>超文本</strong>： 文本就是简单的字符，超文本就是超越了字符，包括图片、视频、压缩包等等二进制文件。其中超链接可以从一个超文本中跳转到另一个超文本。</p>
<p>​	HTTP 是一个在计算机世界里专门在「两点」之间「传输」文字、图片、音频、视频等「超文本」数据的「约定和规范」。</p>
</li>
</ul>
<p>
    <b>
        </b></p><center><b>HTTP常见状态码</b></center><b>
    </b>
<p></p>
<p><img src="/img/%E8%AE%A1%E7%BD%91%E5%85%AB%E8%82%A1/6-%E4%BA%94%E5%A4%A7%E7%B1%BBHTTP%E7%8A%B6%E6%80%81%E7%A0%81.png" alt=" 五大类 HTTP 状态码 "></p>
<h4 id="http常见字段"><a class="markdownIt-Anchor" href="#http常见字段"></a> HTTP常见字段</h4>
<ul>
<li>Host字段，指定主机，也就制定了IP：Port对。</li>
<li>Content-Length字段，服务器返回数据时，表明数据长度。</li>
<li>Connection字段，常用于客户端要求服务器使用 HTTP长连接 机制。其特点是只要一段没有明确提出断开连接，就一直连接。</li>
<li>Content-Type字段，用于服务器回应时，告诉客户端，本次数据的格式。</li>
<li>Accept，客户端请求时，可以用该字段声明自己可以接受的格式。</li>
<li>Content-Encoding字段，服务器返回时表明数据的压缩方法。</li>
<li>Accept-Encoding字段，说明客户端可以接受的压缩方法。</li>
</ul>
<h2 id="get-与-post"><a class="markdownIt-Anchor" href="#get-与-post"></a> GET 与 POST</h2>
<h4 id="get-与-post-的区别"><a class="markdownIt-Anchor" href="#get-与-post-的区别"></a> GET 与 POST 的区别</h4>
<ul>
<li><strong>GET指获取服务器的指定资源</strong>。其请求参数一般在URL中，URL只支持ASCII，HTTP不对URL长度做限制。</li>
<li><strong>POST指对服务器的指定资源做处理</strong>。其请求具体内容在body中，不出现在URL。</li>
<li>浏览器不会对POST缓存，但是会对GET缓存。这是基于RFC语义的。</li>
<li>GET是安全且幂等的。</li>
<li>POST是不安全且不幂等的。</li>
<li>不过RFC规定归规定，实际上程序员不一定完全符合。</li>
<li>HTTP未对body以及URL查询参数做限制，任何操作都可以有这两个东西。</li>
</ul>
<h2 id="http缓存技术"><a class="markdownIt-Anchor" href="#http缓存技术"></a> HTTP缓存技术</h2>
<h4 id="http缓存的实现"><a class="markdownIt-Anchor" href="#http缓存的实现"></a> HTTP缓存的实现</h4>
<ul>
<li>避免发送HTTP请求的方法就是缓存技术。</li>
<li>实现方式有两种，强制缓存与协商缓存。</li>
<li>缓存的识别与使用一般在头部。</li>
</ul>
<h4 id="强制缓存"><a class="markdownIt-Anchor" href="#强制缓存"></a> 强制缓存</h4>
<p>​	强缓存指的是只要浏览器判断缓存没有过期，则直接使用浏览器的本地缓存，决定是否使用缓存的主动性在于浏览器这边。</p>
<p>​	强缓存是利用下面这两个 HTTP 响应头部（Response Header）字段实现的，它们都用来表示资源在客户端缓存的有效期：</p>
<p>​	<strong>Cache-Control， 是一个相对时间；</strong></p>
<p>​	Expires，是一个绝对时间；</p>
<p>​	如果 HTTP 响应头部同时有 Cache-Control 和 Expires 字段的话，Cache-Control 的优先级高于 Expires 。</p>
<h4 id="协商缓存"><a class="markdownIt-Anchor" href="#协商缓存"></a> 协商缓存</h4>
<p><img src="/img/%E8%AE%A1%E7%BD%91%E5%85%AB%E8%82%A1/%E7%BC%93%E5%AD%98etag.png" alt="img"></p>
<p>
    <b>
    	</b></p><center><b>上面就是一个协商缓存的过程，协商缓存就是与服务端协商之后，通过协商结果来判断是否使用本地缓存</b></center><b>
    </b>
<p></p>
<p>协商缓存可以有两个方法实现：</p>
<p>​	第一种，请求头部中的 If-Modified-Since 字段与响应头部中的 Last-Modified 字段实现，这两个字段的意思是：</p>
<p>​	响应头部中的 Last-Modified：标示这个响应资源的<strong>最后修改时间</strong>；</p>
<p>​	请求头部中的 If-Modified-Since：当资源过期了，发现响应头中具有 Last-Modified 声明，则再次发起请求的时候带上 Last-Modified 的时间，服务器收到请求后发现有 <strong>If-Modified-Since 则与被请求资源的最后修改时间进行对比（Last-Modified）</strong>，如果最后修改时间较新（大），说明资源又被改过，则返回最新资源，HTTP 200 OK；如果最后修改时间较旧（小），说明资源无新修改，响应 HTTP 304 走缓存。</p>
<p>​	第二种：请求头部中的 If-None-Match 字段与响应头部中的 ETag 字段，这两个字段的意思是：</p>
<p>​	响应头部中 Etag：<strong>唯一标识</strong>响应资源；</p>
<p>​	请求头部中的 If-None-Match：当资源过期时，浏览器发现响应头里有 Etag，则再次向服务器发起请求时，会将<strong>请求头 If-None-Match 值设置为 Etag 的值。服务器收到请求后进行比对</strong>，如果资源没有变化返回 304，如果资源变化了返回 200。</p>
<ul>
<li>协商缓存需要配合强制缓存中 cache-control 使用。</li>
<li>当同时有 ETag 和 Last-Modified 的时候，优先 ETag，因为 ETag 可以保证一定能检测出文件的修改。</li>
</ul>
<p><img src="/img/%E8%AE%A1%E7%BD%91%E5%85%AB%E8%82%A1/http%E7%BC%93%E5%AD%98.png" alt="img"></p>
<h2 id="http特性"><a class="markdownIt-Anchor" href="#http特性"></a> HTTP特性</h2>
<h4 id="http优点"><a class="markdownIt-Anchor" href="#http优点"></a> HTTP优点：</h4>
<ol>
<li>简单：报文为header+body，头部为key-value</li>
<li>灵活和易于拓展：各种请求方法都不没固定死，允许开发人员自定义和扩充。</li>
<li>应用广泛和跨平台。</li>
</ol>
<h4 id="http缺点"><a class="markdownIt-Anchor" href="#http缺点"></a> HTTP缺点：</h4>
<ol>
<li>
<p>无状态：好处是轻便好用，但当进行有关联性的操作时很麻烦。</p>
<p>一种方法是使用Cookie</p>
<p><img src="/img/%E8%AE%A1%E7%BD%91%E5%85%AB%E8%82%A1/14-cookie%E6%8A%80%E6%9C%AF.png" alt="Cookie 技术"></p>
</li>
<li>
<p>明文传输：网上裸奔，不安全。可以通过HTTPS解决。</p>
</li>
</ol>
<h4 id="http11性能"><a class="markdownIt-Anchor" href="#http11性能"></a> HTTP/1.1性能</h4>
<p>HTTP是基于TCP/IP的，使用请求-应答模式。</p>
<ol>
<li>长连接：避免每次发送请求都建立一次TCP链接</li>
<li>管道网络传输：基于长连接，可以多个请求而无需等待前一个请求的完成。</li>
<li>队头阻塞：当顺序发送的请求序列中的一个请求因为某种原因被阻塞时，在后面排队的<strong>所有请求也一同被阻塞</strong>了，会招致客户端一直请求不到数据，这也就是「队头阻塞」，好比上班的路上塞车。</li>
</ol>
<h2 id="http与https"><a class="markdownIt-Anchor" href="#http与https"></a> HTTP与HTTPS</h2>
<h4 id="http与https区别"><a class="markdownIt-Anchor" href="#http与https区别"></a> HTTP与HTTPS区别</h4>
<ul>
<li>
<p>HTTP 是超文本传输协议，信息是明文传输，存在安全风险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在 <strong>TCP 和 HTTP 网络层之间加入了 SSL/TLS 安全协议，使得报文能够加密传输</strong>。</p>
</li>
<li>
<p>HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 在 TCP 三次握手之后，还需<strong>进行 SSL/TLS 的握手过程，才可进入加密报文传输。</strong></p>
</li>
<li>
<p>两者的默认端口不一样，HTTP 默认端口号是 80，HTTPS 默认端口号是 443。</p>
</li>
<li>
<p>HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。</p>
</li>
</ul>
<h4 id="https解决的http问题"><a class="markdownIt-Anchor" href="#https解决的http问题"></a> HTTPS解决的HTTP问题</h4>
<ul>
<li>信息加密：混合加密（非对称加密 + 对称加密）的方式实现信息的机密性，解决了窃听的风险。<strong>对称加密可能会破解，但是可以用非对称加密加密数字签名。</strong></li>
<li>校验机制：摘要算法的方式来实现完整性，它能够为数据生成独一无二的「指纹」，指纹用于校验数据的完整性，解决了篡改的风险。</li>
<li>身份证书：将服务器公钥放入到数字证书中，解决了冒充的风险</li>
</ul>
<p><img src="/img/%E8%AE%A1%E7%BD%91%E5%85%AB%E8%82%A1/22-%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.jpeg" alt="数子证书工作流程"></p>
<h4 id="https-是如何建立连接的"><a class="markdownIt-Anchor" href="#https-是如何建立连接的"></a> HTTPS 是如何建立连接的？</h4>
<p>SSL/TLS 协议基本流程：</p>
<ul>
<li>客户端向服务器索要并验证服务器的公钥。</li>
<li>双方协商生产「会话秘钥」。</li>
<li>双方采用「会话秘钥」进行加密通信。</li>
</ul>
<p>前两步也就是 SSL/TLS 的建立过程，也就是 TLS 握手阶段。</p>
<p>TLS的握手，涉及四次通信。不同密钥交换算法，握手流程也不一样。</p>
<p><img src="/img/%E8%AE%A1%E7%BD%91%E5%85%AB%E8%82%A1/23-HTTPS%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.jpeg" alt="HTTPS 连接建立过程"></p>
<p>TLS协议流程：</p>
<ol>
<li>ClientHello，发送：
<ol>
<li>TLS版本，</li>
<li>client的随机数 client random，</li>
<li>client支持的密码套件列表（比如 ： RSA加密算法）</li>
</ol>
</li>
<li>ServerHello：
<ol>
<li>确认版本，如不支持，则关闭</li>
<li>server生成随机数 server random</li>
<li>确认密码套件列表</li>
<li>服务器的数字证书</li>
</ol>
</li>
<li>客户端回应：
<ol>
<li>再生成一个随机数 pre-master key</li>
<li>加密通信算法改变通知，表示随后的信息会加密</li>
<li>客户端通知握手结束</li>
</ol>
</li>
</ol>
<p><strong>这个时候服务器和客户端有了三个随机数，接下来就用双方协商的加密锁算法，生成本次通信密钥</strong></p>
<ol start="4">
<li>服务器最后回应
<ol>
<li>通知握手结束</li>
</ol>
</li>
</ol>
<h4 id="https的应用程序如何保证完整性"><a class="markdownIt-Anchor" href="#https的应用程序如何保证完整性"></a> HTTPS的应用程序如何保证完整性。</h4>
<p><img src="/img/%E8%AE%A1%E7%BD%91%E5%85%AB%E8%82%A1/%E8%AE%B0%E5%BD%95%E5%8D%8F%E8%AE%AE.png" alt="img"></p>
<p>数据经过切片、压缩和加密。转交给TCP层传输。</p>
<p>一个问题：HTTPS是安全可靠的吗？</p>
<p>如果有中间人怎么办。 答案是确实安全可靠。</p>
<p><img src="/img/%E8%AE%A1%E7%BD%91%E5%85%AB%E8%82%A1/https%E4%B8%AD%E9%97%B4%E4%BA%BA.drawio.png" alt="img"></p>
<h4 id="http11-http2-http3演变"><a class="markdownIt-Anchor" href="#http11-http2-http3演变"></a> HTTP/1.1、HTTP/2、HTTP/3演变</h4>
<p><strong>HTTP/2</strong>（相比HTTP/1.1）：</p>
<ol>
<li>
<p>头部压缩</p>
</li>
<li>
<p>完全二进制格式</p>
</li>
<li>
<p>多个流并发传输：用 stream id 来表示每个流，用奇偶表示客户端与服务端。</p>
<p><img src="/img/%E8%AE%A1%E7%BD%91%E5%85%AB%E8%82%A1/stream.png" alt="img"></p>
</li>
<li>
<p>服务器主动推送资源</p>
</li>
<li>
<p>仍然存在队头阻塞</p>
</li>
</ol>
<p><strong>HTTP/3</strong>：</p>
<ol>
<li>
<p>为了解决队头阻塞，把 TCP 换成了 UDP，用基于 UDP 实现的 QUIC（Quick UDP Internet Connections）协议，可以实现类似的可靠性传输。</p>
<p>QUIC：</p>
<ol>
<li>
<p>无队头阻塞：类似多路复用，可在一个连接上并发传输多个stream，每个stream都可以认为是一个HTTP请求。当丢包时，只会一个流受到阻塞。</p>
<p><img src="/img/%E8%AE%A1%E7%BD%91%E5%85%AB%E8%82%A1/quic%E6%97%A0%E9%98%BB%E5%A1%9E.jpeg" alt="img"></p>
</li>
<li>
<p>更快连接建立：因为内核实现的传输层和openssl实现的表示层难以合并在一起，所以TLS在TCP之后。</p>
<p>QUIC可以用一个RTT完成连接建立和密钥协商、</p>
</li>
<li>
<p>连接迁移：没有使用四元组的方式绑定连接，而是用连接ID标记。迁移时无需重新连接。</p>
<p>QUIC 是一个在 UDP 之上的伪 TCP + TLS + HTTP/2 的多路复用的协议。</p>
</li>
</ol>
</li>
</ol>
<h2 id="http11优化"><a class="markdownIt-Anchor" href="#http11优化"></a> HTTP/1.1优化</h2>
<p><img src="/img/%E8%AE%A1%E7%BD%91%E5%85%AB%E8%82%A1/%E4%BC%98%E5%8C%96http1.1%E6%8F%90%E7%BA%B2.png" alt="img"></p>
<ol>
<li>减少重定向请求次数：让代理服务器得知即可，而无需让客户端得知。</li>
<li>合并请求：把多个小请求合并成一个大请求。</li>
<li>延迟发送请求：等用到了在解析URL。</li>
</ol>
<h2 id="https-rsa-握手解析"><a class="markdownIt-Anchor" href="#https-rsa-握手解析"></a> HTTPS RSA 握手解析</h2>
<p><img src="/img/%E8%AE%A1%E7%BD%91%E5%85%AB%E8%82%A1/https%E6%8F%90%E7%BA%B2.png" alt="img"></p>
<p>RSA算法不支持前向保密。</p>
<h2 id="https-ecdhe-握手解析"><a class="markdownIt-Anchor" href="#https-ecdhe-握手解析"></a> HTTPS ECDHE 握手解析</h2>
<p><img src="/img/%E8%AE%A1%E7%BD%91%E5%85%AB%E8%82%A1/ecdhe%E6%8F%90%E7%BA%B2.png" alt="img"></p>
<p>ECDHE支持前向保密，每次生成一个临时的密钥，通过椭圆曲线加速计算。</p>
<h2 id="https优化"><a class="markdownIt-Anchor" href="#https优化"></a> HTTPS优化</h2>
<p><img src="/img/%E8%AE%A1%E7%BD%91%E5%85%AB%E8%82%A1/%E4%BC%98%E5%8C%96https%E6%8F%90%E7%BA%B2.png" alt="img"></p>
<ol>
<li>
<p>会话复用。</p>
<ul>
<li>
<p>Session ID</p>
<p>客户端和服务器首次 TLS 握手连接后，双方会在内存缓存会话密钥，并用唯一的 Session ID 来标识，Session ID 和会话密钥相当于 key-value 的关系。</p>
<p>当客户端再次连接时，hello 消息里会带上 Session ID，服务器收到后就会从内存找，如果找到就直接用该会话密钥恢复会话状态，跳过其余的过程，只用一个消息往返就可以建立安全通信。当然为了安全性，内存中的会话密钥会定期失效。</p>
</li>
</ul>
<p>问题：</p>
<p>​	不一定命中，因为服务器是负载均衡的。</p>
<p>​	每一个客户端维护密钥，内存压力大。</p>
<ul>
<li>
<p>Session Ticket</p>
<p>把缓存的工作交给客户端。再次连接的时候让客户端发送Ticket即可。</p>
<p>问题在于可能会出现重放攻击。需要为密钥设定一个合理的过期时间。</p>
</li>
</ul>
<h2 id="http2优点"><a class="markdownIt-Anchor" href="#http2优点"></a> HTTP/2优点</h2>
<p><img src="/img/%E8%AE%A1%E7%BD%91%E5%85%AB%E8%82%A1/image-20240105142731563.png" alt="img"></p>
<ol>
<li>兼容HTTP/1.1 没有引入新的协议名，只在应用层做了改变。</li>
</ol>
</li>
</ol>
<h2 id="http3"><a class="markdownIt-Anchor" href="#http3"></a> HTTP/3</h2>
<p><img src="/img/%E8%AE%A1%E7%BD%91%E5%85%AB%E8%82%A1/image-20240105144308801.png" alt="image-20240105144308801"></p>
<h2 id="有了http为什么还有rpc"><a class="markdownIt-Anchor" href="#有了http为什么还有rpc"></a> 有了HTTP，为什么还有RPC？</h2>
<p><img src="/img/%E8%AE%A1%E7%BD%91%E5%85%AB%E8%82%A1/f4cef7331cabcfe56d9d6434f7ef907f.png" alt="HTTP 原理"></p>
<p>
    </p><center>上面为HTTP</center>
<p></p>
<p><img src="/img/%E8%AE%A1%E7%BD%91%E5%85%AB%E8%82%A1/12244fb0b19b2e61755fcab799198f68.png" alt="RPC 原理"></p>
<p>
    </p><center>上面为RPC</center>
<p></p>
<h2 id="为什么有了http还有websocket"><a class="markdownIt-Anchor" href="#为什么有了http还有websocket"></a> 为什么有了HTTP，还有WebSocket？</h2>
<ol>
<li>
<p>HTTP是客户端向服务器发起请求，而不是服务器向客户端发东西，因此有些时候不方便，比如玩游戏。</p>
</li>
<li>
<p>HTTP把一个全双工的TCP改成了半双工，因为设计之初就没考虑玩游戏这种情况。</p>
</li>
<li>
<p>WebSocket和Socket没一点关系</p>
<p><img src="/img/%E8%AE%A1%E7%BD%91%E5%85%AB%E8%82%A1/3bbe4c5db972513f912d30ba8cbddd65.png" alt="图片"></p>
</li>
<li>
<p>怎么建立WebSocket？为了兼容，最初都用HTTP，在HTTP头中，添加一些字段，表示协议升级为WebSocket</p>
<p><img src="/img/%E8%AE%A1%E7%BD%91%E5%85%AB%E8%82%A1/f4edd3018914fe6eb38fad6aa3fd2d65.png" alt="图片"></p>
</li>
<li>
<p>WebSocket是基于TCP的。是全双工的。</p>
</li>
</ol>
<h1 id="tcp篇"><a class="markdownIt-Anchor" href="#tcp篇"></a> TCP篇</h1>
<p><img src="https://cdn.xiaolincoding.com//mysql/other/1310bf5ed78e4c8186481c47719e0793.png" alt="img"></p>
<h2 id="tcp基本认识"><a class="markdownIt-Anchor" href="#tcp基本认识"></a> TCP基本认识</h2>
<h4 id="tcp头格式"><a class="markdownIt-Anchor" href="#tcp头格式"></a> TCP头格式</h4>
<p><img src="/img/%E8%AE%A1%E7%BD%91%E5%85%AB%E8%82%A1/format,png-20230309230534096.png" alt=""></p>
<p><img src="/img/%E8%AE%A1%E7%BD%91%E5%85%AB%E8%82%A1/image-20250311105243645.png" alt="image-20250311105243645"></p>
<p><img src="/img/%E8%AE%A1%E7%BD%91%E5%85%AB%E8%82%A1/format,png-20230309230439961.png" alt="UDP 头部格式"></p>
<p>TCP与UDP区别：</p>
<ul>
<li>
<p>连接：TCP连接，传输之前要连接；UDP不需要</p>
</li>
<li>
<p>服务对象：TCP一对一；UDP可以一对多，多对多</p>
</li>
<li>
<p>可靠性：TCP可靠，UDP不可靠</p>
</li>
<li>
<p>拥塞控制、流量控制：TCP有，UDP没有</p>
</li>
<li>
<p>首部开销：TCP长，UDP短。TCP有可选变长首部，UDP没有</p>
</li>
<li>
<p>传输方式：TCP是流式没有边界；UDP是一个包一个包，有边界；</p>
</li>
<li>
<p>分片不同：</p>
</li>
</ul>
<h4 id="tcp-连接建立"><a class="markdownIt-Anchor" href="#tcp-连接建立"></a> TCP 连接建立</h4>
<p><strong>TCP 和 UDP 可以使用同一个端口吗</strong></p>
<p>可以的。</p>
<p>操作系统用 ： [协议号（传输层），源IP，源端口，目标IP，目标端口] 来标记一个</p>
<p><img src="/img/%E8%AE%A1%E7%BD%91%E5%85%AB%E8%82%A1/e0d405a55626eb8e4a52553a54680618.gif" alt="握手建立连接流程"></p>
<p><strong>在一个机器上：不同协议可以同时共用一个端口，但是同一个端口不能被同一个协议同时绑定两次。</strong></p>
<p><img src="/img/%E8%AE%A1%E7%BD%91%E5%85%AB%E8%82%A1/tcp%E5%92%8Cudp%E6%A8%A1%E5%9D%97.jpeg" alt="img"></p>
<ul>
<li>
<p><strong>TCP三次握手主要是阻止历史连结</strong>，而不是两次或者四次</p>
</li>
<li>
<p><strong>如何在Linux系统查看TCP状态？ 使用netstat -napt</strong></p>
</li>
<li>
<p><strong>为什么每次初始化TCP连接，初始的序列号都不一样</strong>。为了避免历史报文。</p>
</li>
<li>
<p><strong>IP层MTU会分片，为什么TCP还需要MSS。</strong></p>
<p>那么当如果一个 IP 分片丢失，整个 IP 报文的所有分片都得重传。所以让IP层分片是没有效率的。</p>
<p><img src="/img/%E8%AE%A1%E7%BD%91%E5%85%AB%E8%82%A1/format,png-20230309230633447.png" alt="MTU 与 MSS"></p>
</li>
<li>
<p><strong>第一次握手丢失了，会发生什么？</strong> 会进行等待超时，重发（重发的SYN号一样），每次超时都会加倍等待时间，直到超时次数过多（达到操作系统设置值）就会断开连接。</p>
<p><img src="/img/%E8%AE%A1%E7%BD%91%E5%85%AB%E8%82%A1/%E7%AC%AC1%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%A2%E5%A4%B1.png" alt="img"></p>
</li>
<li>
<p><strong>第二次握手丢失了，会发生什么？</strong> 第二次握手丢失的时候，服务器（发送SYN-ACK）和客户端（发送SYN）都会重发。</p>
<p><img src="/img/%E8%AE%A1%E7%BD%91%E5%85%AB%E8%82%A1/%E7%AC%AC2%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%A2%E5%A4%B1.png" alt=""></p>
<ul>
<li><strong>第三次握手丢失了，会发生什么？</strong> 第三次握手是客户端给服务器发一个SYN-ACK的ACK，如果丢失，那么服务器会重发 SYN-ACK而不是客户端重发，因为ACK丢失是不会重发的。</li>
</ul>
</li>
</ul>
<p><img src="/img/%E8%AE%A1%E7%BD%91%E5%85%AB%E8%82%A1/%E7%AC%AC%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%A2%E5%A4%B1.drawio.png" alt="img"></p>
<h4 id="tcp-连接断开"><a class="markdownIt-Anchor" href="#tcp-连接断开"></a> TCP 连接断开</h4>
<p><img src="/img/%E8%AE%A1%E7%BD%91%E5%85%AB%E8%82%A1/format,png-20230309230614791.png" alt="客户端主动关闭连接 —— TCP 四次挥手"></p>
<p><strong>主动关闭连接的一方采用TIME_WAIT状态</strong></p>
<p>客户端的FIN_WAIT_2和服务端的CLOSED_WAIT等待的时间是服务器的结尾收拾。</p>
<p><strong>第一次挥手丢失了，会发生什么？</strong></p>
<p>​	如果客户端不断丢失重发，达到TCP重发次数之后，再等待一段时间，最后客户端会单方面断开连接。</p>
<p><img src="/img/%E8%AE%A1%E7%BD%91%E5%85%AB%E8%82%A1/%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%8C%A5%E6%89%8B%E4%B8%A2%E5%A4%B1.png" alt="img"></p>
<ul>
<li>
<p><strong>第二次挥手丢失了，会发生什么？</strong></p>
<p>ACK不重发，客户端会进行重发，然后如果不断丢失，客户端可能会单方面断开连接。</p>
<p><img src="/img/%E8%AE%A1%E7%BD%91%E5%85%AB%E8%82%A1/%E7%AC%AC%E4%BA%8C%E6%AC%A1%E6%8C%A5%E6%89%8B%E4%B8%A2%E5%A4%B1.png" alt="img"></p>
</li>
<li>
<p><strong>第三次挥手丢失了，会发生什么？</strong></p>
<p>服务器不断重发，最后仍然超时，如果一直收不到客户端的ACK就断开连接。</p>
<p>客户端不断等待，超时，则断开。</p>
<p><img src="/img/%E8%AE%A1%E7%BD%91%E5%85%AB%E8%82%A1/%E7%AC%AC%E4%B8%89%E6%AC%A1%E6%8C%A5%E6%89%8B%E4%B8%A2%E5%A4%B1.drawio.png" alt="img"></p>
</li>
<li>
<p><strong>第四次挥手丢失了，会发生什么？</strong></p>
<p>ACK丢失，客户端不重传，则服务器重传同时重置客户端的2MSL定时器，直到服务器超过次数，再等待2MSL，关闭。</p>
<p><img src="/img/%E8%AE%A1%E7%BD%91%E5%85%AB%E8%82%A1/%E7%AC%AC%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E4%B8%A2%E5%A4%B1drawio.drawio.png" alt="img"></p>
</li>
<li>
<p><strong>为什么TIME_WAIT等待时间是2MSL？</strong> 2MSL是包在网络上存在的最大生存时间，超过这个时间就会被丢弃，2MSL就是来回的时间。TTL是路由器跳的次数。</p>
</li>
<li>
<p><strong>为什么需要TIME_WAIT状态？</strong></p>
<p>防止历史连接中的数据，因为传输延迟，被后面相同四元组的连接错误接受。</p>
<p>等待足够时间，确保最后的ACK能够让服务器接收。</p>
<p><img src="/img/%E8%AE%A1%E7%BD%91%E5%85%AB%E8%82%A1/6385cc99500b01ba2ef288c27523c1e7-20230309230608128.png" alt="TIME-WAIT 时间过短，收到旧连接的数据报文"></p>
</li>
<li>
<p><strong>TIME_WAIT过多的危害？</strong></p>
<p>占用系统资源。占用端口资源</p>
</li>
<li>
<p><strong>TIME_WAIT状态过多的原因？</strong></p>
<p>HTTP没有使用长连接</p>
<p>HTTP长连接超时：大量客户端都一直没有发送数据，导致服务端主动关闭，处于TIMWE_WAIT</p>
<p>HTTP长连接的请求数量达到上限：数量达到上限，导致不断地关闭连接。</p>
</li>
<li>
<p><strong>服务器出现大量CLOSE_WAIT状态的原因？</strong></p>
<p>CLOSE_WAIT是被动关闭方才用的状态。如果被动关闭方没有调用close函数，就没办法发送FIN报文进行第三次握手，所以没办法使 CLOSE_WAIT 转化为LAST_ACK状态。很可能是代码出了问题。</p>
</li>
<li>
<p><strong>如果已经建立了连接，但是客户端宕机了怎么办？</strong></p>
<p>注意是客户端宕机，而不是进程结束。客户端宕机无法感知，但是进程结束会由内核发送FIN。</p>
<p>如果两方一直都没有发送数据，TCP有一个<strong>保活</strong>机制，如果长时间不发数据，保活机制开始工作。每隔一段时间就发很少量的一段消息，如果一直没有回应，就会关闭连接。</p>
<p>如果是服务器发送数据，但是一直没有回应，也就是没有ACK的话，那么TCP会通过一样的流程。</p>
<p><img src="/img/%E8%AE%A1%E7%BD%91%E5%85%AB%E8%82%A1/2d872f947dedd24800a1867dc4f8b9ce.png" alt="web 服务的 心跳机制"></p>
</li>
<li>
<p><strong>如果建立了连接，但是服务端的进程崩溃会发生什么？</strong></p>
<p>进程崩溃，会由内核进行四次挥手。但如果直接崩溃，则和上面一个问题一样。</p>
</li>
</ul>
<h4 id="socket编程"><a class="markdownIt-Anchor" href="#socket编程"></a> Socket编程</h4>
<p><img src="/img/%E8%AE%A1%E7%BD%91%E5%85%AB%E8%82%A1/format,png-20230309230545997.png" alt="基于 TCP 协议的客户端和服务端工作"></p>
<ul>
<li>
<p><strong>listen的时候backlog的意义？</strong></p>
<p>也就是从listen到accept这之间，把来的请求阻塞住。</p>
<p><img src="/img/%E8%AE%A1%E7%BD%91%E5%85%AB%E8%82%A1/format,png-20230309230542373.png" alt=" SYN 队列 与 Accpet 队列 "></p>
</li>
<li>
<p><strong>accept发生在三次握手的哪一步？</strong></p>
<p>由图，客户端connect成功返回发生在第二次握手，服务端accept成功返回发生在第三次握手成功之后。</p>
<p><img src="/img/%E8%AE%A1%E7%BD%91%E5%85%AB%E8%82%A1/socket%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.drawio.png" alt="socket 三次握手"></p>
</li>
<li>
<p><strong>客户端调用 close 了，连接断开的流程是什么？</strong></p>
<p><img src="/img/%E8%AE%A1%E7%BD%91%E5%85%AB%E8%82%A1/format,png-20230309230538308.png" alt="客户端调用 close 过程"></p>
</li>
<li>
<p><strong>没有accept可以建立TCP连接吗？</strong></p>
<p>可以，accept 不参与TCP三次握手，只是负责从TCP全连接队列中取出一个已经连接的socket，用户层通过accept调用拿到已经建立连接的 socket，就可以对socket读写了。</p>
<p><img src="/img/%E8%AE%A1%E7%BD%91%E5%85%AB%E8%82%A1/3.jpg" alt="半连接队列与全连接队列"></p>
<ul>
<li>
<p>没有listen，可以建立TCP连接吗？</p>
<p>可以。</p>
<p>客户端是可以自己连自己的形成连接（TCP自连接），也可以两个客户端同时向对方发出请求建立连接（TCP同时打开），这两个情况都有个共同点，就是没有服务端参与，也就是没有 listen，就能 TCP 建立连接。</p>
</li>
</ul>
</li>
</ul>
<h2 id="tcp重传-滑动窗口-流量控制-拥塞控制"><a class="markdownIt-Anchor" href="#tcp重传-滑动窗口-流量控制-拥塞控制"></a> TCP重传、滑动窗口、流量控制、拥塞控制</h2>
<p><img src="/img/%E8%AE%A1%E7%BD%91%E5%85%AB%E8%82%A1/3-1741740452191-1.jpg" alt="img"></p>
<h4 id="重传机制"><a class="markdownIt-Anchor" href="#重传机制"></a> 重传机制</h4>
<ol>
<li>超时重传：问题是等待太浪费时间了。</li>
<li>快速重传：如果没收到而后面的包先来了，则发送相同的ACK。发送端便知道有一个包丢失了。但是不好判断重传多少。</li>
</ol>
<p><img src="/img/%E8%AE%A1%E7%BD%91%E5%85%AB%E8%82%A1/10.jpg" alt="快速重传机制"></p>
<ol start="3">
<li>
<p>SACK方法：选择性重发。需要在头部添加一个SACK字段</p>
<p><img src="/img/%E8%AE%A1%E7%BD%91%E5%85%AB%E8%82%A1/11.jpg" alt="选择性确认"></p>
</li>
</ol>
<h4 id="滑动窗口"><a class="markdownIt-Anchor" href="#滑动窗口"></a> 滑动窗口</h4>
<p><img src="/img/%E8%AE%A1%E7%BD%91%E5%85%AB%E8%82%A1/14.jpg" alt="按数据包进行确认应答"></p>
<p>​	图中的 ACK 600 确认应答报文丢失，也没关系，因为可以通过下一个确认应答进行确认，只要发送方收到了 ACK 700 确认应答，就意味着 700 之前的所有数据「接收方」都收到了。这个模式就叫<strong>累计确认</strong>或者<strong>累计应答。</strong></p>
<p>​	窗口大小一般由接收端决定，防止接收端处理不过来导致不断重发。</p>
<p>发送方窗口：</p>
<p><img src="/img/%E8%AE%A1%E7%BD%91%E5%85%AB%E8%82%A1/19.jpg" alt="SND.WND、SND.UN、SND.NXT"></p>
<p>接收方窗口：<br>
<img src="/img/%E8%AE%A1%E7%BD%91%E5%85%AB%E8%82%A1/20.jpg" alt="接收窗口"></p>
<h4 id="流量控制"><a class="markdownIt-Anchor" href="#流量控制"></a> 流量控制</h4>
<p><img src="/img/%E8%AE%A1%E7%BD%91%E5%85%AB%E8%82%A1/21.png" alt="流量控制"></p>
<p><strong>窗口大小根据接收方需求动态调整。</strong></p>
<p><img src="/img/%E8%AE%A1%E7%BD%91%E5%85%AB%E8%82%A1/24.jpg" alt="窗口关闭潜在的危险"></p>
<p><strong>TCP设定一个定时器，如果超时，则发送窗口探测报文。</strong></p>
<p><img src="/img/%E8%AE%A1%E7%BD%91%E5%85%AB%E8%82%A1/25.jpg" alt="窗口探测"></p>
<p><strong>糊涂窗口综合征</strong></p>
<p><img src="/img/%E8%AE%A1%E7%BD%91%E5%85%AB%E8%82%A1/26.png" alt="糊涂窗口综合症"></p>
<p>使用 Nagle 算法，该算法的思路是延时处理，只有满足下面两个条件中的任意一个条件，才可以发送数据： 条件一：要等到窗口大小 &gt;= MSS 并且 数据大小 &gt;= MSS； 条件二：收到之前发送数据的 ack 回包；</p>
<h4 id="拥塞控制"><a class="markdownIt-Anchor" href="#拥塞控制"></a> 拥塞控制</h4>
<p><strong>慢启动</strong></p>
<p>​	假设拥塞窗口cwnd和发送窗口swnd相等</p>
<p>​	一开始cwnd=1，收到ACK加倍增长。</p>
<p>​	达到慢启动门限ssthresh转为使用拥塞避免算法。</p>
<p><img src="/img/%E8%AE%A1%E7%BD%91%E5%85%AB%E8%82%A1/27.jpg" alt="慢启动算法"></p>
<p><strong>拥塞避免算法</strong></p>
<p>当达到ssthresh之后，每收到一个ACK，cwnd增加1</p>
<p><img src="/img/%E8%AE%A1%E7%BD%91%E5%85%AB%E8%82%A1/28.jpg" alt="拥塞避免"></p>
<p>一直增长，网络慢慢拥塞，出现丢包时，需要重发。</p>
<p>重发，出发拥塞发生算法。</p>
<p><strong>拥塞发生算法</strong></p>
<p>​	超时重传：</p>
<p>​		ssthresh 设置为 cwnd / 2，cwnd重置为 初始值 1</p>
<p>​	快速重传：</p>
<p>​		认为情况不严重。</p>
<p>​		cwnd=cwnd / 2, ssthresh = cwnd。</p>
<p>​		进入快速回复算法。</p>
<p><strong>快速恢复算法</strong></p>
<p>​	cwnd = ssthresh + 3</p>
<p>​	重传丢失数据包。</p>
<p>​	每收到重复的ACK，cwnd+1</p>
<p>​</p>
<p><img src="/img/%E8%AE%A1%E7%BD%91%E5%85%AB%E8%82%A1/%E6%8B%A5%E5%A1%9E%E5%8F%91%E7%94%9F-%E5%BF%AB%E9%80%9F%E9%87%8D%E4%BC%A0.drawio.png" alt="快速重传和快速恢复"></p>
<h2 id="如何理解tcp时面向字节流协议"><a class="markdownIt-Anchor" href="#如何理解tcp时面向字节流协议"></a> 如何理解TCP时面向字节流协议？</h2>
<p>​	UDP协议传输时，操作系统不会对消息进行拆分。组装号UDP头部之后直接发送出去。数据部分就是完整的用户数据，接收方收到一个UDP报文就能读到一个完整的用户消息。而在内核中一个UDP报文，就是一个队列元素，不管顺序等。</p>
<p>​	TCP协议则会被OS拆分成多个报文。接收方无法得知消息的边界。必须自定义信息格式以保证消息的边界。也就是会粘包。</p>
<h4 id="tcp-keepalive-和-http-keep-alive-是一个东西吗"><a class="markdownIt-Anchor" href="#tcp-keepalive-和-http-keep-alive-是一个东西吗"></a> TCP KeepAlive 和 HTTP Keep-Alive 是一个东西吗？</h4>
<p>TCP的KeepAlive是TCP层，内核完成的，是保活机制。</p>
<p>HTTP的Keep-Alive是长连接的含义。</p>
<h4 id="tcp协议有什么缺陷"><a class="markdownIt-Anchor" href="#tcp协议有什么缺陷"></a> TCP协议有什么缺陷？</h4>
<ol>
<li>升级TCP很困难：因为它是写在操作系统内核中的。</li>
<li>TCP 建立连接的延迟很高：特别是HTTPS还添加了TLS层的握手</li>
<li>TCP 存在队头阻塞问题：因为TCP是面向字节流的，所以只要一个字节丢失，就不会向上传递。</li>
<li>网络迁移需要重新建立 TCP 连接：因为TCP是 [源IP，源端口，目标IP，目标端口]，当换网络的时候，IP会改变，需要重新建立。</li>
</ol>
<h4 id="如何基于udp实现可靠传输"><a class="markdownIt-Anchor" href="#如何基于udp实现可靠传输"></a> 如何基于UDP实现可靠传输</h4>
<ol>
<li>
<p>QUIC这么做了。</p>
<p><img src="/img/%E8%AE%A1%E7%BD%91%E5%85%AB%E8%82%A1/605d1026df934f20a5ee12f3c55aa6a7.png" alt="img"></p>
<ol start="2">
<li>意义在于：
<ol>
<li>解决TCP升级困难，因为是实现在应用层</li>
<li>减少了建立连接的延迟</li>
<li>解决队头阻塞，可以并发</li>
<li>解决网络迁移需要重新建立，可以用唯一标识符代替四元组。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h4 id="tcp-和-udp-可以使用同一个端口吗"><a class="markdownIt-Anchor" href="#tcp-和-udp-可以使用同一个端口吗"></a> TCP 和 UDP 可以使用同一个端口吗？</h4>
<p><strong>可以。</strong></p>
<p>内核以 [协议号，源IP，源端口，目标IP，目标端口]标识，但是不能TCP同时有两个进程绑定同一个端口。</p>
<h4 id="服务端没有listen客户端发起连接请求会发生什么"><a class="markdownIt-Anchor" href="#服务端没有listen客户端发起连接请求会发生什么"></a> 服务端没有listen，客户端发起连接请求，会发生什么？</h4>
<p>如果listen了，并且指定backlog，那么肯定客户端请求会存在队列中。</p>
<p>但是如果没有listen，内核找不到对应的socket，会由内核发出关闭连接的操作。</p>
<h4 id="没有listen可以建立tcp连接吗"><a class="markdownIt-Anchor" href="#没有listen可以建立tcp连接吗"></a> 没有listen，可以建立TCP连接吗？</h4>
<p>可以。</p>
<p>一个进程自己connect自己。</p>
<p>bind -&gt; connect -&gt; send -&gt; recv</p>
<h4 id="tcp-四次挥手可以变成三次吗"><a class="markdownIt-Anchor" href="#tcp-四次挥手可以变成三次吗"></a> TCP 四次挥手，可以变成三次吗？</h4>
<p>可以。</p>
<p>四次挥手的原因是：</p>
<p>​	客户端发送FIN，内核会回复ACK。这个时候服务端需要处理数据或者发送一些数据。之后才第三次挥手。</p>
<p>​	如果服务端不需要再继续发送数据，那么可以直接第二次挥手和第三次挥手结合。但是需要阻止内核直接回复ACK。</p>
<p>​	这是一个参数，TCP_QUICKACK，关闭这个参数，即可延迟确认。</p>
<p>​	那么这个时候就可以让服务器ACK和FIN一起发送，减少一次挥手。</p>
<h4 id="tcp-序列号和确认号是如何变化的"><a class="markdownIt-Anchor" href="#tcp-序列号和确认号是如何变化的"></a> TCP 序列号和确认号是如何变化的?</h4>
<p><img src="/img/%E8%AE%A1%E7%BD%91%E5%85%AB%E8%82%A1/image-20250312112040224.png" alt="image-20250312112040224"></p>
<h1 id="ip篇"><a class="markdownIt-Anchor" href="#ip篇"></a> IP篇</h1>
<h2 id="ip基本知识"><a class="markdownIt-Anchor" href="#ip基本知识"></a> IP基本知识</h2>
<p><img src="/img/%E8%AE%A1%E7%BD%91%E5%85%AB%E8%82%A1/1.jpg" alt="IP 基础知识全家桶"></p>
<p>IP是网络层，目的是把数据发给目标主机</p>
<p>MAC是链路层，目的是把数据发给相邻主机</p>
<p><img src="/img/%E8%AE%A1%E7%BD%91%E5%85%AB%E8%82%A1/7.jpg" alt="IP 地址分类"></p>
<p><img src="/img/%E8%AE%A1%E7%BD%91%E5%85%AB%E8%82%A1/14-1741750378809-10.jpg" alt="IP 分类判断"></p>
<p>广播地址：主机部分全一</p>
<p>本机地址：主机部分全0</p>
<p>网络号为127.0.1：回环地址</p>
<h4 id="无分类地址-cidr"><a class="markdownIt-Anchor" href="#无分类地址-cidr"></a> 无分类地址 CIDR</h4>
<p>a.b.c.d/x 用x表示网络号与主机号之间的划分。</p>
<p>x可以用来划分子网。使用子网掩码来进行子网划分</p>
<p>更高效的利用IP地址</p>
<h4 id="ping-的工作原理-icmp"><a class="markdownIt-Anchor" href="#ping-的工作原理-icmp"></a> ping 的工作原理 - ICMP</h4>
<p><strong>ICMP协议</strong>：IP基于ICMP工作。</p>
<p>ICMP 主要的功能包括：确认 IP 包是否成功送达目标地址、报告发送过程中 IP 包被废弃的原因和改善网络设置等。</p>
<p><img src="/img/%E8%AE%A1%E7%BD%91%E5%85%AB%E8%82%A1/4.jpg" alt="ICMP 目标不可达消息"></p>
<p>ICMP类型分为两类，一类是查询报文类型，一类是差错报文类型。</p>
<p><img src="/img/%E8%AE%A1%E7%BD%91%E5%85%AB%E8%82%A1/6.jpg" alt="常见的 ICMP 类型"></p>
<p><strong>traceroute-差错报文的使用</strong></p>
<ul>
<li>traceroute 的第一个作用就是故意设置特殊的 TTL，来追踪去往目的地时沿途经过的路由器。</li>
<li>traceroute 还有一个作用是故意设置不分片，从而确定路径的 MTU。</li>
</ul>
<h4 id="localhost-127001-0000与本机ip的区别"><a class="markdownIt-Anchor" href="#localhost-127001-0000与本机ip的区别"></a> localhost、127.0.0.1、0.0.0.0与本机IP的区别</h4>
<p>127.0.0.1 就是回环地址，表示本机</p>
<p>localhost 是一个域名，写在 hosts.txt 中，就是 127.0.0.1</p>
<p><code>0.0.0.0</code>是不能被<code>ping</code>通的。在服务器中，<code>0.0.0.0</code>并不是一个真实的的<strong>IP地址</strong>，它表示本机中所有的<strong>IPV4地址</strong>。监听<code>0.0.0.0</code>的端口，就是监听本机中所有<strong>IP</strong>的端口。</p>
<p>本机IP地址，就是当前这个主机的IP地址。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="https://Dog-Du.github.io">DogDu</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="https://dog-du.github.io/2025/03/10/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/">https://dog-du.github.io/2025/03/10/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%B7%B2%E5%AE%8C%E6%88%90/">已完成</a><a class="post-meta__tags" href="/tags/%E5%A4%8D%E4%B9%A0/">复习</a><a class="post-meta__tags" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a></div><div class="post-share"><div class="social-share" data-image="/img/top_img.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/03/09/%E9%80%9F%E9%80%9Aeffective-modern-cpp/" title="听课，学effective-modern-cpp"><img class="cover" src="/img/top_img.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">Previous</div><div class="info-item-2">听课，学effective-modern-cpp</div></div><div class="info-2"><div class="info-item-1">听课，学effective-modern-cpp复习C++特性</div></div></div></a><a class="pagination-related" href="/2025/03/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/" title="复习操作系统"><img class="cover" src="/img/top_img.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">Next</div><div class="info-item-2">复习操作系统</div></div><div class="info-2"><div class="info-item-1">看中山大学OS，学操作系统</div></div></div></a></nav><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> Comments</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/head.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">DogDu</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">16</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">12</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">2</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Dog-Du"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is DogDu's Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E7%AF%87"><span class="toc-text"> 基础篇</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#tcpip-%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E6%9C%89%E5%93%AA%E5%87%A0%E5%B1%82"><span class="toc-text"> TCP&#x2F;IP 网络模型有哪几层</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%B1%82"><span class="toc-text"> 应用层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%A0%E8%BE%93%E5%B1%82"><span class="toc-text"> 传输层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%B1%82"><span class="toc-text"> 网络层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E6%8E%A5%E5%8F%A3%E5%B1%82"><span class="toc-text"> 网络接口层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text"> 总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E5%88%B0%E7%BD%91%E9%A1%B5%E6%98%BE%E7%A4%BA%E6%9C%9F%E9%97%B4%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88"><span class="toc-text"> 键入网址到网页显示，期间发生了什么？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E8%A7%A3%E6%9E%90url%E7%94%9F%E6%88%90http%E8%AF%B7%E6%B1%82%E6%B6%88%E6%81%AF"><span class="toc-text"> 浏览器解析URL，生成HTTP请求消息。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E6%8A%8A%E5%9F%9F%E5%90%8D%E5%8F%91%E7%BB%99dns%E5%BE%97%E5%88%B0%E5%AF%B9%E5%BA%94ip%E5%9C%B0%E5%9D%80"><span class="toc-text"> 浏览器把域名发给DNS，得到对应IP地址。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%8Ahttp%E7%9A%84%E4%BC%A0%E8%BE%93%E5%B7%A5%E4%BD%9C%E4%BA%A4%E7%BB%99%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8D%8F%E8%AE%AE%E6%A0%88"><span class="toc-text"> 把HTTP的传输工作交给操作系统的协议栈。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93tcp"><span class="toc-text"> 可靠传输TCP</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9C%E7%A8%8B%E5%AE%9A%E4%BD%8Dip"><span class="toc-text"> 远程定位IP</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%A4%E7%82%B9%E4%BC%A0%E8%BE%93mac"><span class="toc-text"> 两点传输MAC</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BA%E5%8F%A3-%E7%BD%91%E5%8D%A1"><span class="toc-text"> 出口-网卡</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%A4%E6%8D%A2%E6%9C%BA"><span class="toc-text"> 交换机</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E5%99%A8"><span class="toc-text"> 路由器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8E%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-text"> 服务器与客户端</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#tcp%E5%85%B3%E9%97%AD%E6%97%B6%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="toc-text"> TCP关闭时四次挥手</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#linux%E7%B3%BB%E7%BB%9F%E6%98%AF%E5%A6%82%E4%BD%95%E6%94%B6%E5%8F%91%E7%BD%91%E7%BB%9C%E5%8C%85%E7%9A%84"><span class="toc-text"> Linux系统是如何收发网络包的？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#linux%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%A0%88"><span class="toc-text"> Linux网络协议栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#linux%E6%8E%A5%E5%8F%97%E7%BD%91%E7%BB%9C%E5%8C%85%E6%B5%81%E7%A8%8B"><span class="toc-text"> Linux接受网络包流程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#http%E7%AF%87"><span class="toc-text"> HTTP篇</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#http-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-text"> HTTP 基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#http%E5%B8%B8%E8%A7%81%E5%AD%97%E6%AE%B5"><span class="toc-text"> HTTP常见字段</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#get-%E4%B8%8E-post"><span class="toc-text"> GET 与 POST</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#get-%E4%B8%8E-post-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text"> GET 与 POST 的区别</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#http%E7%BC%93%E5%AD%98%E6%8A%80%E6%9C%AF"><span class="toc-text"> HTTP缓存技术</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#http%E7%BC%93%E5%AD%98%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-text"> HTTP缓存的实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%BA%E5%88%B6%E7%BC%93%E5%AD%98"><span class="toc-text"> 强制缓存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98"><span class="toc-text"> 协商缓存</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#http%E7%89%B9%E6%80%A7"><span class="toc-text"> HTTP特性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#http%E4%BC%98%E7%82%B9"><span class="toc-text"> HTTP优点：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#http%E7%BC%BA%E7%82%B9"><span class="toc-text"> HTTP缺点：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#http11%E6%80%A7%E8%83%BD"><span class="toc-text"> HTTP&#x2F;1.1性能</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#http%E4%B8%8Ehttps"><span class="toc-text"> HTTP与HTTPS</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#http%E4%B8%8Ehttps%E5%8C%BA%E5%88%AB"><span class="toc-text"> HTTP与HTTPS区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#https%E8%A7%A3%E5%86%B3%E7%9A%84http%E9%97%AE%E9%A2%98"><span class="toc-text"> HTTPS解决的HTTP问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#https-%E6%98%AF%E5%A6%82%E4%BD%95%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5%E7%9A%84"><span class="toc-text"> HTTPS 是如何建立连接的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#https%E7%9A%84%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%AE%8C%E6%95%B4%E6%80%A7"><span class="toc-text"> HTTPS的应用程序如何保证完整性。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#http11-http2-http3%E6%BC%94%E5%8F%98"><span class="toc-text"> HTTP&#x2F;1.1、HTTP&#x2F;2、HTTP&#x2F;3演变</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#http11%E4%BC%98%E5%8C%96"><span class="toc-text"> HTTP&#x2F;1.1优化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#https-rsa-%E6%8F%A1%E6%89%8B%E8%A7%A3%E6%9E%90"><span class="toc-text"> HTTPS RSA 握手解析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#https-ecdhe-%E6%8F%A1%E6%89%8B%E8%A7%A3%E6%9E%90"><span class="toc-text"> HTTPS ECDHE 握手解析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#https%E4%BC%98%E5%8C%96"><span class="toc-text"> HTTPS优化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#http2%E4%BC%98%E7%82%B9"><span class="toc-text"> HTTP&#x2F;2优点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#http3"><span class="toc-text"> HTTP&#x2F;3</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%89%E4%BA%86http%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E6%9C%89rpc"><span class="toc-text"> 有了HTTP，为什么还有RPC？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%89%E4%BA%86http%E8%BF%98%E6%9C%89websocket"><span class="toc-text"> 为什么有了HTTP，还有WebSocket？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#tcp%E7%AF%87"><span class="toc-text"> TCP篇</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#tcp%E5%9F%BA%E6%9C%AC%E8%AE%A4%E8%AF%86"><span class="toc-text"> TCP基本认识</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#tcp%E5%A4%B4%E6%A0%BC%E5%BC%8F"><span class="toc-text"> TCP头格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#tcp-%E8%BF%9E%E6%8E%A5%E5%BB%BA%E7%AB%8B"><span class="toc-text"> TCP 连接建立</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#tcp-%E8%BF%9E%E6%8E%A5%E6%96%AD%E5%BC%80"><span class="toc-text"> TCP 连接断开</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#socket%E7%BC%96%E7%A8%8B"><span class="toc-text"> Socket编程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#tcp%E9%87%8D%E4%BC%A0-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3-%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6"><span class="toc-text"> TCP重传、滑动窗口、流量控制、拥塞控制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6"><span class="toc-text"> 重传机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3"><span class="toc-text"> 滑动窗口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6"><span class="toc-text"> 流量控制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6"><span class="toc-text"> 拥塞控制</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3tcp%E6%97%B6%E9%9D%A2%E5%90%91%E5%AD%97%E8%8A%82%E6%B5%81%E5%8D%8F%E8%AE%AE"><span class="toc-text"> 如何理解TCP时面向字节流协议？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#tcp-keepalive-%E5%92%8C-http-keep-alive-%E6%98%AF%E4%B8%80%E4%B8%AA%E4%B8%9C%E8%A5%BF%E5%90%97"><span class="toc-text"> TCP KeepAlive 和 HTTP Keep-Alive 是一个东西吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#tcp%E5%8D%8F%E8%AE%AE%E6%9C%89%E4%BB%80%E4%B9%88%E7%BC%BA%E9%99%B7"><span class="toc-text"> TCP协议有什么缺陷？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%9F%BA%E4%BA%8Eudp%E5%AE%9E%E7%8E%B0%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93"><span class="toc-text"> 如何基于UDP实现可靠传输</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#tcp-%E5%92%8C-udp-%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%E5%90%8C%E4%B8%80%E4%B8%AA%E7%AB%AF%E5%8F%A3%E5%90%97"><span class="toc-text"> TCP 和 UDP 可以使用同一个端口吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B2%A1%E6%9C%89listen%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%8F%91%E8%B5%B7%E8%BF%9E%E6%8E%A5%E8%AF%B7%E6%B1%82%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88"><span class="toc-text"> 服务端没有listen，客户端发起连接请求，会发生什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B2%A1%E6%9C%89listen%E5%8F%AF%E4%BB%A5%E5%BB%BA%E7%AB%8Btcp%E8%BF%9E%E6%8E%A5%E5%90%97"><span class="toc-text"> 没有listen，可以建立TCP连接吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#tcp-%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E5%8F%AF%E4%BB%A5%E5%8F%98%E6%88%90%E4%B8%89%E6%AC%A1%E5%90%97"><span class="toc-text"> TCP 四次挥手，可以变成三次吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#tcp-%E5%BA%8F%E5%88%97%E5%8F%B7%E5%92%8C%E7%A1%AE%E8%AE%A4%E5%8F%B7%E6%98%AF%E5%A6%82%E4%BD%95%E5%8F%98%E5%8C%96%E7%9A%84"><span class="toc-text"> TCP 序列号和确认号是如何变化的?</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ip%E7%AF%87"><span class="toc-text"> IP篇</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ip%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86"><span class="toc-text"> IP基本知识</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A0%E5%88%86%E7%B1%BB%E5%9C%B0%E5%9D%80-cidr"><span class="toc-text"> 无分类地址 CIDR</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ping-%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-icmp"><span class="toc-text"> ping 的工作原理 - ICMP</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#localhost-127001-0000%E4%B8%8E%E6%9C%AC%E6%9C%BAip%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text"> localhost、127.0.0.1、0.0.0.0与本机IP的区别</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Posts</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/27/Architecture%20Of%20a%20Database%20System/" title="读论文-Architecture of a Database System">读论文-Architecture of a Database System</a><time datetime="2025-03-27T08:37:49.000Z" title="Created 2025-03-27 16:37:49">2025-03-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/" title="复习操作系统">复习操作系统</a><time datetime="2025-03-14T02:43:15.000Z" title="Created 2025-03-14 10:43:15">2025-03-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/10/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/" title="计网复习">计网复习</a><time datetime="2025-03-10T00:54:15.000Z" title="Created 2025-03-10 08:54:15">2025-03-10</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By DogDu</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.3</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="Scroll to Comments"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null

  const commentCount = n => {
    const isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
    if (isCommentCount) {
      isCommentCount.textContent= n
    }
  }

  const initGitalk = (el, path) => {
    if (isShuoshuo) {
      window.shuoshuoComment.destroyGitalk = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }

    const gitalk = new Gitalk({
      clientID: 'Ov23lip70wbjDSj3yXVa',
      clientSecret: '229af146a5a288cca20082b54bcaf2ea896347af',
      repo: 'Dog-Du.github.io',
      owner: 'Dog-Du',
      admin: ['Dog-Du'],
      updateCountCallback: commentCount,
      ...option,
      id: (decodeURIComponent(location.pathname)).substring(0, 48),
      distractionFreeMode: false
    })

    gitalk.render('gitalk-container')
  }

  const loadGitalk = async(el, path) => {
    if (typeof Gitalk === 'function') initGitalk(el, path)
    else {
      await btf.getCSS('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css')
      await btf.getScript('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js')
      initGitalk(el, path)
    }
  }

  if (isShuoshuo) {
    'Gitalk' === 'Gitalk'
      ? window.shuoshuoComment = { loadComment: loadGitalk }
      : window.loadOtherComment = loadGitalk
    return
  }

  if ('Gitalk' === 'Gitalk' || !false) {
    if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
    else loadGitalk()
  } else {
    window.loadOtherComment = loadGitalk
  }
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>