<!DOCTYPE html><html lang="cn-ZH" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>听课，速通effective-modern-cpp | DogDu's blog</title><meta name="author" content="DogDu"><meta name="copyright" content="DogDu"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="听课，用effective-modern-cpp速通cpp八股">
<meta property="og:type" content="article">
<meta property="og:title" content="听课，速通effective-modern-cpp">
<meta property="og:url" content="https://dog-du.github.io/2024/03/09/%E9%80%9F%E9%80%9Aeffective-modern-cpp/index.html">
<meta property="og:site_name" content="DogDu&#39;s blog">
<meta property="og:description" content="听课，用effective-modern-cpp速通cpp八股">
<meta property="og:locale" content="cn_ZH">
<meta property="og:image" content="https://dog-du.github.io/img/top_img.jpg">
<meta property="article:published_time" content="2024-03-09T13:54:15.000Z">
<meta property="article:modified_time" content="2025-03-10T13:28:30.045Z">
<meta property="article:author" content="DogDu">
<meta property="article:tag" content="八股">
<meta property="article:tag" content="未完成">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://dog-du.github.io/img/top_img.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "听课，速通effective-modern-cpp",
  "url": "https://dog-du.github.io/2024/03/09/%E9%80%9F%E9%80%9Aeffective-modern-cpp/",
  "image": "https://dog-du.github.io/img/top_img.jpg",
  "datePublished": "2024-03-09T13:54:15.000Z",
  "dateModified": "2025-03-10T13:28:30.045Z",
  "author": [
    {
      "@type": "Person",
      "name": "DogDu",
      "url": "https://dog-du.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/head.jpg"><link rel="canonical" href="https://dog-du.github.io/2024/03/09/%E9%80%9F%E9%80%9Aeffective-modern-cpp/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":300,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '听课，速通effective-modern-cpp',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="alternate" href="/atom.xml" title="DogDu's blog" type="application/atom+xml">
</head><body><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/top_img.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="/img/head.jpg" alt="Logo"><span class="site-name">DogDu's blog</span></a><a class="nav-page-title" href="/"><span class="site-name">听课，速通effective-modern-cpp</span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">听课，速通effective-modern-cpp</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2024-03-09T13:54:15.000Z" title="Created 2024-03-09 21:54:15">2024-03-09</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2025-03-10T13:28:30.045Z" title="Updated 2025-03-10 21:28:30">2025-03-10</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%AD%A6%E4%B9%A0%E7%B1%BB/">学习类</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p><strong>课程   bilibili: <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Gg4y1p71w">effective-modern-cpp</a></strong></p>
<h1 id="第一章类型推导"><a class="markdownIt-Anchor" href="#第一章类型推导"></a> 第一章：类型推导</h1>
<h3 id="顶层const和底层const"><a class="markdownIt-Anchor" href="#顶层const和底层const"></a> 顶层const和底层const</h3>
<p><img src="/img/%E9%80%9F%E9%80%9Aeffective-modern-cpp/image-20250309151313265.png" alt="image-20250309151313265"></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="comment">/* 没有指针，这里是顶层 */</span> <span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="type">const</span> <span class="comment">/* 引用由指针实现，这里是底层 */</span> <span class="type">int</span> &amp;a = <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="comment">/* 底层const */</span> <span class="type">int</span> *<span class="type">const</span> <span class="comment">/* 顶层const */</span> p;</span><br><span class="line"><span class="comment">// 当执行copy时，常量的顶层const不受什么影响，而底层const必须有一致的const资格。</span></span><br><span class="line"><span class="comment">// 我因为底层的const是所指向的对象的属性，顶层const是本身的属性，</span></span><br><span class="line"><span class="comment">// 本身当然不能修改所指向的对象的属性</span></span><br><span class="line"><span class="comment">// 从安全角度考虑更容易理解</span></span><br></pre></td></tr></tbody></table></figure>
<p><img src="/img/%E9%80%9F%E9%80%9Aeffective-modern-cpp/image-20250309152134974.png" alt="image-20250309152134974"></p>
<p>有点嗯背了。</p>
<p><strong>只有指针有所谓的const顶层，const底层。其他类型包括引用只有底层。</strong></p>
<h3 id="值类型与右值引用"><a class="markdownIt-Anchor" href="#值类型与右值引用"></a> 值类型与右值引用</h3>
<p><img src="/img/%E9%80%9F%E9%80%9Aeffective-modern-cpp/image-20250309152738190.png" alt="image-20250309152738190"></p>
<ol>
<li>
<p>联想到汇编很容易理解</p>
</li>
<li>
<p>想到重载的 T&amp; operator++() 和 const T operator++(int)</p>
<p><img src="/img/%E9%80%9F%E9%80%9Aeffective-modern-cpp/image-20250309153344915.png" alt="image-20250309153344915"></p>
<p><img src="/img/%E9%80%9F%E9%80%9Aeffective-modern-cpp/image-20250309154132253.png" alt="image-20250309154132253"></p>
<p><img src="/img/%E9%80%9F%E9%80%9Aeffective-modern-cpp/image-20250309155148904.png" alt="image-20250309155148904"></p>
</li>
<li>
<p>右值引用&amp;&amp;只能绑定右值（但他仍然是引用），左值引用&amp;只能绑定左值，</p>
</li>
<li>
<p>那么可见std::move其实就是**将左值类型强制转化为右值。**移动语义没移动 -&gt; 是类本身做的这个事情，如果类没有实现移动构造，那么会调用const T&amp;构造。完美转发不完美，哈哈哈。</p>
</li>
<li>
<p>字符串字面量不是右值，因为它存在静态内存中，是持久存在的。</p>
</li>
<li>
<p><strong>把左值转化为右值的值，成为将亡值，所以它既是左值也是右值。</strong></p>
</li>
<li>
<p>T &amp;&amp;a = std::move(b); 什么都不会发生，差不多等于：T &amp;a = b;</p>
</li>
<li>
<p><strong>顶层const不构成重载。</strong></p>
</li>
<li>
<p><strong>右值引用仍然是左值，</strong></p>
</li>
</ol>
<h3 id="类型推导"><a class="markdownIt-Anchor" href="#类型推导"></a> 类型推导</h3>
<p><img src="/img/%E9%80%9F%E9%80%9Aeffective-modern-cpp/image-20250309155312674.png" alt="image-20250309155312674"></p>
<p><img src="/img/%E9%80%9F%E9%80%9Aeffective-modern-cpp/image-20250309160258748.png" alt="image-20250309160258748"></p>
<ol>
<li>数组名不等于指针，但是数组可以退化成指针。也就是<strong>数组的长度信息丢失了。</strong></li>
<li>字符串字面量，是字符串数组，放在静态区，“hello world” 其实是 const char[12]，所以可以 const char *s = “hello world”来进行赋值。这里发生了数组类型的退化。对于 char *s = “hello world” 来说，编译器会警告，如果进行写操作会段错误。</li>
<li>函数指针与函数名，对函数指针赋值的时候 ptr = func/&amp;func；都可以，可以认为发生了函数名的退化。同样的，在使用的时候 (*ptr)()/ptr(); 都可以，这就比较混乱了。</li>
<li>类型别名，typedef 和 using都可以定义类型别名，不过using更好用。typedef在定义函数指针别名时，需要typedef bool (*func)(int, int)也就是using func = bool (*)(int, int)/ using func = bool (int, int)</li>
<li>函数指针作为返回值使用</li>
</ol>
<h2 id="条款一理解模板类型推导"><a class="markdownIt-Anchor" href="#条款一理解模板类型推导"></a> 条款一：理解模板类型推导</h2>
<p><img src="/img/%E9%80%9F%E9%80%9Aeffective-modern-cpp/image-20250309161826547.png" alt="image-20250309161826547"></p>
<p><img src="/img/%E9%80%9F%E9%80%9Aeffective-modern-cpp/image-20250309162038873.png" alt="image-20250309162038873"></p>
<ol>
<li>
<p>up主想的一个很鬼畜的事情，对函数指针进行底层const，这是没必要的事情，因为函数本身就不可能被修改，总不能深入代码区去修改字节码吧。同样，函数指针的底层const会被编译器忽略，也是很合理的事情。</p>
</li>
<li>
<p>template<typename t=""> func(&amp;&amp; T) 会发生<strong>引用折叠</strong>，会把T的&amp;给折叠成一个，当然引用折叠会发生在多个情况。在函数的声明中使用 &amp;&amp; 是万能引用了，因为既可以接受右值引用也可以接受左值引用。</typename></p>
</li>
<li>
<p>GPT出来的：T&amp;  &amp; 折叠为 T&amp;； T&amp;  &amp;&amp; 折叠为 T&amp;； T&amp;&amp;  &amp; 折叠为 T&amp;&amp;； T&amp;&amp;  &amp;&amp; 折叠为 T&amp;&amp;。</p>
</li>
<li>
<p><strong>万能引用的写法只有 &amp;&amp; T 和 auto &amp;</strong>&amp;，只要稍作更改，比如 const &amp;&amp; T，那么就会变成右值引用。</p>
</li>
</ol>
<h2 id="条款七区别使用与-创建对象"><a class="markdownIt-Anchor" href="#条款七区别使用与-创建对象"></a> 条款七：区别使用（）与 {} 创建对象</h2>
<p><img src="/img/%E9%80%9F%E9%80%9Aeffective-modern-cpp/image-20250309164901023.png" alt="image-20250309164901023"></p>
<p><img src="/img/%E9%80%9F%E9%80%9Aeffective-modern-cpp/image-20250309170228603.png" alt="image-20250309170228603"></p>
<p><img src="/img/%E9%80%9F%E9%80%9Aeffective-modern-cpp/image-20250309165614290.png" alt="image-20250309165614290"></p>
<p><img src="/img/%E9%80%9F%E9%80%9Aeffective-modern-cpp/image-20250309170430444.png" alt="image-20250309170430444"></p>
<p><img src="/img/%E9%80%9F%E9%80%9Aeffective-modern-cpp/image-20250309171047875.png" alt="image-20250309171047875"></p>
<ol>
<li>
<p>构造有五种： A a=10; A a(10); A a=(10); /   A a{10}; A a={10}; 前三种一样（在开启返回值优化之后，否则会发生一次隐式转换），后两种一样（在auto初始化时略有区别）。</p>
</li>
<li>
<p>A a=10;和A a=(10)；的缺陷是，只能接受一个参数，同时会发生一次隐式转换。</p>
</li>
<li>
<p>A a(10)的缺陷是，在作为参数传递时，会发生一次copy构造。</p>
</li>
<li>
<p>A a{10}；的优点就是解决了上面的缺陷，同时<strong>不允许缩窄转换。简化了聚合类的初始化。对解析问题天生免疫。</strong></p>
<p>（解析问题就是括号问题导致的变量声明和函数声明区别）。</p>
</li>
<li>
<p>{}初始化包裹问题，感觉更多的是字面量初始化的时候的问题。</p>
</li>
<li>
<p><strong>总是优先匹配列表初始化，即时编译时报错。除非类型之间不存在隐式转换。</strong></p>
</li>
<li>
<p>空的 { } 不会调用列表初始化，但是{ { } }和 ({ })会</p>
</li>
</ol>
<h2 id="条款二理解auto类型推导"><a class="markdownIt-Anchor" href="#条款二理解auto类型推导"></a> 条款二：理解auto类型推导</h2>
<p><img src="/img/%E9%80%9F%E9%80%9Aeffective-modern-cpp/image-20250309171742198.png" alt="image-20250309171742198"></p>
<ol>
<li>
<p>auto x = {2};会匹配成列表，但是 auto x{2}会把 2 当成int；</p>
</li>
<li>
<p>auto x = {2,3};是列表。但是 auto x{2,3}八成会报错。</p>
</li>
<li>
<p>typelate<typename t=""> func(T x)是推导不出来列表的，必须直接声明出列表。</typename></p>
</li>
<li>
<p>auto作为返回值时，是按模板的规则走的。</p>
</li>
<li>
<p><strong>auto和模板大部分一致，个别不一致。</strong></p>
<h2 id="条款九优先考虑别名声明而非typedef"><a class="markdownIt-Anchor" href="#条款九优先考虑别名声明而非typedef"></a> 条款九：优先考虑别名声明而非typedef</h2>
<p><img src="/img/%E9%80%9F%E9%80%9Aeffective-modern-cpp/image-20250309172701661.png" alt="image-20250309172701661"></p>
<p><img src="/img/%E9%80%9F%E9%80%9Aeffective-modern-cpp/image-20250309173313241.png" alt="image-20250309173313241"></p>
<p><img src="/img/%E9%80%9F%E9%80%9Aeffective-modern-cpp/image-20250309173542873.png" alt="image-20250309173542873"></p>
</li>
<li>
<p>typename 用来澄清模板内部的** T 标志某个类型成员，而非数据成员。**</p>
</li>
<li>
<p><strong>C++默认访问的是一个非类型成员，在使用 :: 的时候。</strong></p>
</li>
<li>
<p>对于模板来说，using比typedef更好用。使用using声明别名可以更清晰的表示是一个类型，即使在模板内部。</p>
</li>
<li>
<p>类型萃取器。用来添加/删除模板T的修饰。也可以用来判断一个对象是否是某个类的实例。</p>
</li>
<li>
<p>注意using的作用域。</p>
</li>
</ol>
<h2 id="条款二十三理解stdmove和stdforward"><a class="markdownIt-Anchor" href="#条款二十三理解stdmove和stdforward"></a> 条款二十三：理解std::move和std::forward</h2>
<p><img src="/img/%E9%80%9F%E9%80%9Aeffective-modern-cpp/image-20250309190343629.png" alt="image-20250309190343629"></p>
<p><img src="/img/%E9%80%9F%E9%80%9Aeffective-modern-cpp/image-20250309192157134.png" alt="image-20250309192157134"></p>
<ol>
<li>std::move的实现：使用类型萃取，把类型萃取出来，然后加上 &amp;&amp; ， std::move本质是右值转换。把一个右值转化为将亡值。让这个对象很适合被移动，但是到底移动不移动，这不好说。，</li>
<li>对于const类型，std::move还是返回的是一个const类型的右值引用，但这个时候const的右值引用和右值引用类型是不匹配的。</li>
<li>std::forward就是转发。结果一个问题：<strong>对于函数参数，T &amp;&amp;param，函数内部一定对param变成一个左值，而非右值。原参数的左右值信息丢失了</strong></li>
<li>std::forward就是有条件的move，只有实参用右值初始化的时候才转化为右值，而std::move本质是将左值转化为右值。</li>
</ol>
<h2 id="条款三理解delctype"><a class="markdownIt-Anchor" href="#条款三理解delctype"></a> 条款三：理解delctype</h2>
<p><img src="/img/%E9%80%9F%E9%80%9Aeffective-modern-cpp/image-20250309192733425.png" alt="image-20250309192733425"></p>
<p><img src="/img/%E9%80%9F%E9%80%9Aeffective-modern-cpp/image-20250309193626706.png" alt="image-20250309193626706"></p>
<ol>
<li>
<p>decltype + 变量，所有信息均被保留，数组与函数也不会退化。</p>
</li>
<li>
<p>decltype + 表达式 会返回表达式结果对应的类型。不是左值就是右值</p>
<p>{左值：得到该类型的引用；右值：得到该类型}</p>
</li>
<li>
<p>decltype 不是实际计算表达式的值，只会推断其类型。</p>
</li>
<li>
<p>decltype(auto)可以保留 xxx 的全部细节。可以认为等价于 auto -&gt; decltype(返回值)</p>
</li>
<li>
<p><strong>右值不一定不能放在等号的左边，因为这本质上是在调用operator = 操作</strong>，但是这种操作应该避免，避免在函数返回值返回 T ，应该返回const T来避免这种情况。</p>
</li>
<li>
<p>func(T &amp;&amp;t) { return t; } 返回的是一个左值，可以用完美转发来替代。</p>
</li>
</ol>
<h3 id="c类对象的布局"><a class="markdownIt-Anchor" href="#c类对象的布局"></a> C++类对象的布局</h3>
<p><img src="/img/%E9%80%9F%E9%80%9Aeffective-modern-cpp/image-20250309194857870.png" alt="image-20250309194857870"></p>
<p><img src="/img/%E9%80%9F%E9%80%9Aeffective-modern-cpp/image-20250309200314815.png" alt="image-20250309200314815"></p>
<ol>
<li>
<p>非虚函数，不会影响对象的大小，放在代码区中。</p>
</li>
<li>
<p><strong>虚函数，当然函数还是放在代码区，会影响对象的大小，多 8/4 个字节，用来存放一个指针，指向虚表。</strong></p>
</li>
<li>
<p>非静态成员，会影响对象大小。</p>
</li>
<li>
<p>静态成员，不会影响对象大小。</p>
</li>
<li>
<p>**有虚函数的类，其地址本身就是指向虚表的指针的地址。**也就是说指向虚表的指针的地址存在类的最起点，可以根据这个地址来进行验证虚表的存在。</p>
</li>
<li>
<p><strong>type_info是C++的一个标准数据类型，在虚表的头，也就是虚表的 -1 处</strong>，记录着有关类的信息。比如类名之类的。</p>
</li>
</ol>
<h3 id="c中的多态和rtti"><a class="markdownIt-Anchor" href="#c中的多态和rtti"></a> C++中的多态和RTTI</h3>
<p><img src="/img/%E9%80%9F%E9%80%9Aeffective-modern-cpp/image-20250309202258454.png" alt="image-20250309202258454"></p>
<p><img src="/img/%E9%80%9F%E9%80%9Aeffective-modern-cpp/image-20250309202712393.png" alt="image-20250309202712393"></p>
<p><img src="/img/%E9%80%9F%E9%80%9Aeffective-modern-cpp/image-20250309203410209.png" alt="image-20250309203410209"></p>
<ol>
<li>**RTTI（RunTime Type Identification）也即运行期间类型识别，但在C++中，只有包含虚函数的类才能支持RTTI。**原因也很简单，因为只有包含虚函数的类，才有虚表，才有type_info</li>
<li>对于需要使用继承的基类，其析构函数应该为虚函数，这点在effective C++也提到了。</li>
<li>对于类的函数来说，成员函数有一个隐含的参数为this指针。相当于Python的self。</li>
<li>**typeid（）**是RTTI的机制，也就是访问虚表的type_info信息。</li>
<li>dynamic_cast 也是RTTI的机制</li>
</ol>
<h3 id="各种类型转换"><a class="markdownIt-Anchor" href="#各种类型转换"></a> 各种类型转换</h3>
<p><img src="/img/%E9%80%9F%E9%80%9Aeffective-modern-cpp/image-20250309204639866.png" alt="image-20250309204639866"></p>
<ol>
<li>static_cast 静态类型转换，这是在编译期间完成的类型转换。
<ul>
<li>子类可以转化成父类。反之不行。</li>
</ul>
</li>
</ol>
<p><img src="/img/%E9%80%9F%E9%80%9Aeffective-modern-cpp/image-20250309204908364.png" alt="image-20250309204908364"></p>
<ol start="2">
<li>dynamic_cast 动态类型转换，在运行期间判断</li>
</ol>
<p><img src="/img/%E9%80%9F%E9%80%9Aeffective-modern-cpp/image-20250309204931074.png" alt="image-20250309204931074"></p>
<ol start="3">
<li>const_cast 增加一个底层const，或者去掉一个底层const
<ul>
<li>虽然可以去掉const，但是操作的时候该段错误还是段错误。</li>
<li>用途是可以<strong>重载const函数。减少代码重复。</strong></li>
</ul>
</li>
</ol>
<p><img src="/img/%E9%80%9F%E9%80%9Aeffective-modern-cpp/image-20250309205308978.png" alt="image-20250309205308978"></p>
<ol start="4">
<li>reinterpret_cast 是重新解释，是最强的类型转换
<ul>
<li>是静态类型转换，是编译期间发生的。</li>
<li>与C语言的强制类型转换略有区别，比如 ： int x = (float)y;  在C语言中，会进行类型转换。但是reinterpret_cast不会进行类型转换，反而告诉你不能转换。</li>
<li>要求两个东西必须 sizeof 相等。</li>
<li>更多用于指针包括整型之间的转换。</li>
</ul>
</li>
</ol>
<h1 id="第二章auto"><a class="markdownIt-Anchor" href="#第二章auto"></a> 第二章：auto</h1>
<h3 id="lambda表达式初探"><a class="markdownIt-Anchor" href="#lambda表达式初探"></a> lambda表达式初探</h3>
<p><img src="/img/%E9%80%9F%E9%80%9Aeffective-modern-cpp/image-20250309205558870.png" alt="image-20250309205558870"></p>
<ol>
<li>
<p>lambda的实现，是实现一个匿名的可调用类，重载了operator ()</p>
<p>例如：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> sz = <span class="number">0</span>; </span><br><span class="line"><span class="keyword">auto</span> Sizecomp = [sz] (<span class="type">const</span> string &amp;a) { <span class="keyword">return</span> a.<span class="built_in">size</span>() &gt; sz; }</span><br></pre></td></tr></tbody></table></figure>
<p>​	-&gt;</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Sizecomp</span> {</span><br><span class="line">	<span class="type">size_t</span> sz;</span><br><span class="line">	<span class="built_in">Sizecomp</span>(<span class="type">size_t</span> sz_) : <span class="built_in">sz</span>(sz_) {}</span><br><span class="line">	<span class="function"><span class="keyword">auto</span> <span class="title">operator</span><span class="params">(<span class="type">const</span> string &amp;a)</span> </span>{ <span class="keyword">return</span> a.<span class="built_in">size</span>() &gt; sz; }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p><img src="/img/%E9%80%9F%E9%80%9Aeffective-modern-cpp/image-20250309211342239.png" alt="image-20250309211342239"></p>
<p><img src="/img/%E9%80%9F%E9%80%9Aeffective-modern-cpp/image-20250309211411411.png" alt="image-20250309211411411"></p>
</li>
<li>
<p>lambda 表达式语法。[captures] (params) specifies exception -&gt; ret { body; }</p>
<ul>
<li>
<p>specfies 默认为 const 相当于类中成员函数的 const 修饰，也即默认不能修改捕获列表中的变量，即使是copy来的变量。</p>
</li>
<li>
<p>exception：可使用noexcept表示函数是否会抛出异常。</p>
</li>
<li>
<p>ret 可选返回类型，大多情况可以自行推导，但<strong>初始化列表不行。</strong></p>
</li>
<li>
<p>params 可选参数列表，since C++14 可以使用 auto</p>
</li>
<li>
<p>capture 捕获列表</p>
<ol>
<li>
<p><strong>只能捕获非静态局部变量</strong>，可按值，按引用或者组合。因为全局变量或者静态变量，<strong>不需要捕获</strong>，按照lambda使用类来实现，是一个局部变量来考虑的话，倒也好理解。</p>
</li>
<li>
<p>**捕获发生在定义，而不是使用时。**这也好理解，lambda是一个局部的对象的示例，当定义之后，就相当于对象的定义以及构造。</p>
</li>
<li>
<p>**广义的捕获（since C++14）：捕获列表客传右值。**这样可以让一个不可拷贝的函数变得可以使用，避免无意义拷贝。</p>
</li>
<li>
<p><strong>特殊的捕获方法</strong></p>
<p>[this] 捕获this指针，可以使用this类型的成员变量与函数。</p>
<p>[=] 捕获所有局部变量的值，包括this。但是是用到哪些才捕获那些，不会实际上全部捕获。</p>
<p>[&amp;] 捕获<sub>，引用</sub></p>
<p>[*this] 捕获*this的<strong>副本</strong>，since C++17</p>
</li>
</ol>
</li>
</ul>
</li>
</ol>
<h3 id="可调用对象类型"><a class="markdownIt-Anchor" href="#可调用对象类型"></a> 可调用对象类型</h3>
<p><img src="/img/%E9%80%9F%E9%80%9Aeffective-modern-cpp/image-20250309212830119.png" alt="image-20250309212830119"></p>
<ol>
<li>
<p>闭包：带有<strong>上下文 (状态)</strong> 的函数。</p>
<ul>
<li>闭包的实现方法：operator()； lambda； std::bind （把一个函数的某个参数特化，有点函数特化的意思）；</li>
<li><strong>为了实现泛型，更加灵活。</strong></li>
</ul>
</li>
<li>
<p>可调用对象和function</p>
<p>C++中的可调用对象</p>
<ul>
<li>
<p>函数  -&gt; <strong>可退化为函数指针</strong></p>
</li>
<li>
<p>函数指针</p>
</li>
<li>
<p>lambda -&gt; 当<strong>捕获列表</strong>一无所有的时候，可退化为函数指针</p>
</li>
<li>
<p>std::bind：</p>
<p>std::bind(callable, arg1, arg2, arg3,….)；callable为可调用对象，如果为类的非静态成员函数，需要在arg1传入对象实例的指针，相当于传this。std::placeholders::_1 等占位符可以用来占位。</p>
</li>
<li>
<p>重载operator() 的类</p>
</li>
</ul>
<p>这五种类型都不同，他们五个不能完全相互转换。</p>
<p>但是<strong>std::function</strong>可以容纳他们五种所有的可调用对象。</p>
</li>
</ol>
<h2 id="条款五优先考虑auto而非显示类型声明"><a class="markdownIt-Anchor" href="#条款五优先考虑auto而非显示类型声明"></a> 条款五：优先考虑auto而非显示类型声明</h2>
<p><img src="/img/%E9%80%9F%E9%80%9Aeffective-modern-cpp/image-20250310185634874.png" alt="image-20250310185634874"></p>
<p><img src="/img/%E9%80%9F%E9%80%9Aeffective-modern-cpp/image-20250310185808816.png" alt="image-20250310185808816"></p>
<p><img src="/img/%E9%80%9F%E9%80%9Aeffective-modern-cpp/image-20250310190018184.png" alt="image-20250310190018184"></p>
<p><img src="/img/%E9%80%9F%E9%80%9Aeffective-modern-cpp/image-20250310190048993.png" alt="image-20250310190048993"></p>
<ol>
<li>
<p>lambda返回值一定要用auto？这不一定，可以用std::function，不过这有一定的性能损耗</p>
</li>
<li>
<p>避免copy，比如：for(auto &amp;p : map) 和 for(const std::pair&lt;int, int&gt; &amp;p : map)，其中类型是错误的，可能会出现一个隐藏的copy。</p>
</li>
</ol>
<h3 id="crtp与expression-templates"><a class="markdownIt-Anchor" href="#crtp与expression-templates"></a> CRTP与Expression Templates</h3>
<p><img src="/img/%E9%80%9F%E9%80%9Aeffective-modern-cpp/image-20250310190948061.png" alt="image-20250310190948061"></p>
<p><img src="/img/%E9%80%9F%E9%80%9Aeffective-modern-cpp/image-20250310191042303.png" alt="image-20250310191042303"></p>
<p><img src="/img/%E9%80%9F%E9%80%9Aeffective-modern-cpp/image-20250310191426979.png" alt="image-20250310191426979"></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/HaoBBNuanMM/article/details/109740504">【编程技术】C++ CRTP &amp; Expression Templates_crtp与expression templates-CSDN博客</a></p>
<ol>
<li>
<p>CRTP 奇异模板递归：</p>
<p>编译器多态实现运行时多态。而且没有查虚表的过程。</p>
</li>
<li>
<p>Expression Templates表达式模板: 延时计算与节省表达式中间结果。</p>
<p>这个在高性能计算中非常强大。</p>
<p>例如：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector v0 = {<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>}, v1 = {<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>}, v2 = {<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>};</span><br><span class="line"><span class="keyword">auto</span> v3 = v0 + v1 + v2; <span class="comment">// 中间有临时变量的存在，导致非常低效</span></span><br></pre></td></tr></tbody></table></figure>
</li>
</ol>
<p>​	延时计算：推迟计算，直到需要结果。</p>
<p><img src="/img/%E9%80%9F%E9%80%9Aeffective-modern-cpp/885b8531b7c266da2093a935283ded46.png" alt="img"></p>
<p>​	也就是说把运算符转化为一个模板类，直到通过模板类来获取结果的时候才进行计算。</p>
<p>​	<strong>优点是直到需要才计算</strong>，缺点是每次访问都需要计算。</p>
<p>​	模板类它本身不存储结果。</p>
<p>​	相当于把运算结果委托给一个模板类，在通过这个委托模板类来获取计算结果时，这个时候模板类才进行计算。</p>
<p>​	就是下面所说的代理类。</p>
<h2 id="auto推导若非己愿则使用显示类型声明"><a class="markdownIt-Anchor" href="#auto推导若非己愿则使用显示类型声明"></a> auto推导若非己愿，则使用显示类型声明</h2>
<ol>
<li>
<p>代理类，代理类就是模仿和增强一些类型的行为为目的而存在的类。</p>
<p>比如：std::vector<bool>::reference 来引用 std:;vector<bool> 的bit。</bool></bool></p>
<p>比如：智能指针是代理类，实现对原始指针的封装。</p>
</li>
<li>
<p>C++不允许一个类型到另一个类型两次隐式类型转换。</p>
</li>
<li>
<p>临时变量的引用，不要用引用来接。也就是不要对临时变量来引用。</p>
<p>例如：A &amp;a = func()[2];  其中 func 返回一个临时变量。</p>
</li>
<li>
<p>第一点和第三点结合起来，可能会导致 auto 推导出一个对临时代理类的引用。</p>
</li>
<li>
<p>请记住：</p>
<ul>
<li>不可见的代理类可能会使 auto 从表达式中推导出不期望得到的类型</li>
<li>显式类型初始化惯用法强制 auto 推导出你想要的类型</li>
</ul>
</li>
</ol>
<h1 id="第三章移步现代c"><a class="markdownIt-Anchor" href="#第三章移步现代c"></a> 第三章：移步现代C++</h1>
<h2 id="条款八优先考虑nullptr而非null和0"><a class="markdownIt-Anchor" href="#条款八优先考虑nullptr而非null和0"></a> 条款八：优先考虑nullptr，而非NULL和0</h2>
<p><img src="/img/%E9%80%9F%E9%80%9Aeffective-modern-cpp/image-20250310200449985.png" alt="image-20250310200449985"></p>
<ul>
<li>
<p>因为 NULL 和 0 是 long 类型，而非指针类型。当重载时，会导致调用与期望不符的函数。</p>
</li>
<li>
<p>使用模板时，<strong>NULL 和 0 可能会导致 long 或 int 类型的模板实例化</strong>，这是灾难性的。</p>
</li>
<li>
<p>nullptr可以保证是一个指针。</p>
</li>
</ul>
<h3 id="构造函数语义学"><a class="markdownIt-Anchor" href="#构造函数语义学"></a> 构造函数语义学</h3>
<p><img src="/img/%E9%80%9F%E9%80%9Aeffective-modern-cpp/image-20250310201144798.png" alt="image-20250310201144798"></p>
<ol>
<li>
<p>编译器是何如完善构造函数的。</p>
<ol>
<li>列表初始化先于构造函数。</li>
<li>基类存在默认构造函数，编译器负责按插子类构造函数。</li>
<li>如果存在虚表指针，编译器进行虚表指针的安放。</li>
</ol>
</li>
<li>
<p>如果定义的class中没有默认的构造函数</p>
<ol>
<li>如果编译器需要做什么，那么会构造默认的构造函数。</li>
<li>否则，编译器不会合成默认构造函数。</li>
</ol>
</li>
<li>
<p>基类如果没有默认构造函数，子类需要手动初始化，这显然。</p>
</li>
<li>
<p>使用 using 去掉子类中冗余的构造函数。using Base::Base; 可以直接使用父类的构造函数。</p>
</li>
</ol>
<h2 id="尽量使用constexpr"><a class="markdownIt-Anchor" href="#尽量使用constexpr"></a> 尽量使用constexpr</h2>
<p><img src="/img/%E9%80%9F%E9%80%9Aeffective-modern-cpp/image-20250310202341274.png" alt="image-20250310202341274"></p>
<p><img src="/img/%E9%80%9F%E9%80%9Aeffective-modern-cpp/image-20250310203256292.png" alt="image-20250310203256292"></p>
<p><img src="/img/%E9%80%9F%E9%80%9Aeffective-modern-cpp/image-20250310204950376.png" alt="image-20250310204950376"></p>
<ol>
<li>
<p>const常量的不确定性。</p>
<p>const的常量必须是真正的字面量才会归为编译器常量。</p>
<p>说白了就是增强了const 的能力，让编译器在编译期间能够得知更多的常量。</p>
</li>
<li>
<p>PS：gcc的数组长度支持动态。</p>
</li>
<li>
<p>constexpr值，只要用constexpr就确定变量是编译期常量。</p>
<p><strong>所有constexpr都是const，但不是所有const都是constexpr。</strong></p>
</li>
<li>
<p>对函数进行constexpr的修饰</p>
<ul>
<li>
<p>C++11 ： 这个时候的 constexpr 纯废物。</p>
<ol>
<li>普通函数返回值必须返回个什么东西。</li>
<li>普通的 constexpr 函数体只能是 return expr； 只能有一句话。而且expr也必须是一个常量表达式</li>
<li>如果传给 constexpr 函数运行时的值，那么 constexpr 函数会退化成一个普通函数。</li>
<li>constexpr 不能传给形参。</li>
<li>constexpr 构造函数初始化列表必须是常量表达式。</li>
<li>constexpr 构造函数的函数体必须为空</li>
<li>所有用constexpr修饰构造函数的类，析构函数都是默认的。</li>
<li>constexpr声明的成员函数，具有 const 属性。</li>
</ol>
</li>
<li>
<p>C++14对 constexpr 进行了增强。</p>
<ol>
<li>C++11 中 1.、2.、6.、8. 限制被删除。</li>
<li>函数可以**修改生命周期与变量表达式相同的对象。**这是容易理解的。</li>
<li>即可退化也可编译期间。</li>
</ol>
</li>
<li>
<p>C++17可以 if constexpr （***）</p>
<p>比 #if 更加优秀的方法。让一部分东西直接不编译。</p>
</li>
</ul>
<p>constexpr显然会提高编译时间。</p>
</li>
</ol>
<h2 id="条款十七理解特殊成员函数的生成"><a class="markdownIt-Anchor" href="#条款十七理解特殊成员函数的生成"></a> 条款十七：理解特殊成员函数的生成</h2>
<p><img src="/img/%E9%80%9F%E9%80%9Aeffective-modern-cpp/image-20250310210703529.png" alt="image-20250310210703529"></p>
<ol>
<li>
<p>声明这五个特殊成员函数之一，那么剩下四个也应该声明出来。</p>
<p>原因：只有需要手动管理资源的时候，才会声明这些函数。</p>
</li>
<li>
<p>C++11以及之后，声明 上图1/2/3 不会生成 4/5.</p>
</li>
<li>
<p>移动构造和复制更像是一种请求，这个时候不会生成默认移动构造函数，就会有问题，导致代码很低效。</p>
</li>
<li>
<p>析构函数如果不声明，永远会自动生成。显然对象必须析构。</p>
</li>
</ol>
<h3 id="c中的异常处理与swap-copy"><a class="markdownIt-Anchor" href="#c中的异常处理与swap-copy"></a> C++中的异常处理与swap &amp; copy</h3>
<p><img src="/img/%E9%80%9F%E9%80%9Aeffective-modern-cpp/image-20250310212625906.png" alt="image-20250310212625906"></p>
<ol>
<li>
<p>异常处理的手段</p>
<p>抛出异常：throw 异常； 然后给调用者，层层递进。</p>
<p>接住异常：catch异常；</p>
<p>如果异常是因为内存不足导致的，那么catch时还是用copy的话可能会出现意想不到的问题。</p>
</li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="https://Dog-Du.github.io">DogDu</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="https://dog-du.github.io/2024/03/09/%E9%80%9F%E9%80%9Aeffective-modern-cpp/">https://dog-du.github.io/2024/03/09/%E9%80%9F%E9%80%9Aeffective-modern-cpp/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%85%AB%E8%82%A1/">八股</a><a class="post-meta__tags" href="/tags/%E6%9C%AA%E5%AE%8C%E6%88%90/">未完成</a><a class="post-meta__tags" href="/tags/C/">C++</a></div><div class="post-share"><div class="social-share" data-image="/img/top_img.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2024/02/05/CMU15445%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="CMU15445学习笔记（已完结）"><img class="cover" src="/img/top_img.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">Previous</div><div class="info-item-2">CMU15445学习笔记（已完结）</div></div><div class="info-2"><div class="info-item-1">CMU15445的LAB完成记录，本体不含代码，但包括代码仓库</div></div></div></a><a class="pagination-related" href="/2024/03/10/%E8%AE%A1%E7%BD%91%E5%85%AB%E8%82%A1/" title="计网八股"><img class="cover" src="/img/top_img.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">Next</div><div class="info-item-2">计网八股</div></div><div class="info-2"><div class="info-item-1">看小林coding，嗯背计网八股</div></div></div></a></nav><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> Comments</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/head.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">DogDu</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">14</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">10</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">2</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Dog-Du"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is DogDu's Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC"><span class="toc-text"> 第一章：类型推导</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B6%E5%B1%82const%E5%92%8C%E5%BA%95%E5%B1%82const"><span class="toc-text"> 顶层const和底层const</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%80%BC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8"><span class="toc-text"> 值类型与右值引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC"><span class="toc-text"> 类型推导</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE%E4%B8%80%E7%90%86%E8%A7%A3%E6%A8%A1%E6%9D%BF%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC"><span class="toc-text"> 条款一：理解模板类型推导</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE%E4%B8%83%E5%8C%BA%E5%88%AB%E4%BD%BF%E7%94%A8%E4%B8%8E-%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1"><span class="toc-text"> 条款七：区别使用（）与 {} 创建对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE%E4%BA%8C%E7%90%86%E8%A7%A3auto%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC"><span class="toc-text"> 条款二：理解auto类型推导</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE%E4%B9%9D%E4%BC%98%E5%85%88%E8%80%83%E8%99%91%E5%88%AB%E5%90%8D%E5%A3%B0%E6%98%8E%E8%80%8C%E9%9D%9Etypedef"><span class="toc-text"> 条款九：优先考虑别名声明而非typedef</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE%E4%BA%8C%E5%8D%81%E4%B8%89%E7%90%86%E8%A7%A3stdmove%E5%92%8Cstdforward"><span class="toc-text"> 条款二十三：理解std::move和std::forward</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE%E4%B8%89%E7%90%86%E8%A7%A3delctype"><span class="toc-text"> 条款三：理解delctype</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#c%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B8%83%E5%B1%80"><span class="toc-text"> C++类对象的布局</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#c%E4%B8%AD%E7%9A%84%E5%A4%9A%E6%80%81%E5%92%8Crtti"><span class="toc-text"> C++中的多态和RTTI</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%84%E7%A7%8D%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-text"> 各种类型转换</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0auto"><span class="toc-text"> 第二章：auto</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%88%9D%E6%8E%A2"><span class="toc-text"> lambda表达式初探</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E8%B0%83%E7%94%A8%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B"><span class="toc-text"> 可调用对象类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE%E4%BA%94%E4%BC%98%E5%85%88%E8%80%83%E8%99%91auto%E8%80%8C%E9%9D%9E%E6%98%BE%E7%A4%BA%E7%B1%BB%E5%9E%8B%E5%A3%B0%E6%98%8E"><span class="toc-text"> 条款五：优先考虑auto而非显示类型声明</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#crtp%E4%B8%8Eexpression-templates"><span class="toc-text"> CRTP与Expression Templates</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#auto%E6%8E%A8%E5%AF%BC%E8%8B%A5%E9%9D%9E%E5%B7%B1%E6%84%BF%E5%88%99%E4%BD%BF%E7%94%A8%E6%98%BE%E7%A4%BA%E7%B1%BB%E5%9E%8B%E5%A3%B0%E6%98%8E"><span class="toc-text"> auto推导若非己愿，则使用显示类型声明</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%A7%BB%E6%AD%A5%E7%8E%B0%E4%BB%A3c"><span class="toc-text"> 第三章：移步现代C++</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE%E5%85%AB%E4%BC%98%E5%85%88%E8%80%83%E8%99%91nullptr%E8%80%8C%E9%9D%9Enull%E5%92%8C0"><span class="toc-text"> 条款八：优先考虑nullptr，而非NULL和0</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E8%AF%AD%E4%B9%89%E5%AD%A6"><span class="toc-text"> 构造函数语义学</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%BD%E9%87%8F%E4%BD%BF%E7%94%A8constexpr"><span class="toc-text"> 尽量使用constexpr</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE%E5%8D%81%E4%B8%83%E7%90%86%E8%A7%A3%E7%89%B9%E6%AE%8A%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E7%9A%84%E7%94%9F%E6%88%90"><span class="toc-text"> 条款十七：理解特殊成员函数的生成</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#c%E4%B8%AD%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E4%B8%8Eswap-copy"><span class="toc-text"> C++中的异常处理与swap &amp; copy</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Posts</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/03/CSAPP%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/" title="CSAPP学习记录（已完结）">CSAPP学习记录（已完结）</a><time datetime="2025-03-03T12:44:15.000Z" title="Created 2025-03-03 20:44:15">2025-03-03</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/03/10/%E8%AE%A1%E7%BD%91%E5%85%AB%E8%82%A1/" title="计网八股">计网八股</a><time datetime="2024-03-10T00:54:15.000Z" title="Created 2024-03-10 08:54:15">2024-03-10</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/03/09/%E9%80%9F%E9%80%9Aeffective-modern-cpp/" title="听课，速通effective-modern-cpp">听课，速通effective-modern-cpp</a><time datetime="2024-03-09T13:54:15.000Z" title="Created 2024-03-09 21:54:15">2024-03-09</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By DogDu</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.3</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="Scroll to Comments"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null

  const commentCount = n => {
    const isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
    if (isCommentCount) {
      isCommentCount.textContent= n
    }
  }

  const initGitalk = (el, path) => {
    if (isShuoshuo) {
      window.shuoshuoComment.destroyGitalk = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }

    const gitalk = new Gitalk({
      clientID: 'Ov23lip70wbjDSj3yXVa',
      clientSecret: '229af146a5a288cca20082b54bcaf2ea896347af',
      repo: 'Dog-Du.github.io',
      owner: 'Dog-Du',
      admin: ['Dog-Du'],
      updateCountCallback: commentCount,
      ...option,
      id: (decodeURIComponent(location.pathname)).substring(0, 48),
      distractionFreeMode: false
    })

    gitalk.render('gitalk-container')
  }

  const loadGitalk = async(el, path) => {
    if (typeof Gitalk === 'function') initGitalk(el, path)
    else {
      await btf.getCSS('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css')
      await btf.getScript('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js')
      initGitalk(el, path)
    }
  }

  if (isShuoshuo) {
    'Gitalk' === 'Gitalk'
      ? window.shuoshuoComment = { loadComment: loadGitalk }
      : window.loadOtherComment = loadGitalk
    return
  }

  if ('Gitalk' === 'Gitalk' || !false) {
    if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
    else loadGitalk()
  } else {
    window.loadOtherComment = loadGitalk
  }
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>